# C++

<details><summary>Nh·∫•p v√†o ƒë·ªÉ xem chi ti·∫øt</summary>
<p>

<details><summary><b>Class</b></summary>
<p>

<details><summary><b>1. Gi·ªõi thi·ªáu v·ªÅ Class </b></summary>
<p>

- Trong C++, **class** l√† m·ªôt ki·ªÉu d·ªØ li·ªáu do ng∆∞·ªùi d√πng ƒë·ªãnh nghƒ©a, d√πng ƒë·ªÉ nh√≥m c√°c bi·∫øn (thu·ªôc t√≠nh) v√† h√†m (ph∆∞∆°ng th·ª©c) c√≥ li√™n quan l·∫°i v·ªõi nhau. N√≥ l√† m·ªôt ph·∫ßn c·ªët l√µi c·ªßa l·∫≠p tr√¨nh h∆∞·ªõng ƒë·ªëi t∆∞·ª£ng (OOP - Object-Oriented Programming).
- C√°c th√†nh ph·∫ßn c·ªßa **Class**:

	+ **Ph·∫°m vi truy c·∫≠p** (Access Modifier): **public**, **protected**, **private**
 	+ C√°c th√†nh ph·∫ßn d·ªØ li·ªáu (bi·∫øn hay **property**).
  	+ C√°c ph∆∞∆°ng th·ª©c (h√†m th√†nh ph·∫ßn hay **method**).

- Khai b√°o v√† s·ª≠ d·ª•ng **class**:

```cpp
class <class_name>
{
   <access_modifier>:
      <data_type> property1;
      <data_type> property2;
      ...
      <return_type> <method_name_1>(argument1, argument2, ....);
      <return_type> <method_name_2>(argument1, argument2, ....);
};

<return_type> <class_name>::<method_name1>(argument1, argument2, ....)
{
    ...
}

<return_type> <class_name>::<method_name2>(argument1, argument2, ....)
{
    ...
}
```

<br>

üíª **V√≠ d·ª• 1:**
```cpp
class Person
{
    public:
        string firstName; // property
        string lastName;  // property
        int age;	  // property

        void fullName()   // method
	{  
            cout << firstName << " " << lastName;
        }
}
```

<br>

üíª **V√≠ d·ª• 2:**
```cpp
class SinhVien
{
    public:
        int ID;         // property
        string name;    // property
        string lop;     // property
        void display(); // method
};

void SinhVien::display()
{
    cout << "MSSV: " << ID << endl;
    cout << "T√™n: " << name << endl;
    cout << "L·ªõp: " << lop << endl;
}
```

<br>

</p>
</details>

<details><summary><b>2. Ph·∫°m vi truy c·∫≠p (Access Modifier)</b></summary>
<p>

- Access modifier l√† c√°c "t·ª´" d√πng tr∆∞·ªõc c√°c khai b√°o c·ªßa m·ªôt class, property hay method ƒë·ªÉ th·ªÉ hi·ªán kh·∫£ nƒÉng truy c·∫≠p c·ªßa class, bi·∫øn hay method ƒë√≥ ·ªü c√°c class kh√°c.
- c√≥ 3 access modifier: **public**, **protected**, **private**

<br>

<details><summary><b>üìö public</b></summary>
<p>

- Truy c·∫≠p t·ª´ b√™n trong class th√¥ng qua c√°c method.
- Truy c·∫≠p t·ª´ b√™n ngo√†i class th√¥ng qua c√°c object.

üíª **V√≠ d·ª• 1:**
```cpp
#include <iostream>
#include <string>
using namespace std;

class SinhVien
{
    public:
        int ID;         // property
        string name;    // property
        string lop;     // property
        void display()  // method
	{ 
            cout << "MSSV: " << ID << endl;
            cout << "T√™n: " << name << endl;
            cout << "L·ªõp: " << lop << endl;
        }
};

int main()
{
    SinhVien sv; // sv ƒë∆∞·ª£c g·ªçi l√† object
    sv.ID = 2010117;
    sv.name = "Anh";
    sv.lop = "DD20TD1";
    sv.display();  
    return 0;
}
```

<br>

üíª **V√≠ d·ª• 2:**
```cpp
#include <iostream>
using namespace std;

class HinhChuNhat
{
    public:
        double chieuDai;    // property
        double chieuRong;   // property

    // H√†m t√≠nh di·ªán t√≠ch
    double tinhDienTich()   // method	
    {
        return chieuDai * chieuRong;
    }

    void display(); // method
};

void HinhChuNhat::display(){ cout << " Hello " << "\n"; }

int main()
{
    HinhChuNhat hinh1;
    hinh1.chieuDai = 10.0;
    hinh1.chieuRong = 5.0;
    hinh1.display();
    cout << "Dien tich: " << hinh1.tinhDienTich() << '\n';
    return 0;
}
```

<br>

</p>
</details>

<details><summary><b>üìö private</b></summary>
<p>

- C√°c thu·ªôc t√≠nh m√† b·∫°n kh√¥ng mu·ªën ng∆∞·ªùi kh√°c c√≥ th·ªÉ truy c·∫≠p ƒë·∫øn t·ª´ b√™n ngo√†i s·∫Ω ƒë∆∞·ª£c khai b√°o ·ªü **private**.
- Nh·ªØng property hay method n·∫±m ·ªü **private** th√¨ ch·ªâ c√≥ gi√° tr·ªã t·∫°i class v√† c√°c **object** b√™n ngo√†i kh√¥ng th·ªÉ truy c·∫≠p ƒë·∫øn.
- Mu·ªën truy c·∫≠p c√°c thu·ªôc t√≠nh **private** th√¨ ch·ªâ c√≥ th·ªÉ truy c·∫≠p gi√°n ti·∫øp th√¥ng qua c√°c **method** hay **constructor** n·∫±m trong c√πng **class**.

üíª **V√≠ d·ª•:**
```cpp
#include <iostream>
#include <string>

using namespace std;

class SinhVien
{
    private:
        string name;
        string major;
        int id;
        double gpa;

    public:
        SinhVien()
	{
  	    static int _id = 1;
   	    id = _id;
	    _id++;
	}

	// getter method for name
        string getName(){ return name; }

	// setter method for name
	void setName(string _name){ name = _name; }

	// getter method for major
        string getChuyenNganh(){ return major;}

	// setter method for major
	void setMajor(string _major){ major = _major; }

	// setter method for gpa
        void setGPA(double _gpa){ gpa = _gpa; }

	// getter method for gpa
        double getGPA(){ return gpa; }

	// getter method for id
        int getID(){ return id; }
};

int main(int argc, char const *argv[])
{
    SinhVien sv1("Trung", "DTVT");
    sv1.setName("Tuan");
    sv1.setMajor("Embedded");

    // sv1.ten = "Tuan";        // wrong
    // sv1.id = 10;             // wrong
    // sv1.chuyenNganh = "TDH"; // wrong

    cout << "ID: " << sv1.getID() << endl;
    cout << "Name: " << sv1.getName() << endl;
    cout << "Chuyen nganh: " << sv1.getMajor() << endl;
    return 0;
}
```

üìù Khi ƒë√£ setup m·ªôt s·ªë th√¥ng tin v√† kh√¥ng mu·ªën users c√≥ th·ªÉ truy c·∫≠p v√†o v√† thay ƒë·ªïi ƒë∆∞·ª£c nh·ªØng th√¥ng tin th√¨ ta n√™n khai b√°o n√≥ ·ªü ph·∫°m vi ``` private ```.

üìù Nh·ªØng property n√†o ƒë√£ ƒë∆∞·ª£c khai b√°o ·ªü ph·∫°m vi ``` private ``` th√¨ n√≥ s·∫Ω ch·ªâ c√≥ gi√° tr·ªã n·ªôi b·ªô trong class v√† ch·ªâ c√≥ nh·ªØng metod n·∫±m trong class m·ªõi c√≥ th·ªÉ truy c·∫≠p ƒë·ªÉ thay ƒë·ªïi ƒë∆∞·ª£c.

üìù Vi·ªác ·∫©n ƒëi nh·ªØng property b·∫±ng c√°ch khai b√°o trong ``` private ``` ch√≠nh l√† **t√≠nh ƒë√≥ng g√≥i** trong h∆∞·ªõng ƒë·ªëi t∆∞·ª£ng.

<br>

</p>
</details>

<details><summary><b>üìö protected</b></summary>
<p>

- C√°c method v√† property n·∫±m ·ªü protected kh√¥ng th·ªÉ truy c·∫≠p t·ª´ c√°c object b√™n ngo√†i.
- C√°c method v√† property n·∫±m ·ªü protected c√≥ th·ªÉ truy c·∫≠p tr·ª±c ti·∫øp t·ª´ c√°c method b√™n trong class.
- C√°c method v√† property n·∫±m ·ªü protected c√≤n c√≥ th·ªÉ truy c·∫≠p th√¥ng qua c√°c class **k·∫ø th·ª´a**.


üíª **V√≠ d·ª• 1:**
```cpp
#include <iostream>
using namespace std;

class Base
{
    protected:
        int protectedVar;

    public:
        Base() : protectedVar(10){}
};

class Derived : public Base
{
    public: 
        void showProtectedVar()
        {
            cout << "Protected variable: " << protectedVar << endl;
        }
};

int main(int argc, char const *argv[])
{
    Derived obj;
    // obj.protectedVar = 10; // wrong
    obj.showProtectedVar();   // right
    return 0;
}
```

<br>

üíª **V√≠ d·ª• 2:**
```cpp
#include <iostream>
#include <string>
using namespace std;

class DoiTuong
{
    protected:
	string name;
	string id;
	int id;
	double gpa;
};

class SinhVien : public DoiTuong
{
    public:
        SinhVien()
	{
  	    static int _id = 1;
   	    id = _id;
	    _id++;
	}

	// getter method for name
        string getName(){ return name; }

	// setter method for name
	void setName(string _name){ name = _name; }

	// getter method for major
        string getChuyenNganh(){ return major;}

	// setter method for major
	void setMajor(string _major){ major = _major; }

	// setter method for gpa
        void setGPA(double _gpa){ gpa = _gpa; }

	// getter method for gpa
        double getGPA(){ return gpa; }

	// getter method for id
        int getID(){ return id; }
};

int main(int argc, char const *argv[])
{
    SinhVien sv1("Trung", "DTVT");
    sv1.setName("Tuan");
    sv1.setMajor("Embedded");

    // sv1.ten = "Tuan";        // wrong
    // sv1.id = 10;             // wrong
    // sv1.chuyenNganh = "TDH"; // wrong

    cout << "ID: " << sv1.getID() << endl;
    cout << "Name: " << sv1.getName() << endl;
    cout << "Chuyen nganh: " << sv1.getMajor() << endl;
    return 0;
}
```

<br>

</p>
</details>

</p>
</details>

<details><summary><b>3. Constructor (Ph∆∞∆°ng th·ª©c kh·ªüi t·∫°o) </b></summary>
<p>

- Constructor l√† m·ªôt method c√≥ **t√™n tr√πng v·ªõi t√™n c·ªßa class**.
- Constructor c√≥ th·ªÉ ƒë∆∞·ª£c khai b√°o ·ªü c·∫£ ba ph·∫°m vi public, protected, private.
- Constructor th∆∞·ªùng ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ kh·ªüi t·∫°o gi√° tr·ªã ban ƒë·∫ßu cho c√°c property trong class.

<br>

<details><summary><b>üìö Constructor v·ªõi access modifier l√† PUBLIC</b></summary>
<p>

- Constructor s·∫Ω ƒë∆∞·ª£c t·ª± ƒë·ªông g·ªçi khi kh·ªüi t·∫°o object (b√™n trong l·∫´n ngo√†i **class**).
- Constructor c√≥ th·ªÉ c√≥ tham s·ªë truy·ªÅn v√†o ho·∫∑c kh√¥ng.

<br>

üíª **Constructor kh√¥ng c√≥ tham s·ªë truy·ªÅn v√†o**
```cpp
#include <iostream>
using namespace std;

class HinhChuNhat
{
    public:
        double chieuDai;
        double chieuRong;

        HinhChuNhat()
	{				
             chieuDai  = 10;
             chieuRong = 9;
        }

        // H√†m t√≠nh di·ªán t√≠ch
        double tinhDienTich(){ return chieuDai * chieuRong; }
};

int main()
{
    HinhChuNhat hinh1;
    cout << "Chieu dai: " << hinh1.chieuDai << '\n';
    cout << "Chieu rong: " << hinh1.chieuRong << '\n';
    cout << "Dien tich: " << hinh1.tinhDienTich() << '\n';
    return 0;
}
```

<br>

üíª **Constructor c√≥ tham s·ªë truy·ªÅn v√†o, kh√¥ng c√≥ gi√° tr·ªã m·∫∑c ƒë·ªãnh**
```cpp
#include <iostream>
using namespace std;

class HinhChuNhat
{
    public:
        double chieuDai;
        double chieuRong;

        HinhChuNhat(int dai, int rong);

        double tinhDienTich()
        {
            return chieuDai * chieuRong;
        }
};

HinhChuNhat::HinhChuNhat(int dai, int rong)
{
    chieuDai = dai;
    chieuRong = rong;
}

int main()
{
    int a,b;
    cout << "Nhap chieu dai: ";  cin >> a;
    cout << "Nhap chieu rong: "; cin >> b;

    HinhChuNhat hinh3(a,b); 	// l·∫•y gi√° tr·ªã m·ªõi nh·∫≠p t·ª´ b√†n ph√≠m
    cout << "Chieu dai: " << hinh3.chieuDai << '\n';
    cout << "Chieu rong: " << hinh3.chieuRong << '\n';
    cout << "Dien tich: " << hinh3.tinhDienTich() << '\n';
    return 0;
}
```

<br>

üíª **Constructor c√≥ tham s·ªë truy·ªÅn v√†o, c√≥ gi√° tr·ªã m·∫∑c ƒë·ªãnh**
```cpp
#include <iostream>
using namespace std;

class HinhChuNhat
{
    public:
        double chieuDai;
        double chieuRong;

        HinhChuNhat(int dai = 3, int rong = 5);

        double tinhDienTich()
        {
            return chieuDai * chieuRong;
        }
};

HinhChuNhat::HinhChuNhat(int dai, int rong)
{
    chieuDai = dai;
    chieuRong = rong;
}

int main()
{
    HinhChuNhat hinh1; 		// l·∫•y gi√° tr·ªã m·∫∑c ƒë·ªãnh (3,5)
    cout << "Chieu dai: " << hinh1.chieuDai << '\n';
    cout << "Chieu rong: " << hinh1.chieuRong << '\n';
    cout << "Dien tich: " << hinh1.tinhDienTich() << '\n';

    HinhChuNhat hinh2(10,20); 	// l·∫•y gi√° tr·ªã m·ªõi
    cout << "Chieu dai: " << hinh2.chieuDai << '\n';
    cout << "Chieu rong: " << hinh2.chieuRong << '\n';
    cout << "Dien tich: " << hinh2.tinhDienTich() << '\n';

    int a,b;
    cout << "Nhap chieu dai: ";  cin >> a;
    cout << "Nhap chieu rong: "; cin >> b;

    HinhChuNhat hinh3(a,b); 	// l·∫•y gi√° tr·ªã m·ªõi nh·∫≠p t·ª´ b√†n ph√≠m
    cout << "Chieu dai: " << hinh3.chieuDai << '\n';
    cout << "Chieu rong: " << hinh3.chieuRong << '\n';
    cout << "Dien tich: " << hinh3.tinhDienTich() << '\n';
    return 0;
}
```
üìù Khi constructor c√≥ tham s·ªë truy·ªÅn s·ªë nh∆∞ng kh√¥ng c√≥ gi√° tr·ªã m·∫∑c ƒë·ªãnh th√¨ c√°c object khi kh·ªüi t·∫°o **b·∫Øt bu·ªôc** ph·∫£i truy·ªÅn gi√° tr·ªã cho c√°c tham s·ªë.

üìù Khi constructor c√≥ tham s·ªë truy·ªÅn v√†o v√† c√≥ gi√° tr·ªã m·∫∑c ƒë·ªãnh:

üìù N·∫øu object ƒë∆∞·ª£c kh·ªüi t·∫°o kh√¥ng c√≥ tham s·ªë truy·ªÅn v√†o th√¨ m·∫∑c ƒë·ªãnh l·∫•y 2 gi√° tr·ªã ƒë√£ kh·ªüi t·∫°o ph√≠a tr√™n.

üìù N·∫øu object ƒë∆∞·ª£c kh·ªüi t·∫°o v√† truy·ªÅn v√†o gi√° tr·ªã m·ªõi th√¨ n√≥ s·∫Ω ghi ƒë√® l√™n gi√° tr·ªã c≈© v√† c√°c l·ªánh th·ª±c thi ph√≠a sau s·∫Ω l·∫•y gi√° tr·ªã m·ªõi.

<br>

üíª **Initialization List**
```cpp
#include <iostream>

using namespace std;

class HinhChuNhat
{
    public:
        double chieuDai;
        double chieuRong;

        HinhChuNhat(int dai = 3, int rong = 5): chieuDai(dai), chieuRong(rong){}	// initialization list

        // H√†m t√≠nh di·ªán t√≠ch
        double tinhDienTich()
        {
            return chieuDai * chieuRong;
        }
};
int main(){
    HinhChuNhat hinh1;
    cout << "Chieu dai: " << hinh1.chieuDai << '\n';
    cout << "Chieu rong: " << hinh1.chieuRong << '\n';
    cout << "Dien tich: " << hinh1.tinhDienTich() << '\n';
    return 0;
}
```

<br>

</p>
</details>

<details><summary><b>üìö Constructor v·ªõi access modifier l√† PROTECTED</b></summary>
<p>

-  object kh√¥ng th·ªÉ ƒë∆∞·ª£c kh·ªüi t·∫°o tr·ª±c ti·∫øp t·ª´ b√™n ngo√†i class, m√† ch·ªâ c√≥ th·ªÉ ƒë∆∞·ª£c kh·ªüi t·∫°o t·ª´ c√°c class k·∫ø th·ª´a ho·∫∑c c√°c method b√™n trong class ƒë√≥.

üíª **V√≠ d·ª•:**
```cpp
#include <iostream>
using namespace std;

class Base
{
    protected:
        Base()
        {
            cout << "Protected constructor called!" << endl;
        }
};

class Derived : public Base
{
    public:
        Derived() : Base()	// C√≥ th·ªÉ g·ªçi constructor protected c·ªßa class Base
	{  
            cout << "Derived constructor called!" << endl;
        }
};

int main()
{
    // Base obj;  // L·ªói: Kh√¥ng th·ªÉ kh·ªüi t·∫°o ƒë·ªëi t∆∞·ª£ng Base t·ª´ b√™n ngo√†i
    Derived obj;  // H·ª£p l·ªá: C√≥ th·ªÉ kh·ªüi t·∫°o Derived, class con c·ªßa Base
    return 0;
}
```

<br>

</p>
</details>

<details><summary><b>üìö Constructor v·ªõi access modifier l√† PRIVATE</b></summary>
<p>

- Kh√¥ng ai c√≥ th·ªÉ kh·ªüi t·∫°o ƒë·ªëi t∆∞·ª£ng c·ªßa class t·ª´ b√™n ngo√†i, k·ªÉ c·∫£ class con. Th∆∞·ªùng ƒë∆∞·ª£c s·ª≠ d·ª•ng trong c√°c **singleton pattern** (T·∫°o 1 ƒë·ªëi t∆∞·ª£ng duy nh·∫•t v√† constructor c≈©ng ch·∫°y 1 l·∫ßn duy nh·∫•t) ho·∫∑c c√°c tr∆∞·ªùng h·ª£p m√† mu·ªën ki·ªÉm so√°t ch·∫∑t ch·∫Ω vi·ªác t·∫°o ƒë·ªëi t∆∞·ª£ng.

üíª **V√≠ d·ª•:**
```cpp
class MyClass
{
	private:
	    MyClass()
	    {
	        cout << "Private constructor called!" << endl;
	    }
	
	public:
	    static MyClass createInstance()
	    {
	        return MyClass();  // C√≥ th·ªÉ kh·ªüi t·∫°o t·ª´ b√™n trong class v·ªõi method static
	    }
};

int main()
{
    // MyClass obj;  // L·ªói: Kh√¥ng th·ªÉ kh·ªüi t·∫°o ƒë·ªëi t∆∞·ª£ng t·ª´ b√™n ngo√†i
    MyClass obj = MyClass::createInstance();  // H·ª£p l·ªá: S·ª≠ d·ª•ng ph∆∞∆°ng th·ª©c static ƒë·ªÉ t·∫°o ƒë·ªëi t∆∞·ª£ng
    return 0;
}
```

<br>

</p>
</details>

</p>
</details>

<details><summary><b>4. Destructor (Ph∆∞∆°ng th·ª©c h·ªßy) </b></summary>
<p>

- T∆∞∆°ng t·ª± v·ªõi Constructor, Destructor c≈©ng l√† m·ªôt method v√† c√≥ t√™n tr√πng v·ªõi t√™n class nh∆∞ng c√≥ th·ªÉ k√Ω t·ª± **~** ·ªü ph√≠a tr∆∞·ªõc t√™n.
- Destructor khi khai b√°o trong ph·∫°m vi public s·∫Ω ƒë∆∞·ª£c t·ª± ƒë·ªông g·ªçi khi object ƒë∆∞·ª£c gi·∫£i ph√≥ng.
- Trong class, object b·∫£n ch·∫•t c≈©ng l√† 1 bi·∫øn c·ª•c b·ªô n√™n n√≥ s·∫Ω ƒë∆∞·ª£c l∆∞u trong ph√¢n v√πng Stack v√† khi k·∫øt th√∫c h√†m th√¨ c≈©ng b·ªã thu h·ªìi nh∆∞ng ƒë·ªëi v·ªõi **destructor**, tr∆∞·ªõc khi thu h·ªìi s·∫Ω t·ª± ƒë·ªông kh·ªüi ch·∫°y.

<br>

üíª **V√≠ d·ª•:**
```cpp
#include <iostream>
#include <string>
using namespace std;

class HinhChuNhat
{
    public:
        string name;
        double chieuDai;
        double chieuRong;

    HinhChuNhat(string ten)
    { 
        HinhChuNhat::name = ten;
        cout << "Khoi tao object: " << name << endl;
    }

    ~HinhChuNhat()
    {
        cout << "Destructor: " << name << '\n';
    }


    // H√†m t√≠nh di·ªán t√≠ch
    double tinhDienTich(){ return chieuDai * chieuRong; }
};

void test()
{
    HinhChuNhat hinh1("Hinh1");
    HinhChuNhat hinh2("Hinh2");
}

int main(int argc, char const *argv[])
{
    test();
    return 0;
}
```

**K·∫øt qu·∫£:**
```cpp
Khoi tao object: Hinh1
Khoi tao object: Hinh2
Destructor: Hinh2
Destructor: Hinh1
```

üìù ``` hinh1("Hinh1") ```, ``` hinh2("Hinh2") ``` b·∫£n ch·∫•t ƒë·ªÅu 2 bi·∫øn c·ª•c b·ªô v√† l∆∞u trong Stack

üìù object ``` hinh1("Hinh1") ``` ƒë∆∞·ª£c kh·ªüi t·∫°o tr∆∞·ªõc n√™n ƒë∆∞·ª£c ƒë∆∞a v√†o Stack tr∆∞·ªõc, c√≤n object ``` hinh2("Hinh2") ``` kh·ªüi t·∫°o sau n√™n ƒë∆∞a v√†o Stack sau c√πng nh∆∞ng khi l·∫•y ra th√¨ object ``` hinh2("Hinh2") ``` l·∫°i ƒë∆∞·ª£c l·∫•y ra tr∆∞·ªõc.

<br> 

</p>
</details>

<details><summary><b>5. Static in Class </b></summary>
<p>

<details><summary><b>üìö Static Property</b></summary>
<p>

Khi m·ªôt property trong class ƒë∆∞·ª£c khai b√°o v·ªõi t·ª´ kh√≥a static:

- T·∫•t c·∫£ c√°c object s·∫Ω d√πng chung ƒë·ªãa ch·ªâ c·ªßa property.
- ƒê·ªãa ch·ªâ c·ªßa property ph·∫£i ƒë∆∞·ª£c kh·ªüi t·∫°o tr∆∞·ªõc khi kh·ªüi t·∫°o object.

<br>

üíª **V√≠ d·ª•:**
```cpp
#include <iostream>
#include <string>

using namespace std;

class HinhChuNhat
{ 
    public:
        double chieuDai;
        double chieuRong;
        static int var;
};

int HinhChuNhat::var; // 0xa1

int main()
{
    HinhChuNhat hinh1; // 0x01
    HinhChuNhat hinh2; // 0x08

    cout << "address of object hinh 1: " << &hinh1 << '\n';
    cout << "address of chieu dai 1: " << &hinh1.chieuDai << '\n'; 
    cout << "address of chieu rong 1: " << &hinh1.chieuRong << '\n';
    cout << "address of chieu dai 2: " << &hinh2.chieuDai << '\n'; 
    cout << "address of chieu rong 12: " << &hinh2.chieuRong << '\n';

    cout << "address of var: " << &hinh1.var << '\n'; 
    cout << "address of var: " << &hinh2.var << '\n'; 

    return 0;
}
```

**K·∫øt qu·∫£**:
```cpp
address of object hinh 1: 0x7609ffb80
address of chieu dai 1: 0x7609ffb80
address of chieu rong 1: 0x7609ffb88
address of chieu dai 2: 0x7609ffb70
address of chieu rong 12: 0x7609ffb78
address of var: 0x7ff70cbc7030
address of var: 0x7ff70cbc7030
```

![image](https://github.com/user-attachments/assets/1ed9e3c7-c0b0-483a-8df2-cc0e9283a1fe)

<br>

</p>
</details>

<details><summary><b>üìö Static Method</b></summary>
<p>

- Static method l√† m·ªôt method thu·ªôc v·ªÅ class thay v√¨ object c·ªßa class.
- Static method c√≥ th·ªÉ g·ªçi ra m√† kh√¥ng c·∫ßn t·∫°o ƒë·ªëi t∆∞·ª£ng c·ªßa class.
- Static method ch·ªâ c√≥ th·ªÉ truy c·∫≠p c√°c th√†nh vi√™n static kh√°c c·ªßa class (c·∫£ thu·ªôc t√≠nh v√† ph∆∞∆°ng th·ª©c).
- Static method s·∫Ω kh√¥ng c√≥ con tr·ªè ``` this ``` v√¨ kh√¥ng ƒë∆∞·ª£c g·ªçi t·ª´ ƒë·ªëi t∆∞·ª£ng.

üíª **V√≠ d·ª•:**
```cpp
#include <iostream>

using namespace std;

class MyClass
{
public:
    // Static method
    static void showMessage()
    {
        cout << "This is a static method." << endl;
    }

    // Static variable
    static int count;

    // Static method to manipulate static variable
    static void increaseCount()
    {
        count++;
    }
};

// Kh·ªüi t·∫°o bi·∫øn static
int MyClass::count = 0;

int main()
{
    // G·ªçi static method m√† kh√¥ng c·∫ßn t·∫°o ƒë·ªëi t∆∞·ª£ng
    MyClass::showMessage();

    // G·ªçi static method ƒë·ªÉ thao t√°c v·ªõi bi·∫øn static
    MyClass::increaseCount();
    cout << "Count: " << MyClass::count << endl;

    return 0;
}
```

<br>

</p>
</details>

</p>
</details>

<details><summary><b>6. This Pointer </b></summary>
<p>

- this l√† m·ªôt con tr·ªè ƒë·∫∑c bi·ªát c√≥ s·∫µn trong t·∫•t c·∫£ c√°c method th√†nh vi√™n c·ªßa class. N√≥ tr·ªè ƒë·∫øn object hi·ªán t·∫°i ƒëang g·ªçi method ƒë√≥.
- this l√† h·∫±ng con tr·ªè (constant pointer), nghƒ©a l√† this lu√¥n tr·ªè t·ªõi ƒë·ªëi t∆∞·ª£ng hi·ªán t·∫°i v√† b·∫°n kh√¥ng th·ªÉ thay ƒë·ªïi ƒë·ªÉ this tr·ªè t·ªõi ƒë·ªëi t∆∞·ª£ng kh√°c. Tuy nhi√™n, gi√° tr·ªã c·ªßa ƒë·ªëi t∆∞·ª£ng m√† this tr·ªè t·ªõi c√≥ th·ªÉ thay ƒë·ªïi tr·ª´ khi h√†m th√†nh vi√™n ƒë∆∞·ª£c khai b√°o l√† const.
- this ch·ªâ t·ªìn t·∫°i trong c√°c method (ngo·∫°i tr·ª´ static method) c·ªßa class.
- this t·ª± ƒë·ªông ƒë∆∞·ª£c truy·ªÅn khi b·∫°n g·ªçi method c·ªßa m·ªôt object.

<br>

üíª **V√≠ d·ª• 1:**
```cpp
#include <iostream>

using namespace std;

class Student
{
    private:
        int age;

    public:
        Student(int age)
        {
            this->age = age; 	// S·ª≠ d·ª•ng 'this' ƒë·ªÉ tham chi·∫øu ƒë·∫øn th√†nh vi√™n 'age' c·ªßa ƒë·ªëi t∆∞·ª£ng hi·ªán t·∫°i
        }

        Student& setAge(int age)
        {
            this->age = age;
            return *this; 	// Tr·∫£ v·ªÅ ƒë·ªëi t∆∞·ª£ng hi·ªán t·∫°i
        }

        void display()
        {
            cout << "Age: " << this->age << endl;
        }
};

int main()
{
    Student s1(20);
    s1.setAge(21).setAge(22); // G·ªçi li√™n ti·∫øp c√°c ph∆∞∆°ng th·ª©c
    return 0;
}
```

<br>

üíª **V√≠ d·ª• 2:**
```cpp
#include <iostream>
#include <string>

using namespace std;

class Person
{
    private:
        string name;
        int age;
        int id;
    
    public:
        Person(string name, int age)
        {
            static int newID = 0;
            newID++;
            this->id = newID;

            // this = nullptr;
            this->name = name;  // this: constant pointer
            this->age  = age;
        }

        void setName(string newName)
        {
            this->name = newName;
        }

        void setAge(int newAge)
        {
            
            this->age = newAge;
        }

        void changeInfo(string name, int age)
        {
            this->setName(name);
            this->setAge(age);
        }

        string getName() const
        {
            return this->name;
        }

        int getAge() const
        {
            return this->age;
        }

        int getID() 
        {
            return this->id;
        }

        void showAddress()
        {
            cout << "Address of this pointer: " << this << endl;
        }

        void display()
        {
            cout << "Name: " << this->getName() << endl;
            cout << "ID: " << this->getID() << endl;
            cout << "Age: " << this->getAge() << endl;
        }
};

int main(int argc, char const *argv[])
{
    Person person1("Trung", 20);
    Person person2("Anh", 22);

    cout << "Address of object 1: " << &person1 << endl;
    person1.showAddress();

    cout << "Address of object 2: " << &person2 << endl;
    person2.showAddress();

    person1.display();

    person2.display();
    person2.changeInfo("Tuan", 25);
    person2.display();
    return 0;
}
```

<br>

</p>
</details>

</p>
</details>

<br>

<details><summary><b>Object Oriented Programming (OOP)</b></summary>
<p>

<details><summary><b>1. T√≠nh ƒë√≥ng g√≥i (Encapsulation) </b></summary>
<p>

- L√† vi·ªác che gi·∫•u th√¥ng tin b√™n trong ƒë·ªëi t∆∞·ª£ng, ch·ªâ cung c·∫•p nh·ªØng g√¨ c·∫ßn thi·∫øt ra b√™n ngo√†i th√¥ng qua c√°c ph∆∞∆°ng th·ª©c (method). ƒêi·ªÅu n√†y gi√∫p b·∫£o v·ªá d·ªØ li·ªáu v√† gi·∫£m r·ªßi ro kh√¥ng mong mu·ªën.
- Nh·ªØng th√¥ng tin ƒë∆∞·ª£c l∆∞u ·ªü c√°c thu·ªôc t√≠nh (property) s·∫Ω b·ªã ·∫©n ƒëi b·∫±ng c√°ch khai b√°o ·ªü quy·ªÅn truy c·∫≠p ``` private/protected ```.
- Trong tr∆∞·ªùng h·ª£p mu·ªën ƒë·ªçc ho·∫∑c ghi c√°c property n√†y th√¨ ch·ªâ c√≥ th·ªÉ truy c·∫≠p gi√°n ti·∫øp th√¥ng qua c√°c method ·ªü quy·ªÅn truy c·∫≠p ``` public ```.

üíª **V√≠ d·ª•:**
```cpp
#include <iostream>
#include <string>
#include <cctype>   // isdigit, isalpha
using namespace std;

/**
 * @class   SinhVien
 * @brief   L·ªõp ƒë·∫°i di·ªán cho th√¥ng tin c·ªßa sinh vi√™n.
 * @details L·ªõp n√†y bao g·ªìm c√°c thu·ªôc t√≠nh nh∆∞ t√™n, ID, GPA, 
 *          c√°c ph∆∞∆°ng th·ª©c ƒë·ªÉ thi·∫øt l·∫≠p v√† l·∫•y th√¥ng tin c·ªßa sinh vi√™n.
 */
class SinhVien
{
    private:
        string name;   /**< T√™n sinh vi√™n */                    // t√≠nh ƒë√≥ng g√≥i
        int id;        /**< ID sinh vi√™n  */                    // t√≠nh ƒë√≥ng g√≥i
        double gpa;    /**< ƒêi·ªÉm trung b√¨nh */                  // t√≠nh ƒë√≥ng g√≥i

       /**
        * @brief Ki·ªÉm tra t√≠nh h·ª£p l·ªá c·ªßa t√™n sinh vi√™n.
        * @param[in] str Chu·ªói t√™n c·∫ßn ki·ªÉm tra.
        * @return true n·∫øu h·ª£p l·ªá, false n·∫øu c√≥ k√Ω t·ª± kh√¥ng ph·∫£i ch·ªØ c√°i.
        */
        bool checkName(string str)      // t√≠nh tr·ª´u t∆∞·ª£ng
        {
            for (int i=0; i<str.length(); i++)
            {
                if (isdigit(str[i]) || !isalpha(str[i])) return false;
            }
            return true;
        }


       /**
        * @brief Ki·ªÉm tra ƒëi·ªÉm GPA h·ª£p l·ªá.
        * @param[in] newGPA Gi√° tr·ªã GPA c·∫ßn ki·ªÉm tra.
        * @return true n·∫øu GPA h·ª£p l·ªá (0 - 10), false n·∫øu kh√¥ng h·ª£p l·ªá.
        */
        bool checkGPA(double newGPA)
        {
            if (newGPA < 0 || newGPA > 10) return false;
            return true;
        }

    public:
       /**
        * @brief Constructor c·ªßa l·ªõp SinhVien.
        * @details G√°n gi√° tr·ªã ID t·ª± ƒë·ªông tƒÉng khi t·∫°o m·ªõi ƒë·ªëi t∆∞·ª£ng.
        */
        SinhVien()
        {
            static int _ID = 1;
            id = _ID;
            _ID++;
        }

       /**
        * @brief Thi·∫øt l·∫≠p t√™n sinh vi√™n.
        * @param[in] newName T√™n m·ªõi c·ªßa sinh vi√™n.
        * @details N·∫øu t√™n kh√¥ng h·ª£p l·ªá, g√°n gi√° tr·ªã r·ªóng v√† hi·ªÉn th·ªã th√¥ng b√°o l·ªói.
        */
        void setName(string newName)
        {
            // ki·ªÉm tra chu·ªói ƒë·∫ßu v√†o c√≥ h·ª£p l·ªá hay kh√¥ng?
            if (checkName(newName)){
                name = newName;
            } else {
                name = "";
                cout << "T√™n kh√¥ng h·ª£p l·ªá!. Vui l√≤ng nh·∫≠p l·∫°i t√™n\n";
            }   
        }

       /**
        * @brief L·∫•y t√™n sinh vi√™n.
        * @return T√™n sinh vi√™n d∆∞·ªõi d·∫°ng chu·ªói.
        */
        string getName() const { return name; }

       /**
        * @brief L·∫•y ID c·ªßa sinh vi√™n.
        * @return ID c·ªßa sinh vi√™n.
        */
        int getId() const { return id; }

       /**
        * @brief Thi·∫øt l·∫≠p GPA cho sinh vi√™n.
        * @param[in] newGPA Gi√° tr·ªã GPA c·∫ßn thi·∫øt l·∫≠p.
        * @details N·∫øu GPA kh√¥ng h·ª£p l·ªá, ƒë·∫∑t v·ªÅ 0.0 v√† hi·ªÉn th·ªã th√¥ng b√°o l·ªói.
        */
        void setGPA(double newGPA)
        {
            if (checkGPA(newGPA)){
                gpa = newGPA;
            } else {
                gpa = 0.0;
                cout << "ƒêi·ªÉm nh·∫≠p v√†o kh√¥ng h·ª£p l·ªá!. Vui l√≤ng nh·∫≠p l·∫°i\n";
            }
        }

       /**
        * @brief L·∫•y GPA c·ªßa sinh vi√™n.
        * @return Gi√° tr·ªã GPA c·ªßa sinh vi√™n.
        */
        double getGPA() const { return gpa; }
        
       /**
        * @brief Hi·ªÉn th·ªã th√¥ng tin c·ªßa sinh vi√™n.
        * @details In ra m√†n h√¨nh t√™n, ID v√† GPA c·ªßa sinh vi√™n.
        */
        void display()
        {
            cout << "T√™n: " << getName() << endl;
            cout << "ID: " << getId() << endl;
            cout << "GPA: " << getGPA() << endl << endl;
        }
};

int main(int argc, char const *argv[])
{
    SinhVien sv1;
    SinhVien sv2;

    // sv1.name = "Anh1123@@@";
    // sv2.name = "Trung";

    // sv1.id = 1;
    // sv2.id = 1;

    sv1.setName("Anh");
    sv1.setGPA(11);
    sv1.display();

    sv2.setName("Trung");
    sv2.setGPA(8.5);
    sv2.display();
    return 0;
}
```

<br>

<br>

</p>
</details>

<details><summary><b>2. T√≠nh k·∫ø th·ª´a (Inheritance) </b></summary>
<p>

- K·∫ø th·ª´a cho ph√©p m·ªôt class m·ªõi c√≥ th·ªÉ s·ª≠ d·ª•ng l·∫°i c√°c thu·ªôc t√≠nh v√† ph∆∞∆°ng th·ª©c c·ªßa m·ªôt class ƒë√£ c√≥, v√† c√≥ th·ªÉ m·ªü r·ªông th√™m t√≠nh nƒÉng. (t·∫°m g·ªçi l√† class con k·∫ø th·ª´a t·ª´ class cha).
- ƒê·ªÉ k·∫ø th·ª´a t·ª´ class kh√°c, ta d√πng k√Ω t·ª± ``` : ```.
- T·∫•t c·∫£ thu·ªôc t√≠nh v√† ph∆∞∆°ng th·ª©c c√≥ quy·ªÅn truy c·∫≠p l√† ``` public ``` v√† ``` protected ``` ·ªü class cha s·∫Ω ƒë∆∞·ª£c class con k·∫ø th·ª´a.
- C√≥ 3 ki·ªÉu k·∫ø th·ª´a l√† public, private v√† protected.

<details><summary><b>üìö Public Inheritance</b></summary>
<p>

- C√°c member **public** c·ªßa **class cha** v·∫´n s·∫Ω l√† **public** trong **class con**.
- C√°c member **protected** c·ªßa **class cha** v·∫´n s·∫Ω l√† **protected** trong **class con**.
- C√°c member **private** c·ªßa class cha **kh√¥ng th·ªÉ truy c·∫≠p tr·ª±c ti·∫øp t·ª´ class con** nh∆∞ng c√≥ th·ªÉ ƒë∆∞·ª£c truy c·∫≠p gi√°n ti·∫øp qua c√°c ph∆∞∆°ng th·ª©c public ho·∫∑c protected c·ªßa class cha

<br>

üíª **V√≠ d·ª• 1:**
```cpp
#include <iostream>
#include <string>

using namespace std;

class Person
{
    protected:
        // c√°c member n·∫±m trong protected th√¨ object s·∫Ω kh√¥ng truy c·∫≠p ƒë·∫øn ƒë∆∞·ª£c
        // nh∆∞ng c√°c class con k·∫ø th·ª´a t·ª´ class cha th√¨ c√≥ th·ªÉ truy c·∫≠p ƒë∆∞·ª£c
        string Name;
        int Age;
        string Home_Address;

    public:
        string getName(){           // getter   // ƒë·ªçc gi√° tr·ªã c·ªßa property
            return this->Name;
        }
        void setName(string name){  // setter   // ghi gi√° tr·ªã c·ªßa property
            this->Name = name;
        }

        int getAge(){               // getter
            return this->Age;
        }
        void setAge(int age){       // setter
            this->Age = age;
        }

        string getAddress(){                // getter
            return this->Home_Address;
        }
        void setAddress(string address){    // setter
            this->Home_Address = address;
        }

        void displayInfo(){
            cout << "Name: " << Name << endl;
            cout << "Age: " << Age << endl;
            cout << "Address: " << Home_Address << endl;
        }
};

class Student : public Person
{
    private:
        string School_Name;
        double GPA;
        int StudentID;

    public:
        Student(){
            static int id = 1000;
            Student::StudentID = id;
            id++;
        }

        string getSchoolName(){
            return Student::School_Name;
        }
        void setSchoolName(string school_name){
            Student::School_Name = school_name;
        }

        double getGPA(){
            return Student::GPA;
        }
        void setGPA(double gpa){
            Student::GPA = gpa;
        }

        int getID(){
            return Student::StudentID;
        }

        void displayInfo(){ // override
            cout << "Name: " << Student::Name << endl;
            cout << "Age: " << Student::Age << endl;
            cout << "Address: " << Student::Home_Address << endl;
            cout << "School name: " << Student::School_Name << endl;
            cout << "GPA: " << Student::GPA << endl;
        }
};

int main(){
    Person person1;
    person1.setName("Trung");
    person1.setAge(20);
    person1.setAddress("HCM");
    person1.displayInfo();

    cout << "-----------------------" << endl;
    
    Student student1;
    student1.setName("Trungg");
    student1.setAge(24);
    student1.setAddress("HCMM");
    student1.setGPA(8.1);
    student1.setSchoolName("DinhTienHoang");
    student1.displayInfo();
    return 0;
}
```

<br>

üíª **V√≠ d·ª• 2:**
```cpp
#include <iostream>
#include <string>

using namespace std;

class DoiTuong
{ 
    // private:
    //     int id;   
    //     string name;

    protected:
        string ten;
        int id;

    public:
        DoiTuong()
        {
            static int newID = 1;
            id = newID;
            newID++;
        }

        void setName(string newName)
        {
            ten = newName;
        }

        string getName() const
        {
            return ten;
        }

        int getID() const
        {
            return id;
        }

        void display()
        {
            cout << "ID: " << id << endl;
            cout << "T√™n: " << ten << endl;
        }
};

class SinhVien : public DoiTuong
{
    private:
        string chuyenNganh;

    public:
        void setChuyenNganh(string _nganh)
        {
            chuyenNganh = _nganh;
        }

        void display()  // overload
        {
            DoiTuong::display();
            cout << "Chuy√™n ng√†nh: " << chuyenNganh << endl << endl;
        }
};

class HocSinh : public DoiTuong
{    
    private:
        string lop;

    public:
        void setLop(string _lop)
        {
            lop = _lop;
        }

        void display()  // overload
        {
            DoiTuong::display();
            cout << "L·ªõp: " << lop << endl << endl;
        }
};

class GiaoVien : public DoiTuong
{
    private:
        string chuyenMon;

    public:
        void setChuyenMon(string _mon)
        {
            chuyenMon = _mon;
        }

        void display()  // overload
        {
            DoiTuong::display();
            cout << "Chuy√™n m√¥n: " << chuyenMon << endl << endl;
        }
};

int main(int argc, char const *argv[])
{
    DoiTuong dt1("Hoang");
    dt1.display();
    cout << endl;

    SinhVien sv1("Tuan","DTVT");
    sv1.display();
    cout << endl;

    HocSinh hs1("Trung", "12A1");
    hs1.display();
    cout << endl;

    GiaoVien gv1("Bao", "Toan");
    gv1.display();
    cout << endl;

    return 0;
}
```

<br>

</p>
</details>

<details><summary><b>üìö Protected Inheritance</b></summary>
<p>

- C√°c member **public, protected** c·ªßa class cha s·∫Ω l√† **protected** trong class con.
- C√°c member private c·ªßa class cha kh√¥ng th·ªÉ truy c·∫≠p tr·ª±c ti·∫øp t·ª´ class con nh∆∞ng c√≥ th·ªÉ ƒë∆∞·ª£c truy c·∫≠p gi√°n ti·∫øp qua c√°c ph∆∞∆°ng th·ª©c public ho·∫∑c protected c·ªßa class cha.

<br>

üíª **V√≠ d·ª• 1:**
```cpp
#include <iostream>

using namespace std;

class Base
{
    protected:
        int protectedVar;

    public:
        Base(): protectedVar(10){}
        void showProtectedVar()
	{
            cout << "Protected variable: " << protectedVar << endl;
        }
};

class Derived : protected Base
{
    public:
        void accessBaseMembers()
	{
            // C√≥ th·ªÉ truy c·∫≠p protectedVar v√¨ n√≥ ƒë∆∞·ª£c k·∫ø th·ª´a d∆∞·ªõi d·∫°ng protected
            cout << "Accessing protectedVar from Base: " << protectedVar << endl;
        }
};

int main()
{
    Derived obj;
    obj.accessBaseMembers();

    // Kh√¥ng th·ªÉ truy c·∫≠p tr·ª±c ti·∫øp th√†nh vi√™n protected t·ª´ ƒë·ªëi t∆∞·ª£ng class con
    // obj.protectedVar; // L·ªói: kh√¥ng th·ªÉ truy c·∫≠p tr·ª±c ti·∫øp
}
```

<br>

üíª **V√≠ d·ª• 2:**
```cpp
#include <iostream>
#include <string>

using namespace std;

class DoiTuong
{ 
    // private:
    //     int id;   
    //     string name;

    protected:
        int id;   
        string name;      

    public:
        DoiTuong(string newName){
            static int _id = 1;
            id = _id;
            _id++;

            // check chu·ªói nh·∫≠p v√†o, tr√°nh c√≥ k√Ω t·ª± ƒë·∫∑c bi·ªát, s·ªë, space,...
            name = newName;
        }

        // getter
        int getID(){
            return id;
        }

        string getName(){
            return name;
        }

        void display(){
            cout << "Ten: " << getName() << endl;
            cout << "ID: " << getID() << endl;
        }
};

class SinhVien : protected DoiTuong
{
    private:
        string chuyenNganh;

    public:
        SinhVien(string name, string chuyenNganh): DoiTuong(name){
            SinhVien::chuyenNganh = chuyenNganh;
        }

        string getChuyenNganh(){
            return chuyenNganh;
        }

        void display(){
            cout << "Ten: " << SinhVien::getName() << endl;
            cout << "ID: " << SinhVien::getID() << endl;
            cout << "Chuyen nganh: " << SinhVien::getChuyenNganh() << endl;
        }
};

int main(int argc, char const *argv[])
{
    DoiTuong dt1("Hoang");
    dt1.display();

    cout << endl;

    SinhVien sv1("Tuan","DTVT");
    sv1.display();
    return 0;
}
```

<br>

</p>
</details>

<details><summary><b>üìö Private Inheritance</b></summary>
<p>

- C√°c member **public, protected** c·ªßa class cha s·∫Ω tr·ªü th√†nh **private** trong class con.
- C√°c member private c·ªßa class cha kh√¥ng th·ªÉ truy c·∫≠p tr·ª±c ti·∫øp t·ª´ class con nh∆∞ng c√≥ th·ªÉ ƒë∆∞·ª£c truy c·∫≠p gi√°n ti·∫øp qua c√°c ph∆∞∆°ng th·ª©c public ho·∫∑c protected c·ªßa class cha.

<br>

üíª **V√≠ d·ª•**
```cpp
#include <iostream>

using namespace std;

class Base
{
    protected:
        int protectedVar;

    public:
        int publicVar;
        Base(): protectedVar(10), publicVar(20){}
};

class Derived : private Base
{
    public:
        void accessBaseMembers()
        {
            // C√≥ th·ªÉ truy c·∫≠p protectedVar v√† publicVar b√™n trong class con
            cout << "protectedVar: " << protectedVar << endl;
            cout << "publicVar: " << publicVar << endl;
        }
};

int main()
{
    Derived obj;
    obj.accessBaseMembers();

    // Kh√¥ng th·ªÉ truy c·∫≠p tr·ª±c ti·∫øp th√†nh vi√™n c·ªßa Base qua ƒë·ªëi t∆∞·ª£ng Derived
    // obj.publicVar; // L·ªói: kh√¥ng th·ªÉ truy c·∫≠p v√¨ publicVar ƒë√£ tr·ªü th√†nh private trong Derived
}
```

<br>

</p>
</details>

<details><summary><b>üìö Multiple Inheritance</b></summary>
<p>

- ƒêa k·∫ø th·ª´a trong C++ cho ph√©p m·ªôt class k·∫ø th·ª´a t·ª´ nhi·ªÅu class kh√°c.
- ƒêa k·∫ø th·ª´a th∆∞·ªùng d√πng ƒë·ªÉ k·∫øt h·ª£p c√°c ch·ª©c nƒÉng t·ª´ nhi·ªÅu class.

üíª **V√≠ d·ª•:**
```cpp
#include <iostream>

using namespace std;

class Sensor
{
    public:
        void initialize()
        {
            cout << "Initializing sensor" << endl;
            // code kh·ªüi t·∫°o c·∫£m bi·∫øn
        }

        int readData()
        {
            cout << "Reading sensor data" << endl;
            // code ƒë·ªçc d·ªØ li·ªáu c·∫£m bi·∫øn
            return 30;
        }
};

class Communication
{
    public:
        void setupCommunication()
        {
            cout << "Setting up communication protocol" << endl;
            // code thi·∫øt l·∫≠p giao th·ª©c truy·ªÅn th√¥ng (SPI, I2C, UART,...)
        }

        void sendData(int data)
        {
            cout << "Sending data: " << data << endl;
            // code g·ª≠i d·ªØ li·ªáu qua c√°c giao th·ª©c
        }
};

class Control : public Sensor, public Communication
{
    public:
        Control()
        {
            setupCommunication();

            initialize();

            int data = readData();

            sendData(data);
        }
};

int main(int argc, char const *argv[])
{
    Control sensorControl;
    return 0;
}
```

<br>

</p>
</details>

<details><summary><b>üìö Virtual Inheritance</b></summary>
<p>

- Khi m·ªôt l·ªõp con k·∫ø th·ª´a t·ª´ hai l·ªõp cha, v√† hai l·ªõp cha n√†y ƒë·ªÅu k·∫ø th·ª´a t·ª´ m·ªôt l·ªõp chung (g·ªëc), th√¨ l·ªõp chung ƒë√≥ c√≥ th·ªÉ b·ªã k·∫ø th·ª´a nhi·ªÅu l·∫ßn, d·∫´n ƒë·∫øn vi·ªác d·ªØ li·ªáu t·ª´ l·ªõp chung b·ªã sao ch√©p, g√¢y ra c√°c xung ƒë·ªôt d·ªØ li·ªáu ho·∫∑c kh√¥ng nh·∫•t qu√°n. ƒê√¢y ƒë∆∞·ª£c g·ªçi l√† v·∫•n ƒë·ªÅ kim c∆∞∆°ng (Diamond problem).

üíª **V√≠ d·ª•:**
```cpp
#include <iostream>

using namespace std;

class A
{
    public:
        A(){ cout << "Constructor A\n"; }

        void hienThiA(){ cout << "Day la lop A\n"; }
};

class B : public A
{
    public:
        B(){ cout << "Constructor B\n"; }

        void hienThiB(){ cout << "Day la lop B\n"; }
};

class C : public A
{
    public:
        C(){ cout << "Constructor C\n"; }

        void hienThiC(){ cout << "Day la lop C\n"; }
};

class D : public B, public C{
    public:
        D(){ cout << "Constructor D\n"; }

        void hienThiD(){ cout << "Day la lop D\n"; }
};

int main()
{
    D d;
    d.hienThiA();
    return 0;
}
```
**K·∫øt qu·∫£**:
``` error: request for member 'hienThiA' is ambiguous ```

üìù l·ªõp D s·∫Ω c√≥ hai phi√™n b·∫£n c·ªßa class A, m·ªôt t·ª´ B v√† m·ªôt t·ª´ C, d·∫´n ƒë·∫øn v·∫•n ƒë·ªÅ ƒëa k·∫ø th·ª´a "diamond problem". 

üìù Mu·ªën g·ªçi method ``` hienThiA ``` th√¨ ta ph·∫£i ch·ªâ ƒë·ªãnh r√µ r√†ng l√† g·ªçi t·ª´ class n√†o. V√≠ d·ª•: ``` d.B::hienThiA() ``` ho·∫∑c ``` d.C::hienThiA() ```

üìù Kh√¥ng th·ªÉ g·ªçi tr·ª±c ti·∫øp method ``` hienThiA ``` v√¨ l√∫c n√†y compiler kh√¥ng bi·∫øt n√™n g·ªçi t·ª´ class n√†o.

<br>

ƒê·ªÉ kh·∫Øc ph·ª•c v·∫•n ƒë·ªÅ tr√™n th√¨ ngo√†i vi·ªác ch·ªâ ƒë·ªãnh r√µ r√†ng l√† g·ªçi t·ª´ class n√†o, ta c√≥ th·ªÉ th√™m v√†o t·ª´ kh√≥a ``` virtual ``` khi c√°c class cha (class c∆° s·ªü) k·∫ø th·ª´a t·ª´ class chung. ƒêi·ªÅu n√†y gi√∫p t·∫°o ra m·ªôt b·∫£n sao duy nh·∫•t c·ªßa c√°c th√†nh ph·∫ßn ƒë∆∞·ª£c k·∫ø th·ª´a t·ª´ class chung.

üíª **V√≠ d·ª•:**
```cpp
#include <iostream>

using namespace std;

class A
{
    public:
        A(){ cout << "Constructor A\n"; }

        void hienThiA(){ cout << "Day la lop A\n"; }
};

class B : virtual public A
{
    public:
        B(){ cout << "Constructor B\n"; }

        void hienThiB(){ cout << "Day la lop B\n"; }
};

class C : virtual public A
{
    public:
        C(){ cout << "Constructor C\n"; }

        void hienThiC(){ cout << "Day la lop C\n"; }
};

class D : public B, public C
{
    public:
        D(){ cout << "Constructor D\n"; }

        void hienThiD(){ cout << "Day la lop D\n"; }
};

int main() {
    D d;

    d.hienThiA();

    // G·ªçi ph∆∞∆°ng th·ª©c t·ª´ l·ªõp A qua B v√† C
    // d.B::hienThiA(); // G·ªçi h√†m hienThiA t·ª´ l·ªõp A th√¥ng qua B
    // d.C::hienThiA(); // G·ªçi h√†m hienThiA t·ª´ l·ªõp A th√¥ng qua C

    d.hienThiB();
    d.hienThiC();
    d.hienThiD();

    return 0;
}
```

<br>

</p>
</details>

</p>
</details>

<details><summary><b>3. Polymorphism </b></summary>
<p>

- T√≠nh ƒëa h√¨nh l√† kh·∫£ nƒÉng cho ph√©p m·ªôt ph∆∞∆°ng th·ª©c c√≥ th·ªÉ ho·∫°t ƒë·ªông theo nhi·ªÅu c√°ch kh√°c nhau, t√πy thu·ªôc v√†o ng·ªØ c·∫£nh ho·∫∑c ƒë·ªëi t∆∞·ª£ng ƒëang g·ªçi n√≥.
- T√≠nh ƒëa h√¨nh c√≥ th·ªÉ ƒë∆∞·ª£c chia th√†nh hai lo·∫°i ch√≠nh:
	+ ƒêa h√¨nh t·∫°i th·ªùi ƒëi·ªÉm bi√™n d·ªãch (**Compile-time Polymorphism**): ƒë∆∞·ª£c th·ª±c hi·ªán th√¥ng qua n·∫°p ch·ªìng h√†m (function overloading) ho·∫∑c n·∫°p ch·ªìng to√°n t·ª≠ (operator overloading).
 	+ ƒêa h√¨nh t·∫°i th·ªùi ƒëi·ªÉm ch·∫°y (**Run-time Polymorphism**): ƒë∆∞·ª£c th·ª±c hi·ªán th√¥ng qua c√°c ph∆∞∆°ng th·ª©c ·∫£o (virtual methods) v√† ghi ƒë√® ph∆∞∆°ng th·ª©c (method overriding).

<br>

<details><summary><b>üìö Compile Time Polymorphism</b></summary>
<p>

<details><summary><b>üìöüìö N·∫°p ch·ªìng h√†m (Function Overloading)</b></summary>
<p>

N·∫°p ch·ªìng h√†m (Function Overloading) x·∫£y ra khi c√°c ph∆∞∆°ng th·ª©c trong c√πng m·ªôt l·ªõp c√≥ c√πng t√™n nh∆∞ng kh√°c nhau v·ªÅ s·ªë l∆∞·ª£ng ho·∫∑c ki·ªÉu tham s·ªë. Compiler s·∫Ω x√°c ƒë·ªãnh method n√†o s·∫Ω ƒë∆∞·ª£c g·ªçi d·ª±a tr√™n tham s·ªë truy·ªÅn v√†o.

<br>

üíª **V√≠ d·ª•:**
```cpp
#include <iostream>
#include <string>
using namespace std;

// 1 method c√≥ th·ªÉ c√≥ nhi·ªÅu input parameter kh√°c nhau
class TinhToan
{
    private:
        int a;
        int b;

    public:
        int tong(int a, int b)
 	{
            return a+b;
        }

	double tong(int a, double b)
	{
            return (double)a+b;
        }

	double tong(double a, double b)
	{
            return (double)a+b;
	}

        double tong(int a, int b, int c, double d)
	{
            return (double)a+b+c+d;
        }
};

int main(int argc, char const *argv[])
{
    TinhToan th, th1, th2, th3;
    cout << th.tong(2, 5) << endl;
    cout << th1.tong(2, 5, 7, 6.7) << endl;
    cout << th2.tong(2, 3.5) << endl;
    cout << th3.tong(2.5, 3.5) << endl;
    return 0;
}
```
üìù Vi·∫øt method t√≠nh t·ªïng, c√≥ th·ªÉ l√† t·ªïng c·ªßa 2,3,4 ho·∫∑c nhi·ªÅu h∆°n, ho·∫∑c l√† c√°c tham s·ªë truy·ªÅn v√†o kh√°c nhau. Khi kh·ªüi t·∫°o object v√† g·ªçi method th√¨ l√∫c ƒë√≥ n√≥ s·∫Ω cƒÉn c·ª© v√†o tham s·ªë truy·ªÅn v√†o ƒë·ªÉ bi·∫øt l√† n√≥ s·∫Ω l·∫•y method n√†o.

üìù Qu√° tr√¨nh tr√™n ƒë·ªÉu x·∫£y ra ·ªü compiler, nghƒ©a l√† khi ta ƒë∆∞a c√°c tham s·ªë ƒë·∫ßu v√†o th√¨ n√≥ cƒÉn c·ª© v√†o ƒë√≥ v√† b·∫Øt ƒë·∫ßu generate ra code.

üìù Trong C++ th√¨ vi·ªác nhi·ªÅu h√†m c√≥ c√πng t√™n nh∆∞ng kh√°c nhau tham s·ªë ƒë·∫ßu v√†o v√† ki·ªÉu d·ªØ li·ªáu tr·∫£ v·ªÅ v·∫´n c√≥ th·ªÉ n·∫±m to√†n c·ª•c ch·ª© kh√¥ng nh·∫•t thi·∫øt ph·∫£i n·∫±m trong class.

<br>

</p>
</details>

<details><summary><b>üìöüìö N·∫°p ch·ªìng to√°n t·ª≠ (Operator Overloading)</b></summary>
<p>

C√°c to√°n t·ª≠ nh∆∞ ``` +, -, *, /, ^, |, &, v.v ``` s·∫Ω m·∫∑c ƒë·ªãnh cho c√°c bi·∫øn c√≥ ki·ªÉu d·ªØ li·ªáu nguy√™n th·ªßy (int, double, float, short, char, v.v) nh∆∞ng c√°c ki·ªÉu d·ªØ li·ªáu t·ª± ƒë·ªãnh nghƒ©a th√¨ kh√¥ng ƒë∆∞·ª£c ph√©p, mu·ªën s·ª≠ d·ª•ng ph·∫£i ƒë·ªãnh nghƒ©a l·∫°i.

N·∫°p ch·ªìng to√°n t·ª≠ (Operator Overloading) trong C++ l√† m·ªôt t√≠nh nƒÉng cho ph√©p b·∫°n ƒë·ªãnh nghƒ©a l·∫°i c√°c to√°n t·ª≠ ƒë·ªÉ ch√∫ng ho·∫°t ƒë·ªông theo c√°ch m√† b·∫°n mong mu·ªën ƒë·ªëi v·ªõi c√°c ki·ªÉu d·ªØ li·ªáu do ng∆∞·ªùi d√πng ƒë·ªãnh nghƒ©a (nh∆∞ class ho·∫∑c struct).

Khi b·∫°n mu·ªën n·∫°p ch·ªìng m·ªôt to√°n t·ª≠, b·∫°n c·∫ßn ƒë·ªãnh nghƒ©a m·ªôt h√†m c√≥ t·ª´ kh√≥a ``` operator ``` theo sau l√† ``` k√Ω hi·ªáu to√°n t·ª≠ ``` m√† b·∫°n mu·ªën n·∫°p ch·ªìng.

C√∫ ph√°p: 

```cpp
<return_type> operator symbol (parameters)
{
	// logic c·ªßa to√°n t·ª≠
}
```

Trong ƒë√≥:

- **return_type**: Ki·ªÉu d·ªØ li·ªáu tr·∫£ v·ªÅ c·ªßa h√†m (method).
- **operator symbol**: To√°n t·ª≠ m√† b·∫°n mu·ªën n·∫°p ch·ªìng.
- **parameters**: C√°c tham s·ªë truy·ªÅn v√†o (t·ªëi ƒëa m·ªôt tham s·ªë (do b·∫£n ch·∫•t to√°n h·ªçc) v·ªõi h·∫ßu h·∫øt c√°c to√°n t·ª≠ nh·ªã ph√¢n (+, -, *, /, ...),  c√°c to√°n t·ª≠ ƒë∆°n nguy√™n (++, --, !, ~) th∆∞·ªùng ch·ªâ ho·∫°t ƒë·ªông tr√™n this v√† kh√¥ng c·∫ßn tham s·ªë. ).

**C√°c to√°n t·ª≠ c√≥ th·ªÉ overload ƒë∆∞·ª£c:**
```cpp
+	‚Äì	*	/	%	^	&	|
~	!	=	<	>	+=	-=	*=
/=	%=	^=	&=	|=	<<	>>	>>=
<<=	==	!=	<=	>=	&&	||	++
‚Äî	->*	,	->	[]	()	new	delete
new[]	delete[]
```

**M·ªôt s·ªë to√°n t·ª≠ sau kh√¥ng overload ƒë∆∞·ª£c:**

- To√°n t·ª≠ . (ch·∫•m)
- To√°n t·ª≠ ph·∫°m vi ::
- To√°n t·ª≠ ƒëi·ªÅu ki·ªán ?:
- To√°n t·ª≠ sizeof

<br>

üíª **V√≠ d·ª• 1: S·ªë ph·ª©c**
```cpp
#include <iostream>

using namespace std;

class Complex
{
    private:
        double realPart;    // ph·∫ßn th·ª±c
        double imagPart;    // ph·∫ßn ·∫£o
    
    public:
        Complex(double real = 0, double imag = 0): realPart(real), imagPart(imag){}

        // n·∫°p ch·ªìng to√°n t·ª≠ +
        Complex operator + (const Complex& other) const
    	{
            Complex result;
            result.realPart = this->realPart + other.realPart;
            result.imagPart = this->imagPart + other.imagPart;
            return result;
        }

        // n·∫°p ch·ªìng to√°n t·ª≠ so s√°nh b·∫±ng (==)
        bool operator == (const Complex& other) const
	{
            return (this->realPart == other.realPart && this->imagPart == other.imagPart);
        }

        // h√†m hi·ªÉn th·ªã
        void display() const
	{
            cout << realPart << " + " << imagPart << "i" << endl;
        }
};

int main() 
{
    Complex c1(3,4);
    Complex c2(5,6);
    Complex c3 = c1 + c2;
    c1.display();
    c2.display();
    c3.display();

    if (c1 == c2){
        cout << "Hai s·ªë ph·ª©c b·∫±ng nhau" << endl;
    } else {
        cout << "Hai s·ªë ph·ª©c kh√¥ng b·∫±ng nhau" << endl;
    }
    return 0;
}
```

<br>

üíª **V√≠ d·ª• 2: Ph√¢n s·ªë**
```cpp
#include <iostream>
using namespace std;

class PhanSo
{
    private:
        int numerator;   // T·ª≠ s·ªë
        int denominator; // M·∫´u s·ªë

        // H√†m t√¨m ∆Ø·ªõc Chung L·ªõn Nh·∫•t (Greatest Common Divisor - GCD)
        int gcd(int a, int b) const
	{
            return (b == 0) ? a : gcd(b, a % b);
        }

        // H√†m r√∫t g·ªçn ph√¢n s·ªë
        void simplify()
	{
            int divisor = gcd(numerator, denominator);
            numerator /= divisor;
            denominator /= divisor;
        }

    public:
        PhanSo(int num = 0, int den = 1): numerator(num), denominator(den)
	{
            if (!denominator)
            {
                throw invalid_argument("M·∫´u s·ªë ph·∫£i kh√°c 0!");
            }
        }

        // n·∫°p ch·ªìng to√°n t·ª≠ nh√¢n (*)
        PhanSo operator * (const PhanSo& other) const
	{
            // other.tu = 11;
            // other.mau = 13;
	    // this->tu = 100;
	    // this->mau = 200;
            PhanSo ketqua;
            ketqua.numerator   = this->numerator   * other.numerator;
            ketqua.denominator = this->denominator * other.denominator;
            ketqua.simplify();
            return ketqua;
        }
        
        // n·∫°p ch·ªìng to√°n t·ª≠ c·ªông (+)
        PhanSo operator + (const PhanSo& other) const
	{
            PhanSo ketqua;
            ketqua.numerator = this->numerator * other.denominator + this->denominator * other.numerator;
            ketqua.denominator = this->denominator * other.denominator;
            ketqua.simplify();
            return ketqua;
        }

        // n·∫°p ch·ªìng to√°n t·ª≠ so s√°nh b·∫±ng (==)
        bool operator == (const PhanSo& other) const
	{
            return (this->numerator == other.numerator && this->denominator == other.denominator);
        }

        // n·∫°p ch·ªìng to√°n t·ª≠ nh·∫≠p (>>)
        friend istream& operator >> (istream& input, PhanSo& f)
	{
            cout << "Nh·∫≠p t·ª≠ s·ªë: ";
            input >> f.numerator;

            cout << "Nh·∫≠p m·∫´u s·ªë: ";
            input >> f.denominator;

            if (!f.denominator)
	    {
                throw invalid_argument("M·∫´u s·ªë ph·∫£i kh√°c 0!");
            }
            return input;
        }

        // n·∫°p ch·ªìng to√°n t·ª≠ xu·∫•t (<<)
        friend ostream& operator << (ostream& output, const PhanSo& f)
	{
            output << f.numerator << "/" << f.denominator;
            return output;
        }

        void display()
	{
            cout << "Tu: " << numerator << " , mau: " << denominator << endl;
        }
};

int main(int argc, char const *argv[])
{
    try
    {
        PhanSo p1(1, 2);             // 0xc8
        PhanSo p2(4, 6);             // 0xa5
        PhanSo p3 = p1 * p2;

        p1.display();
        p2.display();
        p3.display();

        if (p1 == p2){
            cout << "p1 = p2" << endl;
        } else {
            cout << "p1 # p2" << endl;
        }

        PhanSo p4, p5, p6;
        cout << "Nh·∫≠p ph√¢n s·ªë p4:\n";
        cin >> p4;

        cout << "Nh·∫≠p ph√¢n s·ªë p5:\n";
        cin >> p5;

        p6 = p4 + p5;
        cout << p6;
    }
    catch (const invalid_argument& e) 		// B·∫Øt ngo·∫°i l·ªá invalid_argument
    {      
        cout << "L·ªói: " << e.what() << endl;  	// Hi·ªÉn th·ªã th√¥ng b√°o l·ªói
    }
    
    return 0;
}
```

üìù **To√°n t·ª≠ c·ªông (+)**: d√πng ƒë·ªÉ c·ªông 2 ph√¢n s·ªë.

üìù **To√°n t·ª≠ nh√¢n (*)**: d√πng ƒë·ªÉ nh√¢n 2 ph√¢n s·ªë.

üìù Sau khi t√≠nh to√°n s·∫Ω t·ª± ƒë·ªông r√∫t g·ªçn ph√¢n s·ªë k·∫øt qu·∫£ th√¥ng qua g·ªçi method ``` simplify() ```.

üìù **To√°n t·ª≠ so s√°nh b·∫±ng (==)**: so s√°nh hai ph√¢n s·ªë ƒë√£ ƒë∆∞·ª£c r√∫t g·ªçn ƒë·ªÉ xem ch√∫ng c√≥ b·∫±ng nhau hay kh√¥ng. N·∫øu t·ª≠ s·ªë v√† m·∫´u s·ªë c·ªßa hai ph√¢n s·ªë b·∫±ng nhau, th√¨ ch√∫ng b·∫±ng nhau.

üìù **To√°n t·ª≠ nh·∫≠p (>>)**: To√°n t·ª≠ nh·∫≠p cho ph√©p ng∆∞·ªùi d√πng nh·∫≠p t·ª≠ s·ªë v√† m·∫´u s·ªë t·ª´ b√†n ph√≠m. 

üìù **To√°n t·ª≠ xu·∫•t (<<)**: To√°n t·ª≠ xu·∫•t hi·ªÉn th·ªã ph√¢n s·ªë theo ƒë·ªãnh d·∫°ng "t·ª≠ s·ªë/m·∫´u s·ªë".

üìù **try**: m·ªôt kh·ªëi l·ªánh ch·ª©a c√°c c√¢u l·ªánh m√† b·∫°n mu·ªën theo d√µi c√°c ngo·∫°i l·ªá. N·∫øu m·ªôt ngo·∫°i l·ªá x·∫£y ra trong kh·ªëi try, ch∆∞∆°ng tr√¨nh s·∫Ω l·∫≠p t·ª©c d·ª´ng th·ª±c thi c√°c l·ªánh ti·∫øp theo trong kh·ªëi try v√† chuy·ªÉn sang t√¨m ki·∫øm kh·ªëi catch th√≠ch h·ª£p ƒë·ªÉ x·ª≠ l√Ω ngo·∫°i l·ªá.

üìù **catch**: b·∫Øt c√°c ngo·∫°i l·ªá ƒë∆∞·ª£c n√©m ra t·ª´ kh·ªëi try. N·∫øu m·ªôt ngo·∫°i l·ªá x·∫£y ra, n√≥ s·∫Ω ƒë∆∞·ª£c b·∫Øt ·ªü kh·ªëi catch t∆∞∆°ng ·ª©ng, v√† ch∆∞∆°ng tr√¨nh s·∫Ω th·ª±c thi c√°c l·ªánh trong kh·ªëi catch ƒë·ªÉ x·ª≠ l√Ω ngo·∫°i l·ªá ƒë√≥.

üìù **throw**: l√† t·ª´ kh√≥a ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ n√©m m·ªôt ngo·∫°i l·ªá (exception). Khi m·ªôt v·∫•n ƒë·ªÅ x·∫£y ra, ch∆∞∆°ng tr√¨nh c√≥ th·ªÉ ph√°t hi·ªán l·ªói ƒë√≥ v√† n√©m ngo·∫°i l·ªá v·ªõi t·ª´ kh√≥a throw. Ngo·∫°i l·ªá n√†y s·∫Ω ƒë∆∞·ª£c chuy·ªÉn l√™n chu·ªói c√°c l·ªánh cho ƒë·∫øn khi n√≥ ƒë∆∞·ª£c b·∫Øt b·ªüi m·ªôt kh·ªëi l·ªánh catch t∆∞∆°ng ·ª©ng.

<br>

</p>
</details>

</p>
</details>

<details><summary><b>üìö Run Time Polymorphism</b></summary>
<p>

ƒêa h√¨nh t·∫°i th·ªùi ƒëi·ªÉm ch·∫°y hay c√≤n g·ªçi l√† ƒëa h√¨nh ghi ƒë√® (**overriding**), ƒëa h√¨nh ƒë·ªông x·∫£y ra khi m·ªôt l·ªõp con ghi ƒë√® l·∫°i m·ªôt ph∆∞∆°ng th·ª©c c·ªßa l·ªõp cha v√† ph∆∞∆°ng th·ª©c n√†y ƒë∆∞·ª£c g·ªçi th√¥ng qua con tr·ªè ho·∫∑c tham chi·∫øu ƒë·∫øn l·ªõp cha. Ph∆∞∆°ng th·ª©c c·ªßa l·ªõp con s·∫Ω ƒë∆∞·ª£c g·ªçi t·∫°i th·ªùi ƒëi·ªÉm th·ª±c thi, kh√¥ng ph·∫£i l√∫c bi√™n d·ªãch.

<details><summary><b>üìöüìö up-casting & down-casting </b></summary>
<p>

</p>
</details>

<details><summary><b>üìöüìö Virtual Function </b></summary>
<p>

- Virtual Function (h√†m ·∫£o) l√† m·ªôt h√†m th√†nh vi√™n ƒë∆∞·ª£c khai b√°o trong l·ªõp cha v·ªõi t·ª´ kh√≥a ``` virtual ```.
- Khi m·ªôt h√†m l√† virtual, n√≥ c√≥ th·ªÉ ƒë∆∞·ª£c ghi ƒë√® (``` override ```) trong c√°c l·ªõp con.
- Khi g·ªçi m·ªôt h√†m ·∫£o th√¥ng qua m·ªôt con tr·ªè ho·∫∑c tham chi·∫øu ƒë·∫øn l·ªõp con, h√†m s·∫Ω ƒë∆∞·ª£c quy·∫øt ƒë·ªãnh d·ª±a tr√™n ƒë·ªëi t∆∞·ª£ng th·ª±c t·∫ø m√† con tr·ªè ho·∫∑c tham chi·∫øu ƒëang tr·ªè t·ªõi ch·ª© kh√¥ng d·ª±a v√†o ki·ªÉu c·ªßa con tr·ªè.

<br>

üíª **V√≠ d·ª•:**
```cpp
class Base
{
	public:
	    virtual void display() { cout << "Display from Base class" << endl; }
};
```

<br>

</p>
</details>

<details><summary><b>üìöüìö Override </b></summary>
<p>

- C√°c l·ªõp con c√≥ th·ªÉ ghi ƒë√® h√†m ·∫£o b·∫±ng c√°ch ƒë·ªãnh nghƒ©a l·∫°i n√≥.
- Khi m·ªôt h√†m ·∫£o ƒë∆∞·ª£c ghi ƒë√®, h√†nh vi c·ªßa n√≥ s·∫Ω ph·ª• thu·ªôc v√†o ki·ªÉu c·ªßa ƒë·ªëi t∆∞·ª£ng th·ª±c t·∫ø, ch·ª© kh√¥ng ph·∫£i ki·ªÉu c·ªßa con tr·ªè hay tham chi·∫øu.

<br>

üíª **V√≠ d·ª• 1:**
```cpp
#include <iostream>
using namespace std;

class cha
{
    public:
        virtual void display()		// H√†m ·∫£o
	{                            
            cout << "display from class cha" << endl;
        }
};

class con : public cha
{
    public:
        void display() override		// Ghi ƒë√® h√†m ·∫£o
	{                           
            cout << "display from class con" << endl;
        }
};

int main()
{
    cha *ptr;
    con obj;

    // tr·ªè con tr·ªè class cha ƒë·∫øn ƒë·ªëi t∆∞·ª£ng class con
    ptr = &obj;

    // G·ªçi h√†m ·∫£o
    ptr->display();
}
```
**K·∫øt qu·∫£**:
```cpp
display from class con
```

<br>

üíª **V√≠ d·ª• 2:**
```cpp
#include <iostream>
#include <string>

using namespace std;

class DoiTuong{
    protected:
        string ten;
        int id;

    public:
        DoiTuong(){  
            static int ID = 1;
            id = ID;
            ID++;
        }

        void setName(string _ten){
            // check chu·ªói nh·∫≠p v√†o
            ten = _ten;
        }

        virtual void display(){
            cout << "ten: " << ten << endl;
            cout << "id: " << id << endl;
        }
};

class SinhVien : public DoiTuong{
    protected:
        string chuyenNganh;

    public:
        void setChuyenNganh(string _nganh){
            chuyenNganh = _nganh;
        }

        void display() override {
            cout << "ten: " << ten << endl;
            cout << "id: " << id << endl;
            cout << "chuyen nganh: " << chuyenNganh << endl;
        }
};

class HocSinh : public DoiTuong{
    protected:
        string lop;
   
    public:
        void setLop(string _lop){
            lop = _lop;
        }

        void display() override {
            cout << "ten: " << ten << endl;
            cout << "id: " << id << endl;
            cout << "lop: " << lop << endl;
        }
};

class GiaoVien : public DoiTuong{
    protected:
        string chuyenMon;

    public:
        void setChuyenMon(string _mon){
            chuyenMon = _mon;
        }

        void display() override {
            cout << "ten: " << ten << endl;
            cout << "id: " << id << endl;
            cout << "chuyen mon: " << chuyenMon << endl;
        }
};

int main(int argc, char const *argv[])
{
    SinhVien sv1;
    sv1.setName("Trung");
    sv1.setChuyenNganh("TDH");

    HocSinh hs1;
    hs1.setName("Tuan");
    hs1.setLop("12A1");

    GiaoVien gv1;
    gv1.setName("Hoang");
    gv1.setChuyenMon("Toan");

    DoiTuong *dt;

    dt = &sv1;
    dt->display();

    dt = &hs1;
    dt->display();

    dt = &gv1;
    dt->display();


    // DoiTuong *ptr[] = {&sv1, &hs1, &gv1};

    // ptr[0]->display();
    // ptr[1]->display();
    // ptr[2]->display();

    return 0;
}
```

<br>

</p>
</details>

<details><summary><b>üìöüìö Pure Virtual Function </b></summary>
<p>

- H√†m thu·∫ßn ·∫£o l√† m·ªôt h√†m ·∫£o kh√¥ng c√≥ ph·∫ßn ƒë·ªãnh nghƒ©a trong class cha, ƒë∆∞·ª£c khai b√°o v·ªõi c√∫ ph√°p = 0 v√† khi·∫øn class cha tr·ªü th√†nh class tr·ª´u t∆∞·ª£ng, nghƒ©a l√† kh√¥ng th·ªÉ t·∫°o ƒë·ªëi t∆∞·ª£ng t·ª´ class n√†y.

üíª **V√≠ d·ª•:**
```cpp
#include <iostream>
using namespace std;

class Base
{
    public:
        virtual void display() = 0;
};

int main(int argc, char const *argv[])
{
    Base baseObj;	// error: cannot declare variable 'baseObj' to be of abstract type 'Base'
    return 0;
}
```

<br>

- H√†m thu·∫ßn ·∫£o ph·∫£i ƒë∆∞·ª£c ghi ƒë√® trong class con v√† ch·ªâ c√°c class con ƒë√£ ghi ƒë√® t·∫•t c·∫£ c√°c H√†m thu·∫ßn ·∫£o m·ªõi c√≥ th·ªÉ t·∫°o ra ƒë·ªëi t∆∞·ª£ng.

üíª **V√≠ d·ª•:**
```cpp
#include <iostream>
using namespace std;

class cha
{
    public:
        virtual void display() = 0; // H√†m thu·∫ßn ·∫£o
};

class con : public cha
{
    public:
        void display() override     // Ghi ƒë√® H√†m thu·∫ßn ·∫£o
        {   
            cout << "display from class con" << endl;
        }
};

int main()
{
    cha *ptr;
    con obj;

    ptr = &obj;
    ptr->display(); // Output: display from class con

    return 0;
}
```

üìù Con tr·ªè ptr l√† c·ªßa class cha, nh∆∞ng n√≥ tr·ªè ƒë·∫øn ƒë·ªëi t∆∞·ª£ng c·ªßa class con.

üìù Method display() trong class cha ƒë∆∞·ª£c khai b√°o l√† h√†m thu·∫ßn ·∫£o, v√¨ v·∫≠y khi g·ªçi ``` ptr->display() ```, C++ s·∫Ω ki·ªÉm tra xem ƒë·ªëi t∆∞·ª£ng th·ª±c s·ª± m√† ptr tr·ªè t·ªõi l√† g√¨, v√† c·ª• th·ªÉ ·ªü ƒë√¢y l√† object ``` obj ``` c·ªßa class con v√† n√≥ g·ªçi h√†m ``` display() ``` c·ªßa class con.

üìù ƒê√¢y l√† **ƒëa h√¨nh**: C√πng m·ªôt giao di·ªán, nh∆∞ng h√†nh vi th·ª±c t·∫ø kh√°c nhau d·ª±a tr√™n ki·ªÉu c·ªßa ƒë·ªëi t∆∞·ª£ng th·ª±c s·ª±.

<br>

üíª **V√≠ d·ª•:**
```cpp
#include <iostream>
#include <string>

using namespace std;

class Xe
{
    public:
        virtual void hienThiThongTin() = 0;
};

class Toyota : public Xe
{
    private:
        string model;
        int namSanXuat;
        string dongCo;

    public:
        Toyota(string m, int nam, string dongCo): model(m), namSanXuat(nam), dongCo(dongCo){}

        void hienThiThongTin() override
        {
            cout << "Hang xe: Toyota\n";
            cout << "Model: " << model << "\n";
            cout << "Nam san xuat: " << namSanXuat << "\n";
            cout << "Dong co: " << dongCo << "\n";
        }
};

class Honda : public Xe{
    private:
        string model;
        int namSanXuat;
        string mauSac;

    public:
        Honda(string m, int nam, string mau): model(m), namSanXuat(nam), mauSac(mau){}

        void hienThiThongTin() override {
            cout << "Hang xe: Honda\n";
            cout << "Model: " << model << "\n";
            cout << "Nam san xuat: " << namSanXuat << "\n";
            cout << "Mau sac: " << mauSac << "\n";
        }
};

class Mazda : public Xe{
    private:
        string model;
        int namSanXuat;
        string loaiDanDong;

    public:
        Mazda(string m, int nam, string loaiDanDong): model(m), namSanXuat(nam), loaiDanDong(loaiDanDong){}

        void hienThiThongTin() override {
            cout << "Hang xe: Mazda\n";
            cout << "Model: " << model << "\n";
            cout << "Nam san xuat: " << namSanXuat << "\n";
            cout << "Loai dan dong: " << loaiDanDong << "\n";
        }
};

int main() {
    // Toyota to;
    // Honda ho;
    // Mazda mz;
    // Xe *xe;

    // xe = &to;
    // xe->hienThiThongTin();
   
    Mazda cx3("CX-3", 2019, "Dan dong 4 banh");

    Xe *ptr[] = {new Toyota("campry", 2020, "V6"),
                 new Honda("civic", 2019, "do"),
                 new Mazda("CX-5", 2021, "Dan dong 4 banh"),
                 new Toyota("corolla", 2018, "I4 1.8L"),
                 new Honda("accord", 2020, "den"),
                 &cx3};
   
    for (int i=0; i<6; i++){
        ptr[i]->hienThiThongTin();
        cout << "--------------" << endl;
        delete ptr[i];
    }

    return 0;
}
```

<br>

</p>
</details>

</p>
</details>

</p>
</details>

<details><summary><b>4. Abstraction </b></summary>
<p>

- Tr·ª´u t∆∞·ª£ng h√≥a v√† vi·ªác ch·ªâ ra nh·ªØng th√¥ng tin quan tr·ªçng nh·∫•t c·ªßa ƒë·ªëi t∆∞·ª£ng, gi·∫•u ƒëi nh∆∞ng chi ti·∫øt ph·ª©c t·∫°p kh√¥ng c·∫ßn thi·∫øt (logic x·ª≠ l√Ω, thu·∫≠t to√°n ƒë·ªÉ ƒë∆∞a ra k·∫øt qu·∫£ cu·ªëi c√πng), gi√∫p t·∫≠p trung v√†o c√°ch s·ª≠ d·ª•ng ƒë·ªëi t∆∞·ª£ng h∆°n l√† c√°ch n√≥ ƒë∆∞·ª£c th·ª±c hi·ªán.

<br>

üíª **V√≠ d·ª•:**
```cpp
#include <iostream>
#include <string>
#include <cmath>

using namespace std;

class PTBH
{
    private:    // x1, x2 l√† t√≠nh ƒë√≥ng g√≥i
        double x1;
        double x2;
        double a,b,c;

        double delta()
	{
            return (double)(b*b - 4*a*c);
        }

        void ketqua()
	{
            if (PTBH::delta() < 0)
	    {
                cout << "PTVN" << endl;
            }
            else if (PTBH::delta() == 0)
	    {
                cout << "x1 = x2 = " << (double)(-b/(2*a)) << endl;
            }
            else
	    {
                cout << "x1 = " << (-b + sqrt(delta()))/(2*a) << endl;
                cout << "x2 = " << (-b - sqrt(delta()))/(2*a) << endl;
            }
        
	
    public:
        void printResult(double a, double b, double c)
	{
            PTBH::a = a;
            PTBH::b = b;
            PTBH::c = c;
            ketqua();
        }
};

int main(int argc, char const *argv[])
{
    PTBH phuongtrinh1;
    phuongtrinh1.printResult(1,2,10);
    return 0;
}
```

üìù T√≠nh tr·ª´u t∆∞·ª£ng gi·ªëng v·ªõi t√≠nh ƒë√≥ng g√≥i nh∆∞ng kh√°c nhau v·ªÅ √Ω nghƒ©a.

üìù T√≠nh ƒë√≥ng g√≥i: nh·ªØng property ·ªü private th√¨ ph·∫£i truy c·∫≠p gi√°n ti·∫øp th√¥ng qua c√°c method, constructor, getter, setter.

üìù T√≠nh tr·ª´u t∆∞·ª£ng: khi thi·∫øt k·∫ø m·ªôt class cho ng∆∞·ªùi d√πng s·ª≠ d·ª•ng th√¨ ng∆∞·ªùi d√πng ch·ªâ ƒë∆∞·ª£c ph√©p s·ª≠ d·ª•ng nh·ªØng h√†m do l·∫≠p tr√¨nh vi√™n quy ƒë·ªãnh , qu√° tr√¨nh t·∫°o ra k·∫øt qu·∫£ cu·ªëi c√πng kh√¥ng ƒë∆∞·ª£c ph√©p truy c·∫≠p ƒë·∫øn, b·ªã ·∫©n ƒëi m·∫∑c d√π n·∫±m trong private.

</p>
</details>

</p>
</details>

<br>

<details><summary><b>Tham chi·∫øu - Tham tr·ªã</b></summary>
<p>

<details><summary><b>1. Tham tr·ªã (Pass by value)</b></summary>
<p>

- Trong C++, "tham tr·ªã" (pass by value) l√† m·ªôt c√°ch truy·ªÅn tham s·ªë v√†o h√†m, trong ƒë√≥ m·ªôt b·∫£n sao c·ªßa bi·∫øn ƒë∆∞·ª£c truy·ªÅn cho h√†m. ƒêi·ªÅu n√†y c√≥ nghƒ©a l√† b·∫•t k·ª≥ thay ƒë·ªïi n√†o ƒë∆∞·ª£c th·ª±c hi·ªán tr√™n tham s·ªë b√™n trong h√†m s·∫Ω kh√¥ng ·∫£nh h∆∞·ªüng ƒë·∫øn gi√° tr·ªã c·ªßa bi·∫øn g·ªëc b√™n ngo√†i h√†m.
- Khi s·ª≠ d·ª•ng tham tr·ªã, n√≥ s·∫Ω t·ªën b·ªô nh·ªõ tr√™n RAM ƒë·ªÉ c·∫•p ph√°t, sau ƒë√≥ th·ª±c hi·ªán copy gi√° tr·ªã.

üíª V√≠ d·ª•:
```cpp
#include <iostream>

void test(int a)	// int a = 10 (0x20: 10)
{   	
    printf("dia chi a: %p\n", &a);
}

int main()
{
    int x = 10; 	// 0x34: 10
    printf("dia chi x: %p\n", &x);
    test(x);
}
```

</p>
</details>

<details><summary><b>2. Tham chi·∫øu (Pass by reference)</b></summary>
<p>

- Trong C++, tham chi·∫øu (pass by reference) l√† m·ªôt c√°ch truy·ªÅn tham s·ªë v√†o h√†m, trong ƒë√≥ thay v√¨ truy·ªÅn m·ªôt b·∫£n sao c·ªßa bi·∫øn, ƒë·ªãa ch·ªâ c·ªßa bi·∫øn s·∫Ω ƒë∆∞·ª£c truy·ªÅn v√†o tr·ª±c ti·∫øp. ƒêi·ªÅu n√†y c√≥ nghƒ©a l√† b·∫•t k·ª≥ thay ƒë·ªïi n√†o th·ª±c hi·ªán tr√™n tham s·ªë trong h√†m s·∫Ω ·∫£nh h∆∞·ªüng tr·ª±c ti·∫øp ƒë·∫øn bi·∫øn g·ªëc b√™n ngo√†i h√†m.
- Tham chi·∫øu (&): b·ªè qua b∆∞·ªõc kh·ªüi t·∫°o bi·∫øn, kh√¥ng t·ªën b·ªô nh·ªõ RAM, Stack kh√¥ng tƒÉng l√™n

üíª V√≠ d·ª• 1:
```cpp
#include <iostream>

void test(int &a)
{   
    cout << "ƒê·ªãa ch·ªâ bi·∫øn a: " << &a << endl;
    a = 50;
    cout << "Gi√° tr·ªã: " << a << endl;
}

int main()
{
    int x = 10; 	// 0x34: 10
    cout << "ƒê·ªãa ch·ªâ bi·∫øn x: " << &x << endl;
    test(x);
}
```

üìù L∆∞u √Ω: tham chi·∫øu c√≥ th·ªÉ thay ƒë·ªïi gi√° tr·ªã.

üìù N·∫øu nhu c·∫ßu c·ªßa b·∫°n l√† ch·ªâ ƒë·ªçc th√¨ th√™m t·ª´ kh√≥a const, v√¨ n√≥ ch·ªâ cho ph√©p ƒë·ªçc gi√° tr·ªã, kh√¥ng cho ph√©p thay ƒë·ªïi.

üíª V√≠ d·ª• 2:
```cpp
#include <iostream>

void test(const int &a)
{   
    cout << "ƒê·ªãa ch·ªâ bi·∫øn a: " << &a << endl;
    cout << "Gi√° tr·ªã: " << a << endl;
}

int main()
{
    int x = 10; 	// 0x34: 10
    cout << "ƒê·ªãa ch·ªâ bi·∫øn x: " << &x << endl;
    test(x);
}
```

</p>
</details>

</p>
</details>

<br>

<details><summary><b>C·∫•p ph√°t ƒë·ªông trong C++</b></summary>
<p>

<details><summary><b>1 new operator </b></summary>
<p>

- To√°n t·ª≠ new ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ c·∫•p ph√°t b·ªô nh·ªõ ƒë·ªông cho m·ªôt bi·∫øn, m·ªôt m·∫£ng ho·∫∑c m·ªôt ƒë·ªëi t∆∞·ª£ng.
- Khi s·ª≠ d·ª•ng new, b·ªô nh·ªõ s·∫Ω ƒë∆∞·ª£c c·∫•p ph√°t tr√™n ph√¢n v√πng Heap (khu v·ª±c nh·ªõ d√†nh cho c·∫•p ph√°t ƒë·ªông) thay v√¨ tr√™n stack (khu v·ª±c nh·ªõ d√†nh cho c·∫•p ph√°t tƒ©nh).

<br>

</p>
</details>

<details><summary><b>2 delete operator </b></summary>
<p>

- To√°n t·ª≠ delete d√πng ƒë·ªÉ gi·∫£i ph√≥ng b·ªô nh·ªõ ƒë√£ ƒë∆∞·ª£c c·∫•p ph√°t b·∫±ng new. ƒêi·ªÅu n√†y gi√∫p tr√°nh l√£ng ph√≠ b·ªô nh·ªõ v√† hi·ªán t∆∞·ª£ng r√≤ r·ªâ b·ªô nh·ªõ (memory leak).

<br>

</p>
</details>

<details><summary><b>3. Examples </b></summary>
<p>

üíª **V√≠ d·ª• 1: C·∫•p ph√°t ƒë·ªông m·ªôt bi·∫øn ƒë∆°n**
```cpp
#include <iostream>

using namespace std;

int main()
{
    int *ptr = new int(10);
    /****************************************************
     * new int(10)
     *      + Kh·ªüi t·∫°o m·ªôt bi·∫øn int
     *      + C·∫•p ph√°t ƒë·ªông cho bi·∫øn int (0x01 - Heap)
     *      + G√°n gi√° tr·ªã t·∫°i ƒë·ªãa ch·ªâ v·ª´a c·∫•p ph√°t l√† 10
     *      + Tr·∫£ v·ªÅ ƒë·ªãa ch·ªâ c·ªßa v√πng nh·ªõ m·ªõi ƒë∆∞·ª£c c·∫•p ph√°t
     * 
     * con tr·ªè ptr s·∫Ω tr·ªè ƒë·∫øn ƒë·ªãa ch·ªâ tr√™n
     ***************************************************/

    cout << "ƒê·ªãa ch·ªâ ƒë·ªëi t∆∞·ª£ng: " << ptr << endl;
    cout << "Gi√° tr·ªã ƒë·ªëi t∆∞·ª£ng: " << *ptr << endl;

    delete ptr;
    return 0;
}
```

<br>

üíª **V√≠ d·ª• 2: C·∫•p ph√°t ƒë·ªông m·ªôt m·∫£ng**
```cpp
#include <iostream>

using namespace std;

int main(int argc, char const *argv[])
{   
    int size;
    cout << "Nh·∫≠p k√≠ch th∆∞·ªõc c·ªßa m·∫£ng: ";
    cin >> size;

    int *arr = new int[size]; 

    for (int i = 0; i < size; i++)
    {
        arr[i] = i * 2;
    }

    for (int i = 0; i < size; i++)
    {
        cout << arr[i] << " ";
    }
    cout << endl;

    delete[] arr;  // Gi·∫£i ph√≥ng b·ªô nh·ªõ   

    return 0;
}
```

üìù M·∫∑c d√π vi·ªác c·∫•p ph√°t ƒë·ªông b·∫±ng new trong C++ kh√¥ng th·ªÉ thay ƒë·ªïi k√≠ch th∆∞·ªõc gi·ªëng nh∆∞ realloc trong C, nh∆∞ng c·∫•p ph√°t ƒë·ªông v·∫´n c√≥ nhi·ªÅu ƒëi·ªÉm kh√°c bi·ªát so v·ªõi khai b√°o m·∫£ng tƒ©nh.
üìù M·∫£ng tƒ©nh: 

- K√≠ch th∆∞·ªõc ph·∫£i ƒë∆∞·ª£c x√°c ƒë·ªãnh khi bi√™n d·ªãch (compile-time), nghƒ©a l√† b·∫°n c·∫ßn bi·∫øt tr∆∞·ªõc s·ªë l∆∞·ª£ng ph·∫ßn t·ª≠ v√† kh√¥ng th·ªÉ thay ƒë·ªïi trong khi ch·∫°y ch∆∞∆°ng tr√¨nh.
- B·ªô nh·ªõ c·ªßa m·∫£ng tƒ©nh ƒë∆∞·ª£c c·∫•p ph√°t tr√™n stack, v√† n√≥ s·∫Ω t·ª± ƒë·ªông gi·∫£i ph√≥ng khi ra kh·ªèi ph·∫°m vi (scope) c·ªßa n√≥. B·ªô nh·ªõ m·∫£ng tƒ©nh kh√¥ng t·ªìn t·∫°i l√¢u d√†i trong su·ªët ch∆∞∆°ng tr√¨nh m√† ph·ª• thu·ªôc v√†o ph·∫°m vi khai b√°o.
- K√≠ch th∆∞·ªõc m·∫£ng tr√™n stack b·ªã gi·ªõi h·∫°n b·ªüi k√≠ch th∆∞·ªõc c·ªßa stack (th∆∞·ªùng l√† v√†i MB), n√™n n·∫øu b·∫°n c·∫ßn m·ªôt m·∫£ng l·ªõn, m·∫£ng tƒ©nh c√≥ th·ªÉ kh√¥ng kh·∫£ thi v√† d·ªÖ g√¢y l·ªói stack overflow.

üìù C·∫•p ph√°t ƒë·ªông v·ªõi new: 

- B·∫°n c√≥ th·ªÉ x√°c ƒë·ªãnh k√≠ch th∆∞·ªõc m·∫£ng t·∫°i th·ªùi ƒëi·ªÉm ch·∫°y, gi√∫p linh ho·∫°t h∆°n n·∫øu k√≠ch th∆∞·ªõc m·∫£ng ph·ª• thu·ªôc v√†o c√°c gi√° tr·ªã m√† b·∫°n ch·ªâ bi·∫øt trong qu√° tr√¨nh ch·∫°y ch∆∞∆°ng tr√¨nh.
- B·ªô nh·ªõ ƒë∆∞·ª£c c·∫•p ph√°t tr√™n heap, c√≥ th·ªÉ t·ªìn t·∫°i cho ƒë·∫øn khi b·∫°n gi·∫£i ph√≥ng th·ªß c√¥ng b·∫±ng delete[]. ƒêi·ªÅu n√†y cho ph√©p b·ªô nh·ªõ t·ªìn t·∫°i l√¢u d√†i h∆°n, ngay c·∫£ khi ph·∫°m vi khai b√°o c·ªßa con tr·ªè ƒë√£ k·∫øt th√∫c.
- V√¨ b·ªô nh·ªõ c·∫•p ph√°t ƒë·ªông n·∫±m tr√™n heap, b·∫°n c√≥ th·ªÉ t·∫°o ra c√°c m·∫£ng r·∫•t l·ªõn n·∫øu b·ªô nh·ªõ h·ªá th·ªëng c√≤n ƒë·ªß, m√† kh√¥ng b·ªã gi·ªõi h·∫°n b·ªüi stack.

<br>

üíª **V√≠ d·ª• 3: C·∫•p ph√°t ƒë·ªông cho m·ªôt bi·∫øn c·ªßa struct**
```cpp
#include <iostream>

using namespace std;

typedef struct
{
    int x;
    int y;
} Point;

int main(int argc, char const *argv[])
{   
    Point *p1 = new Point;
    p1->x = 10;
    p1->y = 20;
    cout << "Point 1: (" << p1->x << ", " << p1->y << ")" << endl << endl;

    Point *p2 = new Point{5, 15};
    cout << "Point 2: (" << p2->x << ", " << p2->y << ")" << endl << endl;

    Point *points = new Point[3];    // C·∫•p ph√°t ƒë·ªông cho m·ªôt m·∫£ng g·ªìm 3 bi·∫øn Point
    points[0] = {1,2};
    points[1] = {3,4};
    points[2] = {5,6};
    for (int i = 0; i < 3; i++)
    {
        cout << "Point " << i + 1 << ": (" << points[i].x << ", " << points[i].y << ")" << endl;
    }

    delete p1;
    delete p2;
    delete[] points;

    return 0;
}
```

<br>

üíª **V√≠ d·ª• 4: C·∫•p ph√°t ƒë·ªông m·ªôt m·∫£ng**
```cpp
#include <iostream>

using namespace std;

class SinhVien
{
    private:
        string name;
        int id;
        int age;
    
    public:
        SinhVien(string _name, int _age): name(_name), age(_age)
        {
            static int _id = 1;
            id = _id;
            _id++;
        }

        void display()
        {
            cout << "Name: " << name << ", ID: " << id << ", Age: " << age << endl;
        }
};

int main(int argc, char const *argv[])
{   
    SinhVien *p1 = new SinhVien("Trung", 25);
    p1->display();

    SinhVien *p2 = new SinhVien("Tuan", 22);
    p2->display();

    return 0;
}
```

<br>

</p>
</details>

</p>
</details>

<br>

<details><summary><b>Data Structure</b></summary>
<p>

<details><summary><b>1. Linked List</b></summary>
<p>

<details><summary><b>üìö Single Linked List </b></summary>
<p>

https://github.com/NHAnh2082/Cpp_Programming_Language/blob/3b23d1737f9b6e5db35057cdb03ac59fcceff890/Data_Structure/Linked_List/Single_Linked_List.hpp

</p>
</details>

<details><summary><b>üìö Doubly Linked List</b></summary>
<p>

https://github.com/NHAnh2082/Cpp_Programming_Language/blob/3b23d1737f9b6e5db35057cdb03ac59fcceff890/Data_Structure/Linked_List/Doubly_Linked_List.hpp

</p>
</details>

</p>
</details>

<details><summary><b>2. Stack</b></summary>
<p>

https://github.com/NHAnh2082/Cpp_Programming_Language/blob/3b23d1737f9b6e5db35057cdb03ac59fcceff890/Data_Structure/Stack/stack.hpp

</p>
</details>

<details><summary><b>3. Queue</b></summary>
<p>

<details><summary><b>üìö Linear Queue</b></summary>
<p>

https://github.com/NHAnh2082/Cpp_Programming_Language/blob/3b23d1737f9b6e5db35057cdb03ac59fcceff890/Data_Structure/Queue/queue_linear.hpp

</p>
</details>

<details><summary><b>üìö Circular Queue</b></summary>
<p>

https://github.com/NHAnh2082/Cpp_Programming_Language/blob/3b23d1737f9b6e5db35057cdb03ac59fcceff890/Data_Structure/Queue/queue_circular.hpp

</p>
</details>

<details><summary><b>üìö Priority Queue</b></summary>
<p>

https://github.com/NHAnh2082/Cpp_Programming_Language/blob/3b23d1737f9b6e5db35057cdb03ac59fcceff890/Data_Structure/Queue/queue_priority.hpp

</p>
</details>

</p>
</details>

</p>
</details>

<br>

<details><summary><b>auto & decltype keywords</b></summary>
<p>

<details><summary><b>1. auto keyword </b></summary>
<p>

- C√∫ ph√°p khai b√°o bi·∫øn th√¥ng th∆∞·ªùng: ``` <data_type> <name_of_variable> = <initial_value> ```
- D·ª±a tr√™n c√∫ ph√°p khai b√°o bi·∫øn n√†y, l·∫≠p tr√¨nh vi√™n ph·∫£i x√°c ƒë·ªãnh tr∆∞·ªõc ƒë∆∞·ª£c ki·ªÉu d·ªØ li·ªáu c·∫ßn s·ª≠ d·ª•ng ƒë·ªÉ l∆∞u tr·ªØ gi√° tr·ªã.
- T·ª´ C++11, **compiler** c√≥ th·ªÉ t·ª± suy lu·∫≠n ki·ªÉu d·ªØ li·ªáu cho gi√° tr·ªã m√† b·∫°n mu·ªën s·ª≠ d·ª•ng b·∫±ng c√°ch s·ª≠ d·ª•ng t·ª´ kh√≥a **auto**, qu√° tr√¨nh suy lu·∫≠n n√†y di·ªÖn ra t·∫°i th·ªùi ƒëi·ªÉm bi√™n d·ªãch.
- C√∫ ph√°p: ``` auto <name_of_variable> = <expression> ```
- Gi√° tr·ªã kh·ªüi t·∫°o l√† th√†nh ph·∫ßn **b·∫Øt bu·ªôc** ph·∫£i c√≥ khi s·ª≠ d·ª•ng t·ª´ kh√≥a auto, compiler s·∫Ω d·ª±a tr√™n gi√° tr·ªã kh·ªüi t·∫°o ƒë·ªÉ quy·∫øt ƒë·ªãnh ki·ªÉu d·ªØ li·ªáu n√†o ph√π h·ª£p v·ªõi bi·∫øn (c√≥ th·ªÉ l√† 1 con s·ªë, 1 k√≠ t·ª±, 1 chu·ªói k√≠ t·ª±, ho·∫∑c 1 bi·ªÉu th·ª©c to√°n h·ªçc...).

<br>

üíª **V√≠ d·ª•:**
```cpp
#include <iostream>
#include <typeinfo>
#include <cstdint>

using namespace std;

int main(int argc, char const *argv[])
{
    auto x = 10;		// i	-> int
    auto pi = 3.14;		// d	-> double
    auto character = 'a';	// c	-> char
    auto str = "Anh";		// PKc	-> Pointer constant char -> const char *

    cout << "Type of x: "         << typeid(x).name()           << endl;
    cout << "Type of PI: "        << typeid(pi).name()          << endl;
    cout << "Type of character: " << typeid(character).name()   << endl;
    cout << "Type of string: "    << typeid(str).name()         << endl;
    return 0;
}
```

<br>

</p>
</details>

<details><summary><b>2. decltype keyword</b></summary>
<p>

- C≈©ng t∆∞∆°ng t·ª± v·ªõi t·ª´ kh√≥a **auto**, t·ª´ kh√≥a **decltype** gi√∫p ch∆∞∆°ng tr√¨nh t·ª± ƒë·ªông x√°c ƒë·ªãnh ki·ªÉu d·ªØ li·ªáu cho bi·∫øn. Nh∆∞ng c√°ch s·ª≠ d·ª•ng t·ª´ kh√≥a decltype c√≥ m·ªôt ch√∫t kh√°c bi·ªát so v·ªõi c√°ch s·ª≠ d·ª•ng t·ª´ kh√≥a auto.

- ƒê·ªÉ ph√¢n bi·ªát:

	+ T·ª´ kh√≥a **auto** x√°c ƒë·ªãnh ki·ªÉu d·ªØ li·ªáu d·ª±a tr√™n ph·∫ßn kh·ªüi t·∫°o c·ªßa bi·∫øn.
	+ T·ª´ kh√≥a **decltype** x√°c ƒë·ªãnh ki·ªÉu d·ªØ li·ªáu t·ª´ 1 bi·∫øn ho·∫∑c 1 bi·ªÉu th·ª©c kh√°c.

V√¨ th·∫ø, khi s·ª≠ d·ª•ng t·ª´ kh√≥a decltype, ch√∫ng ta ph·∫£i s·ª≠ d·ª•ng k√®m v·ªõi 1 ƒë·ªëi t∆∞·ª£ng c·ª• th·ªÉ (1 bi·∫øn, 1 bi·ªÉu th·ª©c ho·∫∑c 1 ƒë·ªëi t∆∞·ª£ng c·ªßa class n√†o ƒë√≥...).

- C√∫ ph√°p: ``` decltype(<object or expression>) <name_of_variable> = <initial_value> ```
- Gi√° tr·ªã kh·ªüi t·∫°o (ph·∫ßn ƒë·∫∑t trong ngo·∫∑c vu√¥ng) l√† kh√¥ng b·∫Øt bu·ªôc v√¨ t·ª´ kh√≥a decltype ƒë√£ x√°c ƒë·ªãnh ƒë∆∞·ª£c ki·ªÉu d·ªØ li·ªáu b·∫±ng c√°ch l·∫•y ki·ªÉu d·ªØ li·ªáu c·ªßa ƒë·ªëi t∆∞·ª£ng (object) ho·∫∑c bi·ªÉu th·ª©c (expression).

<br>

üíª **V√≠ d·ª• 1:**
```cpp
#include <iostream>

using namespace std;

int main()
{
    int x = 10;
    decltype(x) y = 20;  // y c√≥ ki·ªÉu int gi·ªëng x
    cout << y << endl;

    decltype(3.14) pi;  // pi c√≥ ki·ªÉu double
}
```

<br>

üíª **V√≠ d·ª• 2:**
```cpp
#include <iostream>

using namespace std;

int fun1(){ return 10; }

char fun2(){ return 'g'; }

int main()
{
    decltype(fun1()) x; // Data type of x is same as return type of fun1()
    decltype(fun2()) y; // Data type of y is same as return type of fun2()

    cout << typeid(x).name() << endl;
    cout << typeid(y).name() << endl;

    return 0;
}
```

<br>

üíª **V√≠ d·ª• 3:**
```cpp
#include <iostream>

using namespace std;

template <typename T1, typename T2>
auto sum(T1 a, T2 b) -> decltype(a+b)
{
    return a+b;
}

int main(int argc, char const *argv[])
{
    cout << "Sum of 2, 3 = " << sum(2, 3) << endl;
    return 0;
}
```

<br>

</p>
</details>

</p>
</details>

<br>

<details><summary><b>uniform initialization & constexpr</b></summary>
<p>

<details><summary><b>1. uniform initialization (kh·ªüi t·∫°o ƒë·ªìng nh·∫•t)</b></summary>
<p>

T·ª´ C++11, C++ h·ªó tr·ª£ c√∫ ph√°p ``` {} ``` ƒë·ªÉ kh·ªüi t·∫°o bi·∫øn m·ªôt c√°ch th·ªëng nh·∫•t.

üíª **V√≠ d·ª• 1:**
```cpp
#include <iostream>
#include <vector>

struct Point
{
   int x,y;
};

int main()
{
   int a{10};			// kh·ªüi t·∫°o ki·ªÉu int	// int a = 10
   double b{5.5};		// kh·ªüi t·∫°o ki·ªÉu double // double b = 5.5
   Point p{1,2};		// kh·ªüi t·∫°o struct	// Point p = {1,2}
   vector<int> vec{1,2,3,4};	// kh·ªüi t·∫°o vector	// vector<int> vec = {1,2,3,4}
}
```

üìù L·ª£i √≠ch c·ªßa Uniform Initialization:

- Tr√°nh l·ªói kh·ªüi t·∫°o (v√≠ d·ª•: kh√¥ng c√≥ chuy·ªÉn ƒë·ªïi ng·∫ßm gi·ªØa double ‚Üí int).
- ƒê·ªìng nh·∫•t c√∫ ph√°p gi·ªØa bi·∫øn, struct, array, v√† container.

<br>

**·ª®ng d·ª•ng**

üìù **Kh·ªüi t·∫°o m·∫£ng ƒë·ªông**

```cpp
#include <iostream>

using namespace std;

int main()
{
	// demonstrate initialization of dynamic array in C++ using uniform initialization
	int* ptr = new int[5]{ 1, 2, 3, 4, 5 };

	// printing the contents of the array
	for (int i = 0; i < 5; i++) cout << *(ptr + i) << " ";
}
```

<br>

üìù **Kh·ªüi t·∫°o m·∫£ng trong class**

```cpp
#include <iostream>

using namespace std;

class A
{
	int arr[3];

public:
	// initializing array using uniform initialization
	A(int x, int y, int z) : arr{ x, y, z }{};

	void show()
	{
		for (int i = 0; i < 3; i++) cout << *(arr + i) <<" ";
	}
};

int main()
{
	A a(1, 2, 3);
	a.show();
	return 0;
}
```

<br>

üìù **Kh·ªüi t·∫°o ng·∫ßm (implicit) c√°c ƒë·ªëi t∆∞·ª£ng**

```cpp
#include <iostream>

using namespace std;

class A
{
	int a;
	int b;

public:
	A(int x, int y): a(x), b(y){}

	void show() { cout << a << " " << b; }
};

A f(int a, int b)
{
	return { a, b };
}

void f1(A x)
{
	x.show();
}

int main()
{
	A x = f(1, 2);
	x.show();
	f1({3,4});
	return 0;
}
```

<br>

</p>
</details>

<details><summary><b>2. constexpr (bi·ªÉu th·ª©c h·∫±ng s·ªë)</b></summary>
<p>

- T·ª´ C++11, **constexpr** cho ph√©p khai b√°o c√°c bi·∫øn ho·∫∑c h√†m c√≥ th·ªÉ t√≠nh to√°n t·∫°i th·ªùi ƒëi·ªÉm bi√™n d·ªãch.
- Khi m·ªôt bi·∫øn, h√†m ho·∫∑c to√°n t·ª≠ ƒë∆∞·ª£c khai b√°o v·ªõi **constexpr**, gi√° tr·ªã c·ªßa n√≥ ph·∫£i ƒë∆∞·ª£c **t√≠nh to√°n trong l√∫c bi√™n d·ªãch** n·∫øu c√≥ th·ªÉ. ƒêi·ªÅu n√†y gi√∫p tƒÉng hi·ªáu su·∫•t ch∆∞∆°ng tr√¨nh b·∫±ng c√°ch gi·∫£m thi·ªÉu c√°c ph√©p t√≠nh t·∫°i runtime.

```cpp
#include <iostream>

using namespace std;

constexpr int square(int x)
{
    return x * x;
}

int main()
{
    constexpr int a = 10;     		// H·∫±ng s·ªë
    constexpr int b = square(a); 	// ƒê∆∞·ª£c t√≠nh t·∫°i compile-time

    int x = 5;
    // constexpr int y = square(x); 	// L·ªói v√¨ x kh√¥ng ph·∫£i h·∫±ng s·ªë
}
```

<br>

</p>
</details>

</p>
</details>

<br>

<details><summary><b>Template</b></summary>
<p>

<details><summary><b>1. Gi·ªõi thi·ªáu Template </b></summary>
<p>

Trong C++ cho ph√©p vi·∫øt nhi·ªÅu h√†m c√≥ t√™n gi·ªëng nhau nh∆∞ng kh√°c nhau tham s·ªë truy·ªÅn v√†o v√† ki·ªÉu tr·∫£ v·ªÅ (T√≠nh ƒëa h√¨nh Compile - Time). V√≠ d·ª•:

```cpp
int tong(int a, int b)
{
    return a+b;
}

double tong(double a, double b)
{
    return a+b;
}
```

üìù Hai h√†m tr√™n c√≥ ch·ª©c nƒÉng gi·ªëng nhau, ƒë·ªÅu d√πng ƒë·ªÉ t√≠nh t·ªïng 2 s·ªë, ch·ªâ kh√°c nhau ki·ªÉu tr·∫£ v·ªÅ v√† ki·ªÉu d·ªØ li·ªáu c√°c input params.

ü§î V·∫≠y l√†m sao ƒë·ªÉ thi·∫øt k·∫ø m·ªôt h√†m chung cho hai ho·∫∑c nhi·ªÅu h√†m t∆∞∆°ng t·ª± tr√™n‚ùì

‚û°Ô∏è S·ª≠ d·ª•ng Template.

Template l√† m·ªôt t√≠nh nƒÉng m·∫°nh m·∫Ω gi√∫p vi·∫øt m√£ t·ªïng qu√°t, c√≥ th·ªÉ l√†m vi·ªác v·ªõi nhi·ªÅu ki·ªÉu d·ªØ li·ªáu kh√°c nhau m√† kh√¥ng c·∫ßn ph·∫£i vi·∫øt l·∫°i m√£ cho t·ª´ng ki·ªÉu c·ª• th·ªÉ. C√≥ hai lo·∫°i template ch√≠nh trong C++:

- Function Template (H√†m m·∫´u).
- Class Template (L·ªõp m·∫´u).

</p>
</details>

<details><summary><b>2. Function Template </b></summary>
<p>

Function Template trong C++ cho ph√©p b·∫°n vi·∫øt m·ªôt h√†m t·ªïng qu√°t c√≥ th·ªÉ ho·∫°t ƒë·ªông v·ªõi nhi·ªÅu ki·ªÉu d·ªØ li·ªáu kh√°c nhau m√† kh√¥ng c·∫ßn vi·∫øt l·∫°i m√£ ngu·ªìn cho t·ª´ng ki·ªÉu d·ªØ li·ªáu c·ª• th·ªÉ. ƒêi·ªÅu n√†y gi√∫p tƒÉng t√≠nh t√°i s·ª≠ d·ª•ng c·ªßa m√£ v√† l√†m cho ch∆∞∆°ng tr√¨nh linh ho·∫°t h∆°n.

<br>

üíª **Function Template v·ªõi m·ªôt ki·ªÉu d·ªØ li·ªáu t·ªïng qu√°t**

```cpp
#include <iostream>
#include <cassert>

using namespace std;

template <typename T>
T sum(T a, T b)
{
    return (T)a+b;
}

template <typename T>
T divide(T a, T b)
{
    assert(b != 0 && "M·∫´u s·ªë b·∫±ng 0");
    return (T)a/b;
}

int main(int argc, char const *argv[])
{
    cout << "Sum: " << sum(1,5) << endl;        	// T: int
    cout << "Sum: " << sum(1.5,5.6) << endl;    	// T: double
    cout << "Divide: " << divide(3,1) << endl;
    cout << "Divide: " << divide(3.5,1.6) << endl;
    cout << "Divide: " << divide(3,0) << endl;
    return 0;
}
```

üìù Khi g·ªçi h√†m sum, compiler s·∫Ω suy lu·∫≠n ki·ªÉu d·ª±a tr√™n c√°c tham s·ªë truy·ªÅn v√†o. H√†m tr√™n t√≠nh t·ªïng 2 s·ªë nh∆∞ng tham s·ªë truy·ªÅn v√†o ph·∫£i c√πng ki·ªÉu d·ªØ li·ªáu ( (int, int) ho·∫∑c (double, double) ho·∫∑c (float, float) ...). N·∫øu c·ªë t√¨nh truy·ªÅn v√†o 2 tham s·ªë v·ªõi ki·ªÉu d·ªØ li·ªáu kh√°c nhau th√¨ compiler s·∫Ω b√°o l·ªói ``` error: no matching function for call to 'sum(int, double)' ```

üìù N·∫øu mu·ªën t√≠nh t·ªïng 2 s·ªë c√≥ ki·ªÉu d·ªØ li·ªáu kh√°c nhau th√¨ ph·∫£i khai b√°o m·ªôt template kh√°c.

<br>

üíª **Function Template v·ªõi nhi·ªÅu ki·ªÉu d·ªØ li·ªáu t·ªïng qu√°t**

```cpp
#include <iostream>

using namespace std;

template <typename T1, typename T2>
auto sum(T1 a, T2 b) -> decltype(a+b)
{
    return a+b;
}

int main(int argc, char const *argv[])
{
    cout << "Sum: " << sum(1, 5) << endl;	// T1, T2: int
    cout << "Sum: " << sum(1.5, 5.8) << endl;	// T1, T2: double
    cout << "Sum: " << sum(1.6, 5) << endl; 	// T1: double, T2: int
    return 0;		
}
```

üìù T·ª´ kh√≥a auto ƒë·ªÉ cho ph√©p tr√¨nh bi√™n d·ªãch t·ª± ƒë·ªông suy ra ki·ªÉu tr·∫£ v·ªÅ c·ªßa ph√©p c·ªông gi·ªØa a v√† b.

üìù Phi√™n b·∫£n n√†y t·ªïng qu√°t h∆°n so v·ªõi phi√™n b·∫£n ban ƒë·∫ßu v√¨ n√≥ c√≥ th·ªÉ x·ª≠ l√Ω hai ki·ªÉu d·ªØ li·ªáu kh√°c nhau.

<br>

üíª **Function Template v·ªõi tham s·ªë m·∫∑c ƒë·ªãnh**

```cpp
#include <iostream>

using namespace std;

template <typename T = int>
T square(T x)
{
    return x * x;
}

int main(int argc, char const *argv[])
{
    cout << square(4) << endl;			// l·∫•y m·∫∑c ƒë·ªãnh -> int 	  -> 16
    cout << square<double>(4.5) << endl;	// √©p ki·ªÉu 	-> double -> 20.25
    return 0;		
}
```

<br>

üíª **Function Template v·ªõi Specialization (Chuy√™n bi·ªát h√≥a)**

- Specialization (chuy√™n bi·ªát h√≥a) ƒë∆∞·ª£c s·ª≠ d·ª•ng khi m·ªôt ki·ªÉu d·ªØ li·ªáu c·ª• th·ªÉ y√™u c·∫ßu m·ªôt c√°ch x·ª≠ l√Ω kh√°c bi·ªát so v·ªõi c√°c ki·ªÉu d·ªØ li·ªáu chung.

```cpp
#include <iostream>

using namespace std;

template <typename T>
void display(T value)
{
    cout << value << endl;
}

// Chuy√™n bi·ªát h√≥a cho ki·ªÉu 'const char*'
template <>
void display<const char*>(const char *str)
{
    cout << "String: " << str << endl;
}

// Chuy√™n bi·ªát h√≥a cho ki·ªÉu 'int'
template <>
void display<int>(int value)
{
    cout << ++value << endl;
}

int main(int argc, char const *argv[])
{
    display(3.14);
    display("Hello");
    display(2);
    return 0;
}
```

<br>

</p>
</details>

<details><summary><b>3. Class Template </b></summary>
<p>

Class Template trong C++ gi√∫p t·∫°o ra c√°c l·ªõp t·ªïng qu√°t c√≥ th·ªÉ ho·∫°t ƒë·ªông v·ªõi nhi·ªÅu ki·ªÉu d·ªØ li·ªáu kh√°c nhau m√† kh√¥ng c·∫ßn ƒë·ªãnh nghƒ©a l·∫°i m√£ ngu·ªìn cho t·ª´ng ki·ªÉu d·ªØ li·ªáu c·ª• th·ªÉ.

<br>

üíª **V√≠ d·ª• 1:**
```cpp
#include <iostream>

using namespace std;

template <typename T>
class Sensor
{
    private:
        T value;
    
    public: 
        Sensor(T init): value(init){}

        void readSensor(T newValue)
	{
            value = newValue;
        }

        T getValue()
	{
            return value;
        }

        void display()
	{
            cout << "Gi√° tr·ªã c·∫£m bi·∫øn: " << value << endl;
        }
};

int main(int argc, char const *argv[])
{
    Sensor<double> tempSensor(25.7);
    tempSensor.display();

    Sensor<int> lightSensor(512);
    lightSensor.display();

    Sensor<string> stateSensor("OFF");
    stateSensor.display();
    return 0;
}
```

<br>

üíª **V√≠ d·ª• 2:**
```cpp
#include <iostream>
#include <string>

using namespace std;

template <typename T1, typename T2>
class Pair
{
	private:
	    T1 first;
	    T2 second;

	public:
	    Pair(T1 f, T2 s) : first(f), second(s) {}

	    void show()
	    {
	        std::cout << "First: " << first << ", Second: " << second << std::endl;
	    }
};

int main()
{
    Pair<int, double> p1(10, 3.14);
    Pair<string, char> p2("Hello", 'A');

    p1.show(); // Output: First: 10,    Second: 3.14
    p2.show(); // Output: First: Hello, Second: A
    return 0;
}
```

<br>

üíª **V√≠ d·ª• 3:**
```cpp
#include <iostream>

using namespace std;

template <typename T>
class Test
{
    private: 
        T value;
    
    public:
        Test(T v);

        void display();
};

// ƒê·ªãnh nghƒ©a constructor b√™n ngo√†i class
template <typename T>
Test<T>::Test(T v) : value(v){}

// ƒê·ªãnh nghƒ©a method b√™n ngo√†i class
template <typename T>
void Test<T>::display()
{
    cout << "Value: " << value << endl;
}

int main(int argc, char const *argv[])
{
    Test<string> t1("hello");
    t1.display();

    Test<int> t2(10);
    t2.display();
    return 0;
}
```

<br>

üíª **V√≠ d·ª• 4:**
```cpp
#include <iostream>
#include <string>

using namespace std;

// Template chung
template <typename T>
class Printer 
{
    public:
        void print(T value) 
        {
            cout << "Generic: " << value << endl;
        }
};

// Chuy√™n bi·ªát h√≥a cho ki·ªÉu std::string
template <>
class Printer<string> 
{
    public:
        void print(string value) 
        {
            cout << "String specialization: " << value << endl;
        }
};

int main() 
{
    Printer<int> intPrinter;
    intPrinter.print(100);      // Output: Generic: 100

    Printer<string> strPrinter;
    strPrinter.print("Hello");  // Output: String specialization: Hello
    return 0;
}
```

<br>

üíª **V√≠ d·ª• 5:**
```cpp
#include <iostream>
#include <string>

using namespace std;

class Sensor
{
    public:
        virtual double getValue() const = 0;

        virtual string getUnit() const = 0;
};

// Class ƒë·∫°i di·ªán cho c·∫£m bi·∫øn nhi·ªát ƒë·ªô (Temperature Sensor)
class TemperatureSensor : public Sensor
{
    private:
        double temp;

    public:
        double getValue() const override
        {
            // temp = 30.3;
            return 40.5; // Gi√° tr·ªã c·∫£m bi·∫øn gi·∫£ ƒë·ªãnh
        }

        string getUnit() const override
        {
            return "Celsius";
        }
};

// Class ƒë·∫°i di·ªán cho c·∫£m bi·∫øn √°p su·∫•t l·ªëp (Tire Pressure Sensor)
class TirePressureSensor : public Sensor
{
    public:
        double getValue() const override 
        {
            return 32; // Gi√° tr·ªã c·∫£m bi·∫øn gi·∫£ ƒë·ªãnh
        }

        string getUnit() const override 
        {
            return "PSI";
        }
};

// Template class qu·∫£n l√Ω hai c·∫£m bi·∫øn kh√°c nhau
template <typename Sensor1, typename Sensor2>
class VehicleSensors
{
    private:
        Sensor1 sensor1;  // ƒê·ªëi t∆∞·ª£ng c·∫£m bi·∫øn 1
        Sensor2 sensor2;  // ƒê·ªëi t∆∞·ª£ng c·∫£m bi·∫øn 2

    public:
        // Constructor nh·∫≠n v√†o hai ƒë·ªëi t∆∞·ª£ng c·∫£m bi·∫øn
        VehicleSensors(Sensor1 s1, Sensor2 s2) : sensor1(s1), sensor2(s2) {}

        // H√†m hi·ªÉn th·ªã th√¥ng tin c·ªßa c·∫£ hai c·∫£m bi·∫øn
        void displaySensorsInfo() const 
        {
            cout << "Sensor 1 Value: " << sensor1.getValue() << " " << sensor1.getUnit() << endl;
            cout << "Sensor 2 Value: " << sensor2.getValue() << " " << sensor2.getUnit() << endl;
        }
};

int main()
{
    // T·∫°o ƒë·ªëi t∆∞·ª£ng c·∫£m bi·∫øn nhi·ªát ƒë·ªô
    TemperatureSensor tempSensor;

    // T·∫°o ƒë·ªëi t∆∞·ª£ng c·∫£m bi·∫øn √°p su·∫•t l·ªëp
    TirePressureSensor pressureSensor;

    // Qu·∫£n l√Ω c·∫£ hai c·∫£m bi·∫øn b·∫±ng class VehicleSensors
    VehicleSensors vehicleSensors(tempSensor, pressureSensor);
    vehicleSensors.displaySensorsInfo();

    return 0;
}
```

<br>

</p>
</details>

<details><summary><b>4. Variadic Template </b></summary>
<p>

Variadic Template cho ph√©p b·∫°n t·∫°o c√°c h√†m template ho·∫∑c l·ªõp template c√≥ th·ªÉ nh·∫≠n m·ªôt s·ªë l∆∞·ª£ng tham s·ªë kh√¥ng x√°c ƒë·ªãnh. ƒêi·ªÅu n√†y gi√∫p b·∫°n vi·∫øt m√£ linh ho·∫°t h∆°n khi l√†m vi·ªác v·ªõi danh s√°ch tham s·ªë c√≥ k√≠ch th∆∞·ªõc ƒë·ªông.

<br>

üíª **V√≠ d·ª• 1:**
```cpp
#include <iostream>

using namespace std;

template <typename... Args>
void count(Args... args)
{
    cout << "Number of arguments: " << sizeof...(args) << endl;
}

int main(int argc, char const *argv[])
{
    count(1, 2, 3.5, 'a', "hello");
    return 0;
}
```

üìù ``` typename... ```: ƒë·ªãnh nghƒ©a nhi·ªÅu ki·ªÉu t·ªïng qu√°t: typename Args1, typename Args2, typename Args3, v.v

üìù ``` Args... ```: nhi·ªÅu ki·ªÉu d·ªØ li·ªáu, ·ª©ng v·ªõi tham s·ªë truy·ªÅn v√†o: Args1 arg1, Args2 arg2, Args3 arg3, v.v

üìù ``` sizeof...(args) ```: ƒë·∫øm s·ªë l∆∞·ª£ng tham s·ªë

<br>

üíª **V√≠ d·ª• 2:**
```cpp
#include <iostream>

using namespace std;

template <typename T>
void print(T last)
{
    cout << last << endl;
}

template <typename T, typename... Args>
void print(T first, Args... args)
{
    cout << first << " ";
    if (sizeof...(args) > 0) print(args...);
}

template<typename... Args>
void print1(Args... args)
{
    (cout << ... << args) << '\n';
}

int main(int argc, char const *argv[])
{
    print(1, 2, 3.5, 'a', "hello");
    print1(1, 2, 3.5, 'a', "hello");
    return 0;
}
```

üìù ``` print(args...) ```: g·ªçi l·∫°i h√†m v·ªõi danh s√°ch tham s·ªë c√≤n l·∫°i.

üìù ``` (std::cout << ... << args) ```: In t·∫•t c·∫£ c√°c tham s·ªë

<br>

üíª **V√≠ d·ª• 3:**
```cpp
#include <iostream>

using namespace std;

/* C√°ch 1 */
// template <typename... Args>
// auto sum(Args... args)
// {
//     return (args + ...);
// }

/* C√°ch 2 */
// Function Template khi ch·ªâ c√≥ m·ªôt tham s·ªë
template<typename T>
T sum(T value)
{
    return value;
}

// Function Template s·ª≠ d·ª•ng Variadic Template, √≠t nh·∫•t 2 tham s·ªë
template<typename T, typename... Args>  
auto sum(T first, Args... args)
{        
    return first + sum(args...);        
}

int main(int argc, char const *argv[])
{
    cout << sum(1, 2, 3.6, 5.7, 40) << endl;
    /*********************************************************************************************
     * L·∫ßn 1: first = 1,    args... = 2, 3.6, 5.7, 40  --> 1 + sum(2, 3.6, 5.7, 40)
     * L·∫ßn 2: first = 2,    args... = 3.6, 5.7, 40     --> 1 + (2 + sum(3.6, 5.7, 40))
     * L·∫ßn 3: first = 3.6,  args... = 5.7, 40          --> 1 + 2 + (3.6 + sum(5.7, 40))
     * L·∫ßn 4: first = 5.7,  args... = 40               --> 1 + 2 + 3.6 + (5.7 + sum(40))
     * L·∫ßn 5: g·ªçi h√†m sum m·ªôt ƒë·ªëi s·ªë --> return 40     --> 1 + 2 + 3.6 + 5.7 + 40
     ********************************************************************************************/
    return 0;
}
```

<br>

üíª **V√≠ d·ª• 4:**
```cpp
#include <iostream>

using namespace std;

// Class t·ªïng qu√°t s·ª≠ d·ª•ng Variadic Template
template <typename... Args>
class MyClass;

// ƒê·ªãnh nghƒ©a class khi kh√¥ng c√≥ ƒë·ªëi s·ªë
template <>
class MyClass<>
{
    public:
        void display() 
        {
            cout << "No arguments" << endl;
        }
};

// ƒê·ªãnh nghƒ©a class khi c√≥ √≠t nh·∫•t m·ªôt ƒë·ªëi s·ªë
template <typename T, typename... Args> 
class MyClass<T, Args...> : public MyClass<Args...>
{
    private:
        T first_;

    public:
        MyClass(T first, Args... args): first_(first),  MyClass<Args...>(args...){} // T first_ = first, Args1 args1_ = args1, Args2 args2_ = args2,...

        void display()
        {
            cout << first_ << " ";
            MyClass<Args...>::display(); // G·ªçi h√†m display c·ªßa l·ªõp c∆° s·ªü
        }   

};

int main() 
{
    MyClass<int, double, char> obj(1, 2.5, 'A');
    obj.display();  // K·∫øt qu·∫£: 1 2.5 A

    MyClass obj1;
    obj1.display();
    return 0;
}

/**************************************************************
 * L·∫ßn 1:
 *  + T = int, Args... = double, char
 *  + first = 1, args... = 2.5, 'A'
 *  --> In ra: 1            --> MyClass<double, char>(2.5, 'A')
 * 
 * L·∫ßn 2:
 *  + T = double, Args... = char
 *  + first = 2.5, args... = 'A'
 *  --> In ra: 1 2.5        --> MyClass<char>('A')
 * 
 * L·∫ßn 3:
 *  + T = char, Args... kh√¥ng c√≤n
 *  + first = 'A', args... kh√¥ng c√≤n
 *  --> In ra: 1 2.5 'A'    --> MyClass<>
 * 
 * L·∫ßn 4:
 *  + Kh√¥ng c√≤n ƒë·ªëi s·ªë
 *  --> In ra: 1 2.5 'A' No arguments
 *************************************************************/
```

<br>

</p>
</details>

</p>
</details>

<br>

<details><summary><b>Namespace</b></summary>
<p>

<details><summary><b>1. Gi·ªõi thi·ªáu Namespace </b></summary>
<p>

- Namespace l√† t·ª´ kh√≥a trong C++ ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ ƒë·ªãnh nghƒ©a m·ªôt ph·∫°m vi nh·∫±m m·ª•c ƒë√≠ch ph√¢n bi·ªát c√°c bi·∫øn, h√†m, class, ... c√πng t√™n trong c√°c ph·∫ßn c·ªßa ch∆∞∆°ng tr√¨nh ho·∫∑c c√°c th∆∞ vi·ªán kh√°c nhau.
- C√∫ ph√°p:
```cpp
namespace name_of_namespace{
    /* source code */
}
```

üíª **V√≠ d·ª• 1:**
File B.cpp
```cpp
#include <iostream>

using namespace std;

namespace fileB
{
    void display(int id){
        cout << "This is file B.cpp, id = " << id << endl;
    }
}
```

File C.cpp
```cpp
#include <iostream>
using namespace std;

namespace fileC
{
    void display(int id){
        cout << "This is file C.cpp, id = " << id << endl;
    }
}
```

File A.cpp
```cpp
#include <iostream>
#include "fileB.cpp"
#include "fileC.cpp"
using namespace std;

int main(int argc, char const *argv[])
{
    fileB::display(2);
    fileC::display(2);
    return 0;
}
```

<br>

üíª **V√≠ d·ª• 2:**
```cpp
#include <iostream>
using namespace std;

namespace A
{
    char *name = (char*)"Trung 20";

    void display(){ cout << "Name: " << name << endl; }
}


namespace B
{
    char *name = (char*)"Trung 21";

    void display(){ cout << "Name: " << name << endl; }

    class SinhVien
    {
        private:
            string name;
            int id;
        
        public:
            SinhVien()
            {
                static int _ID = 1;
                id = _ID;
                _ID++;
            }

            void setName(string newName){
                name = newName;
            }

            string getName() const{
                return name;
            }

            int getID() const{
                return id;
            }

            void display(){
                cout << "T√™n sinh vi√™n: " << getName() << endl;
                cout << "ID: " << getID() << endl;
            }
    };
}

int main(int argc, char const *argv[])
{
    cout << "Name: " << A::name << endl;
    cout << "Name: " << B::name << endl;


    A::display();
    B::display();


    B::SinhVien sv1;
    sv1.setName("Trung");
    sv1.display();
    return 0;
}
```

üìù Chu·ªói "Trung 21": n·∫±m ·ªü rdata (data read-only) ho·∫∑c text t√πy compiler.

üìù char *name: bi·∫øn con tr·ªè to√†n c·ª•c, ƒë√£ kh·ªüi t·∫°o n√™n l∆∞u ·ªü data.

üìù string name: m·ªôt bi·∫øn c·ª•c b·ªô trong m·ªói ƒë·ªëi t∆∞·ª£ng SinhVien. Khi m·ªôt ƒë·ªëi t∆∞·ª£ng SinhVien ƒë∆∞·ª£c t·∫°o, v√πng nh·ªõ cho name s·∫Ω ƒë∆∞·ª£c c·∫•p ph√°t trong:

- stack: n·∫øu ƒë·ªëi t∆∞·ª£ng SinhVien ƒë∆∞·ª£c khai b√°o tƒ©nh ho·∫∑c c·ª•c b·ªô trong m·ªôt h√†m.
- Heap: n·∫øu ƒë·ªëi t∆∞·ª£ng SinhVien ƒë∆∞·ª£c c·∫•p ph√°t ƒë·ªông b·∫±ng new.

üìù int id: T∆∞∆°ng t·ª± name, bi·∫øn id l√† bi·∫øn th√†nh vi√™n non-static c·ªßa class, n√™n s·∫Ω ƒë∆∞·ª£c l∆∞u trong stack ho·∫∑c heap t√πy v√†o c√°ch c·∫•p ph√°t ƒë·ªëi t∆∞·ª£ng SinhVien.

üìù static int _ID: bi·∫øn static c·ª•c b·ªô trong constructor SinhVien. Bi·∫øn static c·ª•c b·ªô ƒë∆∞·ª£c l∆∞u tr·ªØ trong data segment v√† t·ªìn t·∫°i su·ªët th·ªùi gian ch·∫°y c·ªßa ch∆∞∆°ng tr√¨nh.

<br>

</p>
</details>

<details><summary><b>2. using keyword </b></summary>
<p>

- T·ª´ kh√≥a using cho ph√©p b·∫°n khai b√°o namespace ƒë·ªÉ s·ª≠ d·ª•ng c√°c th√†nh vi√™n trong namespace m√† kh√¥ng c·∫ßn ph·∫£i s·ª≠ d·ª•ng to√°n t·ª≠ '::' m·ªói khi truy c·∫≠p.
- Ch·ªâ s·ª≠ d·ª•ng using namespace khi member mu·ªën truy c·∫≠p ƒë·∫øn l√† duy nh·∫•t.

üíª **V√≠ d·ª•:**
```cpp
#include <iostream>

using namespace std;

namespace A{
    char *name = (char*)"Trung 20";
}

namespace B{
    char *name = (char*)"Trung 21";
}

using namespace A;

// using namespace B; // error: tham chi·∫øu kh√¥ng r√µ r√†ng

int main(int argc, char const *argv[])
{
    cout << "Name: " << name << endl;
    cout << "Name: " << B::name << endl;
    return 0;
}
```

<br>

</p>
</details>

<details><summary><b>3. Nested Namespace </b></summary>
<p>

- C++ cho ph√©p t·∫°o c√°c namespace l·ªìng nhau, nghƒ©a l√† m·ªôt namespace c√≥ th·ªÉ ch·ª©a m·ªôt namespace kh√°c b√™n trong n√≥.

üíª **V√≠ d·ª•:**
```cpp
#include <iostream>

using namespace std;

namespace A{
    char *name = (char*)"Trung 20";

    namespace C{
        char *str = (char*)"Hoang";
    }
}

namespace B{
    char *name = (char*)"Trung 21";
}

using namespace A::C;

int main(int argc, char const *argv[])
{
    cout << "Name: " << A::name << endl;
    cout << "Name: " << B::name << endl;
    cout << "Name: " << A::C::str << endl;

    str = (char*)"Hello World";
    cout << "Name: " << str << endl;
    return 0;
}
```

<br>

</p>
</details>

<details><summary><b>4. Extending a Namespace </b></summary>
<p>

- Namespace c√≥ th·ªÉ ƒë∆∞·ª£c m·ªü r·ªông b·∫±ng c√°ch khai b√°o nhi·ªÅu l·∫ßn c√πng m·ªôt t√™n namespace trong c√°c ph·∫ßn kh√°c nhau c·ªßa ch∆∞∆°ng tr√¨nh. C√°c khai b√°o n√†y s·∫Ω ƒë∆∞·ª£c tr√¨nh bi√™n d·ªãch gh√©p l·∫°i th√†nh m·ªôt namespace duy nh·∫•t.

üíª **V√≠ d·ª•:**

**File lcd1.hpp**
```cpp
#ifndef _LCD1_HPP
#define _LCD1_HPP

namespace LCD{
    int temp;

    class lcd{
        private:

        public:
            lcd(/* args */);
            ~lcd();
    };

    lcd::lcd(){}

    lcd::~lcd(){}
}

#endif
```

**File lcd2.hpp**
```cpp
#ifndef _LCD2_HPP
#define _LCD2_HPP

namespace LCD{
    char *text;
}

#endif
```

**File main.cpp**
```cpp
#include <iostream>
#include "lcd1.hpp"
#include "lcd2.hpp"

using namespace std;

int main(int argc, char const *argv[])
{
    LCD::lcd;
    LCD::temp;
    LCD::text;
    return 0;
}

```

<br>

</p>
</details>

<details><summary><b>5. Standard Namespace (std) </b></summary>
<p>

- M·ªôt trong nh·ªØng namespace quan tr·ªçng v√† ph·ªï bi·∫øn nh·∫•t trong C++ l√† std. T·∫•t c·∫£ c√°c th√†nh ph·∫ßn c·ªßa th∆∞ vi·ªán chu·∫©n C++ (nh∆∞ cout, cin, vector, string) ƒë·ªÅu ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a b√™n trong namespace std.

üíª **V√≠ d·ª•:**
```cpp
#include <iostream>

using namespace std;

namespace std{
    struct{
        int x;
        int y;
    } point;

    void display(){
        cout << "x = " << point.x << endl;
        cout << "y = " << point.y << endl;
    }
}

int main(int argc, char const *argv[])
{
    std::cout << "Hello world!" << std::endl;

    cout << "Hello world!" << endl;
   
    std::point.x = 10;
    std::point.y = 20;
    std::display();

    return 0;
}
```

<br>

</p>
</details>

</p>
</details>

<br>

<details><summary><b>Standard Template Library (STL)</b></summary>
<p>

<details><summary><b>1. Gi·ªõi thi·ªáu STL</b></summary>
<p>

STL l√† m·ªôt th∆∞ vi·ªán trong ng√¥n ng·ªØ l·∫≠p tr√¨nh C++ cung c·∫•p m·ªôt t·∫≠p h·ª£p c√°c template classes v√† functions ƒë·ªÉ th·ª±c hi·ªán nhi·ªÅu lo·∫°i c·∫•u tr√∫c d·ªØ li·ªáu v√† c√°c thu·∫≠t to√°n ph·ªï bi·∫øn. STL ƒë√£ tr·ªü th√†nh m·ªôt ph·∫ßn quan tr·ªçng c·ªßa ng√¥n ng·ªØ C++ v√† l√†m cho vi·ªác l·∫≠p tr√¨nh tr·ªü n√™n m·∫°nh m·∫Ω, linh ho·∫°t v√† hi·ªáu qu·∫£.

M·ªôt s·ªë th√†nh ph·∫ßn ch√≠nh c·ªßa STL:

- Container
- Iterator
- Algorithms
- Functor

<br>

</p>
</details>

<details><summary><b>2. Vector</b></summary>
<p>

- L√† m·ªôt trong nh·ªØng container quan tr·ªçng nh·∫•t trong STL.
- B·∫£n ch·∫•t c·ªßa vector l√† m·ªôt class template. N√≥ cung c·∫•p m·ªôt m·∫£ng ƒë·ªông v·ªõi kh·∫£ nƒÉng thay ƒë·ªïi k√≠ch th∆∞·ªõc m·ªôt c√°ch linh ho·∫°t.
- C√≥ th·ªÉ truy c·∫≠p c√°c ph·∫ßn t·ª≠ c·ªßa m·∫£ng b·∫±ng c√°ch s·ª≠ d·ª•ng ch·ªâ s·ªë.
- C√≥ th·ªÉ ch√®n ho·∫∑c x√≥a b·∫•t k·ª≥ ph·∫ßn t·ª≠ n√†o trong m·∫£ng.
- M·ªôt s·ªë method c·ªßa vector:

+ **at()**: truy c·∫≠p ƒë·ªÉ ƒë·ªçc ho·∫∑c thay ƒë·ªïi gi√° tr·ªã ph·∫ßn t·ª≠ c·ªßa vector.
+ **size()**: tr·∫£ v·ªÅ k√≠ch th∆∞·ªõc c·ªßa vector.
+ **resize()**: thay ƒë·ªïi k√≠ch th∆∞·ªõc c·ªßa vector.
+ **begin()**: Tr·∫£ v·ªÅ m·ªôt iterator tr·ªè ƒë·∫øn ƒë·ªãa ch·ªâ ph·∫ßn t·ª≠ ƒë·∫ßu ti√™n c·ªßa vector.
+ **end()**: Tr·∫£ v·ªÅ m·ªôt iterator tr·ªè ƒë·∫øn ƒë·ªãa ch·ªâ sau ph·∫ßn t·ª≠ cu·ªëi c√πng c·ªßa vector.
+ **push_back()**: th√™m ph·∫ßn t·ª≠ v√†o v·ªã tr√≠ cu·ªëi c·ªßa vector.
+ **pop_back()**: x√≥a ph·∫ßn t·ª≠ ·ªü v·ªã tr√≠ cu·ªëi c·ªßa vector.
+ **insert()**: th√™m ph·∫ßn t·ª≠ v√†o v·ªã tr√≠ b·∫•t k·ª≥.
+ **erase()**: xo√° ph·∫ßn t·ª≠ ·ªü v√≠ tr√≠ b·∫•t k·ª≥ ho·∫∑c x√≥a c√°c ph·∫ßn t·ª≠ trong ph·∫°m vi ƒë∆∞·ª£c ch·ªâ ƒë·ªãnh.
+ **clear()**: x√≥a to√†n b·ªô ph·∫ßn t·ª≠ c·ªßa vector (thu h·ªìi t·∫•t c·∫£ ƒë·ªãa ch·ªâ).

<br>

üíª **V√≠ d·ª•:**
```cpp
#include <iostream>
#include <vector>

using namespace std;

int main() {
    // Kh·ªüi t·∫°o vector b·∫±ng danh s√°ch kh·ªüi t·∫°o {}
    vector<int> vec = {1, 2, 3, 4, 5};

    // Th√™m ph·∫ßn t·ª≠ v√†o cu·ªëi vector b·∫±ng push_back
    vec.push_back(6);
    vec.push_back(7);

    // Thay ƒë·ªïi k√≠ch th∆∞·ªõc c·ªßa vector v·ªõi resize
    vec.resize(10); // TƒÉng k√≠ch th∆∞·ªõc vector l√™n 10 ph·∫ßn t·ª≠, c√°c ph·∫ßn t·ª≠ m·ªõi ƒë∆∞·ª£c kh·ªüi t·∫°o v·ªõi 0
    vec.at(8) = 50; // ghi gi√° tr·ªã m·ªõi
    vec.at(9) = 25;

    // In vector sau khi resize b·∫±ng v√≤ng l·∫∑p for c·∫£i ti·∫øn v√† ph∆∞∆°ng th·ª©c at()
    cout << "Vector sau khi resize: ";
    for (auto item : vec) {
        cout << item << " ";
    }
    cout << endl;

    // Th√™m ph·∫ßn t·ª≠ v√†o v·ªã tr√≠ th·ª© 3 (sau ph·∫ßn t·ª≠ th·ª© 2) b·∫±ng insert
    vec.insert(vec.begin() + 2, 99);

    // Th√™m m·ªôt ph·∫ßn t·ª≠ kh√°c v√†o v·ªã tr√≠ th·ª© 5
    vec.insert(vec.begin() + 4, 88);

    // X√≥a ph·∫ßn t·ª≠ th·ª© 4 (sau ph·∫ßn t·ª≠ ƒë·∫ßu ti√™n th√™m v√†o) b·∫±ng erase
    vec.erase(vec.begin() + 3);

    // X√≥a th√™m m·ªôt ph·∫ßn t·ª≠ kh√°c t·∫°i v·ªã tr√≠ th·ª© 6
    vec.erase(vec.begin() + 5);

    // S·ª≠ d·ª•ng pop_back() ƒë·ªÉ x√≥a ph·∫ßn t·ª≠ cu·ªëi c√πng
    vec.pop_back();

    // In vector sau khi s·ª≠ d·ª•ng insert, erase, v√† pop_back, s·ª≠ d·ª•ng iterator
    cout << "Vector sau khi th√™m, x√≥a v√† pop_back: ";
    for (vector<int>::iterator it = vec.begin(); it != vec.end(); ++it) {
        cout << *it << " ";
    }
    cout << endl;

    return 0;
}
```

<br>

</p>
</details>

<details><summary><b>3. List</b></summary>
<p>

- Tri·ªÉn khai d∆∞·ªõi d·∫°ng danh s√°ch li√™n k·∫øt hai chi·ªÅu (linked list), nghƒ©a l√† g·ªìm nh·ªØng nodes c√≥ ƒë·ªãa ch·ªâ ng·∫´u nhi√™n li√™n k·∫øt v·ªõi nhau.
- Ch·ªâ c·ªè th·ªÉ truy c·∫≠p c√°c ph·∫ßn t·ª≠ m·ªôt c√°ch tu·∫ßn t·ª± (kh√¥ng h·ªó tr·ª£ truy c·∫≠p ng·∫´u nhi√™n).
- C√≥ th·ªÉ ch√®n/x√≥a ·ªü b·∫•t k·ª≥ v·ªã tr√≠ n√†o trong danh s√°ch.
- M·ªôt s·ªë method c·ªßa list:

+ **size()**: tr·∫£ v·ªÅ k√≠ch th∆∞·ªõc c·ªßa list hay s·ªë l∆∞·ª£ng node trong list.
+ **begin()**: Tr·∫£ v·ªÅ iterator tr·ªè ƒë·∫øn ƒë·ªãa ch·ªâ node ƒë·∫ßu ti√™n c·ªßa list.
+ **end()**: Tr·∫£ v·ªÅ iterator tr·ªè ƒë·∫øn ƒë·ªãa ch·ªâ node cu·ªëi c√πng c·ªßa list.
+ **push_back()**: th√™m node v√†o v·ªã tr√≠ cu·ªëi c·ªßa list.
+ **push_front()**: th√™m node v√†o v·ªã tr√≠ ƒë·∫ßu c·ªßa list.
+ **pop_back()**: x√≥a node ·ªü v·ªã tr√≠ cu·ªëi c·ªßa list.
+ **pop_front()**: x√≥a node ·ªü v·ªã tr√≠ ƒë·∫ßu c·ªßa list.
+ **insert()**: th√™m node ·ªü v·ªã tr√≠ b·∫•t k·ª≥
+ **erase()**: xo√° node ·ªü v√≠ tr√≠ b·∫•t k·ª≥ ho·∫∑c x√≥a c√°c node trong ph·∫°m vi ƒë∆∞·ª£c ch·ªâ ƒë·ªãnh.
+ **remove()**: X√≥a c√°c node v·ªõi gi√° tr·ªã ƒë∆∞·ª£c ch·ªâ ƒë·ªãnh.

<br>

üíª **V√≠ d·ª•:**
```cpp
#include <iostream>
#include <list>

using namespace std;

int main() {
    // Kh·ªüi t·∫°o list b·∫±ng danh s√°ch kh·ªüi t·∫°o {}
    list<int> lst = {1, 2, 3, 4, 5};

    // Th√™m ph·∫ßn t·ª≠ v√†o cu·ªëi list b·∫±ng push_back
    lst.push_back(6);
    lst.push_back(7);

    // Th√™m ph·∫ßn t·ª≠ v√†o ƒë·∫ßu list b·∫±ng push_front
    lst.push_front(0);
    lst.push_front(-1);

    // Thay ƒë·ªïi k√≠ch th∆∞·ªõc c·ªßa list b·∫±ng resize
    lst.resize(12, 0); // TƒÉng k√≠ch th∆∞·ªõc list l√™n 12 ph·∫ßn t·ª≠, c√°c ph·∫ßn t·ª≠ m·ªõi ƒë∆∞·ª£c kh·ªüi t·∫°o v·ªõi 0

    list<int>::iterator it;

    // In list sau khi resize b·∫±ng v√≤ng l·∫∑p for c·∫£i ti·∫øn
    cout << "List sau khi push_front v√† resize: ";
    for (auto it = lst.begin(); it != lst.end(); ++it) {
        cout << *it << " ";
    }
    cout << endl;

    // Th√™m ph·∫ßn t·ª≠ v√†o v·ªã tr√≠ th·ª© 3 (sau ph·∫ßn t·ª≠ th·ª© 2) b·∫±ng insert
    it = lst.begin();
    for (int i = 0; i < 2; ++i) {
        ++it;
    }
    lst.insert(it, 99);

    // Th√™m m·ªôt ph·∫ßn t·ª≠ kh√°c v√†o v·ªã tr√≠ th·ª© 5
    it = lst.begin();
    for (int i = 0; i < 4; ++i) {
        ++it;
    }
    lst.insert(it, 88);

    // X√≥a ph·∫ßn t·ª≠ th·ª© 4 (sau ph·∫ßn t·ª≠ ƒë·∫ßu ti√™n th√™m v√†o) b·∫±ng erase
    it = lst.begin();
    for (int i = 0; i < 3; ++i) {
        ++it;
    }
    lst.erase(it);

    // X√≥a th√™m m·ªôt ph·∫ßn t·ª≠ kh√°c t·∫°i v·ªã tr√≠ th·ª© 6
    it = lst.begin();
    for (int i = 0; i < 5; ++i) {
        ++it;
    }
    lst.erase(it);

    // S·ª≠ d·ª•ng pop_back() ƒë·ªÉ x√≥a ph·∫ßn t·ª≠ cu·ªëi c√πng
    lst.pop_back();

    // S·ª≠ d·ª•ng pop_front() ƒë·ªÉ x√≥a ph·∫ßn t·ª≠ ƒë·∫ßu ti√™n
    lst.pop_front();

    // Ki·ªÉm tra list c√≥ r·ªóng kh√¥ng b·∫±ng empty()
    if (lst.empty()) {
        cout << "List hi·ªán t·∫°i r·ªóng." << endl;
    } else {
        cout << "List sau khi th√™m, x√≥a, pop_back v√† pop_front: ";
        for (auto it = lst.begin(); it != lst.end(); ++it) {
            cout << *it << " ";
        }
        cout << endl;
    }

    return 0;
}
```

<br>

</p>
</details>

<details><summary><b>4. Map</b></summary>
<p>

- Cung c·∫•p m·ªôt c·∫•u tr√∫c d·ªØ li·ªáu √°nh x·∫° key ‚Äì value, trong ƒë√≥ value gi·ªØa c√°c object c√≥ th·ªÉ gi·ªëng nhau nh∆∞ng key l√† duy nh·∫•t trong map, n·∫øu c√≥ 2 value c√πng key th√¨ l·∫•y key v√† value sau c√πng.
- C√≥ th·ªÉ th√™m ph·∫ßn t·ª≠ m·ªõi v√†o map b·∫±ng c√°ch s·ª≠ d·ª•ng operator [] ho·∫∑c h√†m insert(). ƒê·ªÉ x√≥a ph·∫ßn t·ª≠, b·∫°n c√≥ th·ªÉ s·ª≠ d·ª•ng h√†m erase().
- C√≥ th·ªÉ s·ª≠ d·ª•ng iterator ƒë·ªÉ duy·ªát qua c√°c ph·∫ßn t·ª≠ c·ªßa map.

<br>

üíª **V√≠ d·ª• 1:**
```cpp
#include <iostream>
#include <map>

using namespace std;

int main(int argc, char const *argv[]){    
    map<int, string> array; // key: int, value: string

    array[1] = "Hoang";
    array[2] = "Tuan";
    array[3] = "Anh";

    for (auto item : array){
        cout << "key: " << item.first << " - value: " << item.second << endl; 
    }

    return 0;
}
```

<br>

üíª **V√≠ d·ª• 2:**
```cpp
#include <iostream>
#include <map>
#include <string>

using namespace std;

int main(int argc, char const *argv[]){
    map<string, int> myMap;

    // Th√™m ph·∫ßn t·ª≠ v√†o map
    myMap["one"] = 1;
    myMap["two"] = 2;
    myMap["three"] = 3;

    for (auto item : myMap){
        cout << "Key: " << item.first << " , " << "Value: " << item.second << endl;
    }

    cout << "---------------" << endl;

    map<string, int> ::iterator it; // it = myMap.begin()

    // myMap.insert(make_pair("four", 4));
    myMap.insert({"four", 4});
    myMap.erase("one");

    for (it = myMap.begin(); it != myMap.end(); it++){
        cout << "Key: " << (*it).first << " , " << "Value: " << (*it).second << endl;
    }

    return 0;
}
```

<br>

üíª **V√≠ d·ª• 3:**
```cpp
#include <iostream>
#include <map>
#include <string>

using namespace std;

typedef struct{
    string ten;
    int    tuoi;
    string lop;
} SinhVien;

int main(int argc, char const *argv[]){
    map<string, SinhVien> Database = {
        {
            "SV100", {
                "Hoang",
                20,
                "DDT"
            }
        },
        {
            "SV101", {
                "Tuan",
                21,
                "CDT"
            }
        },
        {
            "SV102", {
                "Anh",
                22,
                "KTMT"
            }
        }
    };

    for (auto item : Database){
        cout << "ID: " << item.first << " - Ten: " << item.second.ten << " - Tuoi: " << item.second.tuoi << " - Lop: " << item.second.lop << endl;
    }
    return 0;
}
```

<br>

</p>
</details>

<details><summary><b>5. Iterator</b></summary>
<p>

- Iterator l√† m·ªôt ƒë·ªëi t∆∞·ª£ng ƒë·∫°i di·ªán cho v·ªã tr√≠ trong container v√† cho ph√©p duy·ªát qua c√°c ph·∫ßn t·ª≠ c·ªßa container (nh∆∞ std::vector, std::list, std::map, v.v.). Ch√∫ng c√≥ th·ªÉ ƒë∆∞·ª£c xem l√† m·ªôt c√¥ng c·ª• ƒë·ªÉ truy c·∫≠p tu·∫ßn t·ª± c√°c ph·∫ßn t·ª≠ m√† kh√¥ng c·∫ßn bi·∫øt c·∫•u tr√∫c n·ªôi b·ªô c·ªßa container. Iterator s·∫Ω l∆∞u ƒë·ªãa ch·ªâ ƒë·∫ßu ti√™n c·ªßa list v√† cho ph√©p duy·ªát qua t·ª´ng ph·∫ßn t·ª≠.
- Iterator l√† m·ªôt class, b√™n trong qu·∫£n l√Ω m·ªôt con tr·ªè. Con tr·ªè n√†y l√† th√†nh ph·∫ßn gi√∫p iterator bi·∫øt ƒë∆∞·ª£c n√≥ ƒëang tr·ªè t·ªõi ph·∫ßn t·ª≠ n√†o trong container. Con tr·ªè n√†y l∆∞u tr·ªØ ƒë·ªãa ch·ªâ c·ªßa ph·∫ßn t·ª≠ ƒë·∫ßu ti√™n trong vector hay node ƒë·∫ßu ti√™n trong list, v√† t·ª≠ ƒë√≥ duy·ªát qua t·ª´ng ph·∫ßn t·ª≠.
- Khi b·∫°n mu·ªën in ra ƒë·ªãa ch·ªâ m√† m·ªôt iterator ƒëang tr·ªè t·ªõi, b·∫°n c·∫ßn s·ª≠ d·ª•ng &(*it).

+ *it: (*) l√† to√°n t·ª≠ truy c·∫≠p gi√° tr·ªã ƒë√£ ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a l·∫°i (overload) b√™n trong iterator.
+ &(*it): l·∫•y ƒë·ªãa ch·ªâ c·ªßa gi√° tr·ªã m√† iterator it tr·ªè t·ªõi.

- C√°c th∆∞ vi·ªán nh∆∞ std::vector, std::list, v√† nhi·ªÅu container kh√°c trong C++ Standard Library ƒë·ªÅu ƒë·ªãnh nghƒ©a m·ªôt class iterator ri√™ng b√™n trong ch√∫ng. ƒêi·ªÅu n√†y gi√∫p m·ªói container c√≥ m·ªôt lo·∫°i iterator ph√π h·ª£p v·ªõi c√°ch t·ªï ch·ª©c d·ªØ li·ªáu v√† c√°ch duy·ªát qua c√°c ph·∫ßn t·ª≠ c·ªßa n√≥.

<br>

</p>
</details>

<details><summary><b>6. Building and Designing Library</b></summary>
<p>

<details><summary><b>üìö vector</b></summary>
<p>

</p>
</details>

<details><summary><b>üìö list</b></summary>
<p>

</p>
</details>

</p>
</details>

</p>
</details>

<br>

<details><summary><b>Lambda expression</b></summary>
<p>

Lambda l√† m·ªôt t√≠nh nƒÉng m·∫°nh m·∫Ω ƒë∆∞·ª£c th√™m v√†o ng√¥n ng·ªØ l·∫≠p tr√¨nh C++ t·ª´ phi√™n b·∫£n C++11.

Lambda c√≥ nh·ªØng ƒë·∫∑c ƒëi·ªÉm sau:

- L√† 1 h√†m kh√¥ng t√™n.
- S·ª≠ d·ª•ng 1 l·∫ßn duy nh·∫•t trong ch∆∞∆°ng tr√¨nh.
- ƒê∆∞·ª£c ƒë·ªãnh nghƒ©a t·∫°i ch·ªó.
- C√≥ th·ªÉ s·ª≠ d·ª•ng tr·ª±c ti·∫øp ho·∫∑c g√°n cho bi·∫øn

C√∫ ph√°p:
```cpp
[capture](parameters) -> return_type
{
	// function body
}

[capture](parameters)
{
	// function body
}
```

- **capture**: cho bi·∫øt c√°ch c√°c bi·∫øn ·ªü ph·∫°m vi b√™n ngo√†i ƒë∆∞·ª£c s·ª≠ d·ª•ng trong lambda

	+ []: kh√¥ng s·ª≠ d·ª•ng b·∫•t k·ª≥ bi·∫øn n√†o t·ª´ m√¥i tr∆∞·ªùng xung quanh

	+ [x]: ch·ªâ ƒë·ªãnh bi·∫øn c·ª• th·ªÉ (x), theo gi√° tr·ªã, read-only.

	+ [&x]: ch·ªâ ƒë·ªãnh bi·∫øn c·ª• th·ªÉ (x), theo tham chi·∫øu, read, write.

	+ [=]: s·ª≠ d·ª•ng t·∫•t c·∫£ bi·∫øn xung quanh, theo gi√° tr·ªã.

	+ [&]: s·ª≠ d·ª•ng t·∫•t c·∫£ bi·∫øn xung quanh, theo tham chi·∫øu.

	+ [=, &x]: s·ª≠ d·ª•ng t·∫•t c·∫£ bi·∫øn xung quanh theo gi√° tr·ªã, tr·ª´ bi·∫øn 'x' theo tham chi·∫øu.

	+ [&, x]: s·ª≠ d·ª•ng t·∫•t c·∫£ bi·∫øn xung quanh theo tham chi·∫øu, tr·ª´ 'x' theo gi√° tr·ªã.

- **parameters**: danh s√°ch c√°c tham s·ªë truy·ªÅn v√†o c·ªßa lambda (gi·ªëng function).

- **return_type**:

	+ ki·ªÉu tr·∫£ v·ªÅ c·ªßa lambda.
 	+ N·∫øu kh√¥ng ch·ªâ ƒë·ªãnh, ki·ªÉu tr·∫£ v·ªÅ s·∫Ω ƒë∆∞·ª£c suy di·ªÖn.

**function body**: ƒê·∫∑t trong d·∫•u ngo·∫∑c nh·ªçn {} v√† ch·ª©a m√£ ngu·ªìn th·ª±c thi c·ªßa lambda.

<br>

üíª **V√≠ d·ª• 1:**
```cpp
#include <iostream>

using namespace std;

int main(int argc, char const *argv[])
{
    // ƒë·ªãnh nghƒ©a lambda v√† g√°n cho bi·∫øn
    auto greet = []()
    {
        cout << "Hello, lambda!\n";
    };
    greet();


    auto sum = [](auto... args)
    {
        int sum = 0;
        int arr[] = {args...};
        for (size_t i=0; i<(sizeof(arr)/sizeof(arr[0])); i++)
        {
            sum += arr[i];
        }
        return sum;
    };
    cout << "Sum: " << sum(3,9) << endl;


    // ƒë·ªãnh nghƒ©a lambda v√† s·ª≠ d·ª•ng tr·ª±c ti·∫øp
    cout << [](int a, int b, int c)
    {   
        return a + b + c;
    }(2,3,4) << endl;


    // s·ª≠ d·ª•ng bi·∫øn xung quanh lambda
    int x = 1, y = 2, z = 3;

    // s·ª≠ d·ª•ng gi√° tr·ªã
    auto lambda = [x,y]()
    {
        // x = 5;   // wrong
        // y = 10;  // wrong
        cout << "Captured x: " << x << endl;
        cout << "Captured y: " << y << endl;
    };
    lambda();


    // s·ª≠ d·ª•ng tham chi·∫øu
    auto lambda1 = [&x, &y]()
    {
        x += 5;     // 0x01: 1  ->   0x01: 6
        y = 50;
        cout << "Modified x: " << x << endl;
        cout << "Modified y: " << y << endl;
    };
    lambda1();


    // s·ª≠ d·ª•ng t·∫•t c·∫£ c√°c bi·∫øn xung quanh, gi√° tr·ªã
    auto lambda2 = [=]()
    {
        cout << "Captured x: " << x << " , y: " << y << " , z: " << z << endl;
    };
    lambda2();


    // s·ª≠ d·ª•ng t·∫•t c·∫£ c√°c bi·∫øn xung quanh, tham chi·∫øu
    auto lambda3 = [&]()
    {   
        x = 10;
        y = 20;
        z = 30;
        cout << "Modified x: " << x << " , y: " << y << " , z: " << z << endl;
    };
    lambda3();

    return 0;
}
```

<br>

üíª **V√≠ d·ª• 2:**
```cpp
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

int main(int argc, char const *argv[])
{
    vector<int> vec {1, 2, 3, 4, 5, 6};

    int count_even = 0;
    int count_odd  = 0;
    vector<int> evens, odds;

    count_if(vec.begin(), vec.end(), [&](int x)
    {
        if (x % 2 == 0){
            count_even++;
            evens.push_back(x);
        } else {
            count_odd++;
            odds.push_back(x);
        }
        return false;
    });

    cout << "Number of even numbers: " << count_even << endl;
    cout << "Even numbers: ";
    for (auto item : evens)
    {
        cout << item << " ";
    }
    cout << endl;

    
    cout << "Number of odd numbers: " << count_odd << endl;
    cout << "Odd numbers: ";
    for (auto item : odds)
    {
        cout << item << " ";
    }
    cout << endl;

    return 0;
}
```

<br>

üíª **V√≠ d·ª• 3:**
```cpp
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

int main(int argc, char const *argv[])
{
    vector<int> arr = {32, 71, 12, 40, 2, 80, 53, 35};

    vector<int>::iterator it;

    cout << "Initial: ";
    for (it = arr.begin(); it != arr.end(); it++){
        cout << " " << *it;
    }
    cout << endl;


    // s·∫Øp x·∫øp tƒÉng d·∫ßn
    sort(arr.begin(), arr.end(), [](int i, int j) -> bool{
        return i < j;
    });

    cout << "Increase: ";
    for (it = arr.begin(); it != arr.end(); it++){
        cout << " " << *it;
    }
    cout << endl;


    // s·∫Øp x·∫øp gi·∫£m d·∫ßn
    sort(arr.begin(), arr.end(), [](int i, int j) -> bool{
        return i > j;
    });

    cout << "Decrease: ";
    for (it = arr.begin(); it != arr.end(); it++){
        cout << " " << *it;
    }
    
    return 0;
}
```

<br>

</p>
</details>

<br>

<details><summary><b>Smart Pointer</b></summary>
<p>

<details><summary><b>1. Gi·ªõi thi·ªáu v·ªÅ RAII</b></summary>
<p>

<details><summary><b>üìö Kh√°i ni·ªám</b></summary>
<p>

- **RAII (Resource Acquisition Is Initialization)** l√† m·ªôt k·ªπ thu·∫≠t qu·∫£n l√Ω t√†i nguy√™n trong l·∫≠p tr√¨nh C++, trong ƒë√≥ t√†i nguy√™n (b·ªô nh·ªõ, file, mutex, socket,...) ƒë∆∞·ª£c **c·∫•p ph√°t khi m·ªôt ƒë·ªëi t∆∞·ª£ng ƒë∆∞·ª£c kh·ªüi t·∫°o** v√† ƒë∆∞·ª£c **gi·∫£i ph√≥ng khi ƒë·ªëi t∆∞·ª£ng ƒë√≥ b·ªã h·ªßy**. ƒêi·ªÅu n√†y gi√∫p tr√°nh r√≤ r·ªâ t√†i nguy√™n v√† ƒë·∫£m b·∫£o vi·ªác gi·∫£i ph√≥ng t√†i nguy√™n di·ªÖn ra m·ªôt c√°ch t·ª± ƒë·ªông, ngay c·∫£ khi c√≥ ngo·∫°i l·ªá x·∫£y ra.

<br>

</p>
</details>

<details><summary><b>üìö Nguy√™n t·∫Øc ho·∫°t ƒë·ªông</b></summary>
<p>

- **C·∫•p ph√°t t√†i nguy√™n trong Constructor**: Khi m·ªôt ƒë·ªëi t∆∞·ª£ng ƒë∆∞·ª£c t·∫°o, n√≥ s·∫Ω l·∫•y t√†i nguy√™n c·∫ßn thi·∫øt (v√≠ d·ª•: c·∫•p ph√°t b·ªô nh·ªõ ƒë·ªông, m·ªü file, lock mutex,...).
- **Gi·∫£i ph√≥ng t√†i nguy√™n trong destructor**: Khi ƒë·ªëi t∆∞·ª£ng ƒëi ra kh·ªèi ph·∫°m vi (scope), destructor c·ªßa n√≥ ƒë∆∞·ª£c g·ªçi v√† t√†i nguy√™n s·∫Ω ƒë∆∞·ª£c gi·∫£i ph√≥ng m·ªôt c√°ch an to√†n.

</p>
</details>

<details><summary><b>üìö V√≠ d·ª• minh h·ªça</b></summary>
<p>

üîπ**Qu·∫£n l√Ω b·ªô nh·ªõ v·ªõi RAII**

- Tr∆∞·ªõc khi c√≥ RAII, n·∫øu d√πng new v√† delete th·ªß c√¥ng, d·ªÖ b·ªã memory leak:

```cpp
void badExample()
{
    int* ptr = new int(10);
    // N·∫øu c√≥ ngo·∫°i l·ªá x·∫£y ra tr∆∞·ªõc khi delete, s·∫Ω b·ªã memory leak.
    delete ptr;
}
```

<br>

- D√πng RAII v·ªõi ``` std::unique_ptr ``` ƒë·ªÉ t·ª± ƒë·ªông gi·∫£i ph√≥ng b·ªô nh·ªõ:

```cpp
#include <memory>

void goodExample()
{
    std::unique_ptr<int> ptr = std::make_unique<int>(10);
    // Kh√¥ng c·∫ßn delete, b·ªô nh·ªõ s·∫Ω ƒë∆∞·ª£c gi·∫£i ph√≥ng t·ª± ƒë·ªông khi ptr ra kh·ªèi scope.
}
```

<br>
<br>

üîπ**Qu·∫£n l√Ω file v·ªõi RAII**

- Khi m·ªü file b·∫±ng ``` FILE* ```, c·∫ßn g·ªçi ``` fclose() ``` th·ªß c√¥ng:

```cpp
#include <cstdio>

void bad_FileHandling()
{
    FILE* file = fopen("example.txt", "w");
    if (!file) return;
    // N·∫øu return s·ªõm m√† qu√™n fclose, s·∫Ω b·ªã r√≤ r·ªâ file descriptor.
    fclose(file);
}
```

<br>

- D√πng RAII v·ªõi ``` std::ofstream ```:

```cpp
#include <fstream>

void goodFileHandling()
{
    std::ofstream file("example.txt");
    if (!file) return;
    // Kh√¥ng c·∫ßn g·ªçi close(), file s·∫Ω ƒë∆∞·ª£c ƒë√≥ng t·ª± ƒë·ªông khi ra kh·ªèi scope.
}
```

<br>

</p>
</details>

</p>
</details>

<details><summary><b>2. Gi·ªõi thi·ªáu v·ªÅ Smart Pointer</b></summary>
<p>

- **Smart Pointer** kh√°c ho√†n con tr·ªè th√¥ (**raw pointer**) th√¥ng th∆∞·ªùng, n√≥ l√† m·ªôt **class** gi√∫p qu·∫£n l√Ω b·ªô nh·ªõ t·ª± ƒë·ªông. N√≥ ƒë·∫£m b·∫£o r·∫±ng b·ªô nh·ªõ ƒë∆∞·ª£c c·∫•p ph√°t ƒë·ªông s·∫Ω ƒë∆∞·ª£c gi·∫£i ph√≥ng m·ªôt c√°ch an to√†n, gi√∫p tr√°nh **memory leak** v√† **dangling pointer**.
- Smart pointer t·ª± ƒë·ªông qu·∫£n l√Ω t√†i nguy√™n b·∫±ng c√°ch s·ª≠ d·ª•ng **RAII (Resource Acquisition Is Initialization)**, t·ª©c l√† t√†i nguy√™n s·∫Ω ƒë∆∞·ª£c gi·∫£i ph√≥ng khi ƒë·ªëi t∆∞·ª£ng ƒëi ra kh·ªèi ph·∫°m vi (scope).
- C√≥ 3 lo·∫°i smart pointer ch√≠nh trong C++ ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a trong th∆∞ vi·ªán ``` memory ```:

    + ``` std::unique_ptr ```
    + ``` std::shared_ptr ```
    + ``` std::weak_ptr ```

<br>

</p>
</details>

<details><summary><b>3. Unique Pointer</b></summary>
<p>

- **Unique Pointer** (``` unique_ptr ```) l√† m·ªôt smart pointer qu·∫£n l√Ω b·ªô nh·ªõ t·ª± ƒë·ªông trong C++.
- ``` unique_ptr ``` ƒë·∫£m b·∫£o r·∫±ng ch·ªâ c√≥ duy nh·∫•t m·ªôt con tr·ªè s·ªü h·ªØu ƒë·ªëi t∆∞·ª£ng t·∫°i m·ªôt th·ªùi ƒëi·ªÉm (quy·ªÅn s·ªü h·ªØu ƒë·ªôc quy·ªÅn).
- Khi ``` unique_ptr ``` b·ªã h·ªßy ho·∫∑c ƒë∆∞·ª£c g√°n cho m·ªôt con tr·ªè kh√°c, ƒë·ªëi t∆∞·ª£ng m√† n√≥ s·ªü h·ªØu s·∫Ω t·ª± ƒë·ªông ƒë∆∞·ª£c gi·∫£i ph√≥ng.

üíª
```cpp
#include <iostream>
#include <memory>  // C·∫ßn thi·∫øt ƒë·ªÉ s·ª≠ d·ª•ng smart pointer

using namespace std;

int main() 
{
    unique_ptr<int> ptr = make_unique<int>(10);
    
    cout << "Value: " << *ptr << endl;

    return 0;
}
```

üìù ``` make_unique<int>(10) ```: t·∫°o ra m·ªôt ƒë·ªëi t∆∞·ª£ng ki·ªÉu int v·ªõi gi√° tr·ªã kh·ªüi t·∫°o l√† 10 v√† ƒë·ªãa ch·ªâ ƒë∆∞·ª£c c·∫•p ph√°t n·∫±m tr√™n v√πng nh·ªõ heap, sau ƒë√≥ tr·∫£ v·ªÅ m·ªôt con tr·ªè th√¥ng minh ``` unique_ptr ``` tr·ªè t·ªõi ƒë·ªëi t∆∞·ª£ng ƒë√≥.

üìù ``` unique_ptr<int> ```: ch·ªâ ra r·∫±ng unique pointer n√†y s·∫Ω qu·∫£n l√Ω m·ªôt ƒë·ªëi t∆∞·ª£ng ki·ªÉu **int**.

üìù ``` ptr ```: t√™n c·ªßa object thu·ªôc class unique_ptr, n√≥ ƒë∆∞·ª£c t·∫°o ra v√† s·ªü h·ªØu v√πng nh·ªõ v·ª´a ƒë∆∞·ª£c c·∫•p ph√°t. T·ª´ th·ªùi ƒëi·ªÉm n√†y, ptr c√≥ tr√°ch nhi·ªám qu·∫£n l√Ω v√πng nh·ªõ c·ªßa ƒë·ªëi t∆∞·ª£ng ki·ªÉu int.

<br>

Nh·ªØng ph∆∞∆°ng th·ª©c ch√≠nh m√† ``` std::unique_ptr ``` h·ªó tr·ª£:

<b>1. operator*() v√† operator->()**</b>

- ``` operator*() ```: dereference con tr·ªè ƒë·ªÉ truy c·∫≠p gi√° tr·ªã c·ªßa ƒë·ªëi t∆∞·ª£ng m√† **unique_ptr** ƒëang qu·∫£n l√Ω.
- ``` operator->() ```: truy c·∫≠p th√†nh vi√™n c·ªßa ƒë·ªëi t∆∞·ª£ng m√† **unique_ptr** tr·ªè t·ªõi.


üíª
```cpp
#include <iostream>
#include <memory>  // C·∫ßn thi·∫øt ƒë·ªÉ s·ª≠ d·ª•ng smart pointer

using namespace std;

class Example{
    private:
        int data;

    public:
        Example(int value): data(value){
            cout << "Constructor called, data = " << data << endl;
        }

        ~Example(){
            cout << "Destructor called, data = " << data << endl;
        }

        void display(){
            cout << "Value: " << data << endl;
        }
};

int main() 
{
    unique_ptr<Example> ptr = make_unique<Example>(10);
    ptr->display();

    *ptr = 20;
    (*ptr).display();
    return 0;
}
```

<br>

<b>2. get()</b>

- Tr·∫£ v·ªÅ con tr·ªè th√¥ (raw pointer) ƒë·∫øn ƒë·ªëi t∆∞·ª£ng m√† **unique_ptr** ƒëang qu·∫£n l√Ω.
-  Con tr·ªè th√¥ tr·∫£ v·ªÅ b·ªüi **get()** kh√¥ng chuy·ªÉn quy·ªÅn s·ªü h·ªØu, t·ª©c l√† ƒë·ªëi t∆∞·ª£ng v·∫´n ƒë∆∞·ª£c qu·∫£n l√Ω b·ªüi **unique_ptr**.

üíª
```cpp
#include <iostream>
#include <memory>  // C·∫ßn thi·∫øt ƒë·ªÉ s·ª≠ d·ª•ng smart pointer

using namespace std;

class Example{
    private:
        int data;

    public:
        Example(int value): data(value){
            cout << "Constructor called, data = " << data << endl;
        }

        ~Example(){
            cout << "Destructor called, data = " << data << endl;
        }

        void display(){
            cout << "Value: " << data << endl;
        }
};

int main() 
{
    unique_ptr<Example> ptr;
    ptr = make_unique<Example>(30);

    Example *rawPtr2 = ptr.get();   
    rawPtr2->display();
    return 0;
}
```

<br>

<b>3. release()</b>

- Gi·∫£i ph√≥ng quy·ªÅn s·ªü h·ªØu ƒë·ªëi v·ªõi ƒë·ªëi t∆∞·ª£ng m√† unique_ptr ƒëang qu·∫£n l√Ω (``` unique_ptr ``` gi·ªù ƒë√¢y tr·ªü th√†nh ``` con tr·ªè null ```(nullptr)) v√† tr·∫£ v·ªÅ con tr·ªè th√¥ (raw pointer) ƒë·∫øn ƒë·ªëi t∆∞·ª£ng ƒë√≥.
- Sau khi g·ªçi ``` release() ```, unique_ptr kh√¥ng c√≤n qu·∫£n l√Ω ƒë·ªëi t∆∞·ª£ng n·ªØa, v√† tr√°ch nhi·ªám gi·∫£i ph√≥ng b·ªô nh·ªõ thu·ªôc v·ªÅ ng∆∞·ªùi g·ªçi (gi·∫£i ph√≥ng th·ªß c√¥ng v·ªõi ``` delete ```).

üíª
```cpp
#include <iostream>
#include <memory>  // C·∫ßn thi·∫øt ƒë·ªÉ s·ª≠ d·ª•ng smart pointer

using namespace std;

class Example{
    private:
        int data;

    public:
        Example(int value): data(value){
            cout << "Constructor called, data = " << data << endl;
        }

        ~Example(){
            cout << "Destructor called, data = " << data << endl;
        }

        void display(){
            cout << "Value: " << data << endl;
        }
};

int main() 
{
    unique_ptr<Example> ptr = make_unique<Example>(30);

    Example *rawPtr = ptr.release();
    if (!ptr){
        cout << "ptr ƒë√£ b·ªã t√°ch quy·ªÅn s·ªü h·ªØu v√† tr·ªü th√†nh nullptr\n";
    }
    rawPtr->display();  
    delete rawPtr;      
    return 0;
}
```

<br>

<b>4. reset()</b>

- Gi·∫£i ph√≥ng ƒë·ªëi t∆∞·ª£ng m√† unique_ptr ƒëang qu·∫£n l√Ω (n·∫øu c√≥) v√† c√≥ th·ªÉ qu·∫£n l√Ω m·ªôt ƒë·ªëi t∆∞·ª£ng m·ªõi (n·∫øu ƒë∆∞·ª£c cung c·∫•p).
- N·∫øu kh√¥ng cung c·∫•p ƒë·ªëi t∆∞·ª£ng m·ªõi, reset() s·∫Ω khi·∫øn unique_ptr tr·ªü th√†nh nullptr.

üíª
```cpp
#include <iostream>
#include <memory>  // C·∫ßn thi·∫øt ƒë·ªÉ s·ª≠ d·ª•ng smart pointer

using namespace std;

class Example{
    private:
        int data;

    public:
        Example(int value): data(value){
            cout << "Constructor called, data = " << data << endl;
        }

        ~Example(){
            cout << "Destructor called, data = " << data << endl;
        }

        void display(){
            cout << "Value: " << data << endl;
        }
};

int main() 
{
    unique_ptr<Example> ptr = make_unique<Example>(30);

    ptr.reset(new Example(20)); // ptr qu·∫£n l√Ω ƒë·ªëi t∆∞·ª£ng m·ªõi
    ptr->display();

    ptr.reset();
    if (!ptr){
           cout << "ptr tr·ªü th√†nh nullptr\n";
    }
    return 0;
}
```

<br>

<b>5. swap()</b>

Ho√°n ƒë·ªïi (swap) n·ªôi dung c·ªßa hai unique_ptr v·ªõi nhau, t·ª©c l√† ƒë·ªïi ƒë·ªëi t∆∞·ª£ng m√† hai unique_ptr qu·∫£n l√Ω.

üíª
```cpp
#include <iostream>
#include <memory>  // C·∫ßn thi·∫øt ƒë·ªÉ s·ª≠ d·ª•ng smart pointer

using namespace std;

class Example{
    private:
        int data;

    public:
        Example(int value): data(value){
            cout << "Constructor called, data = " << data << endl;
        }

        ~Example(){
            cout << "Destructor called, data = " << data << endl;
        }

        void display(){
            cout << "Value: " << data << endl;
        }
};

int main() 
{
    unique_ptr<Example> ptr1 = make_unique<Example>(30);
    unique_ptr<Example> ptr2 = make_unique<Example>(60);
    ptr1.swap(ptr2);

    ptr1->display();
    ptr2->display();
    return 0;
}
```

<br>

<b>6. move()</b>

Chuy·ªÉn nh∆∞·ª£ng quy·ªÅn s·ªü h·ªØu t√†i nguy√™n (move semantics). Sau khi chuy·ªÉn nh∆∞·ª£ng (move), con tr·ªè g·ªëc s·∫Ω tr·ªü th√†nh nullptr v√† quy·ªÅn s·ªü h·ªØu t√†i nguy√™n ƒë∆∞·ª£c chuy·ªÉn sang **unique_ptr** m·ªõi.

üíª
```cpp
#include <iostream>
#include <memory>  // C·∫ßn thi·∫øt ƒë·ªÉ s·ª≠ d·ª•ng smart pointer

using namespace std;

class Example{
    private:
        int data;

    public:
        Example(int value): data(value){
            cout << "Constructor called, data = " << data << endl;
        }

        ~Example(){
            cout << "Destructor called, data = " << data << endl;
        }

        void display(){
            cout << "Value: " << data << endl;
        }
};

int main() 
{
    unique_ptr<Example> ptr1 = make_unique<Example>(30);
    unique_ptr<Example> newPtr = move(ptr); // chuy·ªÉn quy·ªÅn s·ªü h·ªØu t·ª´ ptr sang newPtr

    if (!ptr){
        cout << "ptr ƒë√£ tr·ªü th√†nh nullptr sau khi chuy·ªÉn quy·ªÅn s·ªü h·ªØu\n";
    }
    newPtr->display();  // newPtr gi·ªù s·ªü h·ªØu ƒë·ªëi t∆∞·ª£ng
    return 0;
}
```

<br>

</p>
</details>

<details><summary><b>4. Shared Pointer</b></summary>
<p>

- **Shared Pointer** (``` shared_ptr ```) l√† m·ªôt smart pointer h·ªó tr·ª£ chia s·∫ª quy·ªÅn s·ªü h·ªØu ƒë·ªëi v·ªõi m·ªôt ƒë·ªëi t∆∞·ª£ng.
- Nhi·ªÅu ``` shared_ptr ``` c√≥ th·ªÉ c√πng s·ªü h·ªØu m·ªôt ƒë·ªëi t∆∞·ª£ng. ƒê·ªëi t∆∞·ª£ng ch·ªâ ƒë∆∞·ª£c gi·∫£i ph√≥ng khi kh√¥ng c√≤n ``` shared_ptr ``` n√†o s·ªü h·ªØu n√≥ (ƒë·∫øm tham chi·∫øu ƒë·∫°t gi√° tr·ªã 0).

- shared pointer (shared_ptr) l√† m·ªôt smart pointer h·ªó tr·ª£ chia s·∫ª quy·ªÅn s·ªü h·ªØu ƒë·ªëi v·ªõi m·ªôt ƒë·ªëi t∆∞·ª£ng.
- Nhi·ªÅu shared_ptr c√≥ th·ªÉ c√πng s·ªü h·ªØu m·ªôt ƒë·ªëi t∆∞·ª£ng. ƒê·ªëi t∆∞·ª£ng ch·ªâ ƒë∆∞·ª£c gi·∫£i ph√≥ng khi kh√¥ng c√≤n shared_ptr n√†o s·ªü h·ªØu n√≥ (ƒë·∫øm tham chi·∫øu ƒë·∫°t gi√° tr·ªã 0).

<br>

Nh·ªØng ph∆∞∆°ng th·ª©c ch√≠nh m√† ``` std::shared_ptr ``` h·ªó tr·ª£:

<b>1. operator*() v√† operator->()</b>: t∆∞∆°ng t·ª± ``` unique_ptr ```

<b>2. get()</b>: t∆∞∆°ng t·ª± ``` unique_ptr ```

<b>3. reset()</b>: t∆∞∆°ng t·ª± ``` unique_ptr ```

<b>4. swap()</b>: t∆∞∆°ng t·ª± ``` unique_ptr ```

<b>5. operator=</b>

Sao ch√©p ho·∫∑c di chuy·ªÉn quy·ªÅn s·ªü h·ªØu gi·ªØa c√°c ``` shared_ptr ```.

<b>6. use_count()</b>

Tr·∫£ v·ªÅ s·ªë l∆∞·ª£ng shared_ptr ƒëang c√πng qu·∫£n l√Ω ƒë·ªëi t∆∞·ª£ng (b·ªô ƒë·∫øm tham chi·∫øu).

<br>

üíª
```cpp
#include <iostream>
#include <memory>

using namespace std;

int main(int argc, char const *argv[])
{
    shared_ptr<int> ptr1 = make_shared<int>(20); // 0x01
    shared_ptr<int> ptr2 = ptr1;
    shared_ptr<int> ptr3 = ptr1;

    {
        shared_ptr<int> ptr4 = ptr1;
        cout << "Count: " << ptr1.use_count() << endl;
    }

    cout << "ptr1 = " << *ptr1 << endl;
    cout << "ptr2 = " << *ptr2 << endl;
    cout << "ptr3 = " << *ptr3 << endl;

    cout << "Count: " << ptr1.use_count() << endl;
    
    int *ptr = ptr1.get();
    cout << "ptr: " << *ptr << endl;
    *ptr = 50;
    cout << "ptr: " << *ptr << endl;
    /*
     * tr·∫£ v·ªÅ 1 con tr·ªè int
     */

    shared_ptr<int> a = make_shared<int>(40);   // 0xa1
    shared_ptr<int> b = make_shared<int>(50);   // 0xb3
    a.swap(b);
    cout << "a = " << *a << endl;
    cout << "b = " << *b << endl;
    
    return 0;
}
```
**K·∫øt qu·∫£:**
```cpp
Count: 4
ptr1 = 20
ptr2 = 20
ptr3 = 20
Count: 3
ptr: 20
ptr: 50
a = 50
b = 40
```

<br>

</p>
</details>

<details><summary><b>5. Weak Pointer</b></summary>
<p>

- **Weak Pointer** (``` weak_ptr ```) l√† m·ªôt smart pointer kh√¥ng s·ªü h·ªØu ƒë·ªëi t∆∞·ª£ng m√† n√≥ tr·ªè t·ªõi. N√≥ ch·ªâ ƒë√≥ng vai tr√≤ theo d√µi ƒë·ªëi t∆∞·ª£ng ƒë∆∞·ª£c qu·∫£n l√Ω b·ªüi m·ªôt ``` shared_ptr ``` m√† kh√¥ng l√†m tƒÉng b·ªô ƒë·∫øm tham chi·∫øu.
- ``` weak_ptr ``` ch·ªâ theo d√µi m·ªói ``` shared_ptr ```, kh√¥ng theo d√µi ``` unique_ptr ``` v√¨ ch√≠nh ƒë·∫∑c ƒëi·ªÉm c·ªßa ``` unique_ptr ``` ƒë√£ ngƒÉn ch·∫∑n vi·ªác ƒë√≥.

<br>

Nh·ªØng ph∆∞∆°ng th·ª©c ch√≠nh m√† ``` std::shared_ptr ``` h·ªó tr·ª£:

<b>1. use_count()</b>: t∆∞∆°ng t·ª± ``` shared_ptr ```

<b>2. reset()</b>: t∆∞∆°ng t·ª± ``` shared_ptr ``` v√† ``` unique_ptr ```

<b>3. swap()</b>: t∆∞∆°ng t·ª± ``` shared_ptr ``` v√† ``` unique_ptr ```

<b>4. operator=</b>

- G√°n m·ªôt ``` shared_ptr ``` ho·∫∑c m·ªôt ``` weak_ptr ``` kh√°c cho ``` weak_ptr ```.
- Khi g√°n m·ªôt shared_ptr cho m·ªôt weak_ptr s·∫Ω kh√¥ng l√†m tƒÉng b·ªô ƒë·∫øm tham chi·∫øu.

<b>5. lock()</b>

Tr·∫£ v·ªÅ shared_ptr tr·ªè t·ªõi ƒë·ªëi t∆∞·ª£ng m√† weak_ptr theo d√µi, ho·∫∑c null n·∫øu ƒë·ªëi t∆∞·ª£ng ƒë√£ b·ªã h·ªßy.

<b>6. expired()</b>

Tr·∫£ v·ªÅ true n·∫øu ƒë·ªëi t∆∞·ª£ng m√† weak_ptr theo d√µi ƒë√£ b·ªã h·ªßy.

<br>

üíª
```cpp
#include <iostream>
#include <memory>

using namespace std;

int main(int argc, char const *argv[])
{
    // T·∫°o hai shared_ptr c√πng qu·∫£n l√Ω m·ªôt ƒë·ªëi t∆∞·ª£ng int
    shared_ptr<int> ptr1 = make_shared<int>(20); // 0x01
    shared_ptr<int> ptr2 = ptr1;

    // T·∫°o m·ªôt weak_ptr tr·ªè t·ªõi ƒë·ªëi t∆∞·ª£ng ƒë∆∞·ª£c qu·∫£n l√Ω b·ªüi shared_ptr
    weak_ptr<int> ptr3 = ptr1;

    cout << "Count: " << ptr1.use_count() << endl;

    cout << "ptr3: " << *(ptr3.lock()) << endl;

    ptr1.reset();   // gi·∫£i ph√≥ng quy·ªÅn s·ªü h·ªØu c·ªßa ptr1 ƒë·ªëi v·ªõi ƒë·ªëi t∆∞·ª£ng t·∫°i ƒë·ªãa ch·ªâ 0x01

    cout << "check: " << ptr3.expired() << endl;
    /*
     * n·∫øu 0x01 c√≤n t·ªìn t·∫°i th√¨ tr·∫£ v·ªÅ false
     * ng∆∞·ª£c l·∫°i th√¨ tr·∫£ v·ªÅ true
     */

    ptr2.reset();
    cout << "check: " << ptr3.expired() << endl;
    
    return 0;
}
```
**K·∫øt qu·∫£:**
```cpp
Count: 2
ptr2: 20
check: 0
check: 1
```

<br>

</p>
</details>

<details><summary><b>6. Building and Desinging Library</b></summary>
<p>

<details><summary><b>üìö Unique Pointer</b></summary>
<p>

https://github.com/NHAnh2082/Cpp_Programming_Language/blob/3b23d1737f9b6e5db35057cdb03ac59fcceff890/Smart_%20Pointer/Lib/Unique_Pointer.hpp

</p>
</details>

<details><summary><b>üìö Shared Pointer</b></summary>
<p>

https://github.com/NHAnh2082/Cpp_Programming_Language/blob/3b23d1737f9b6e5db35057cdb03ac59fcceff890/Smart_%20Pointer/Lib/Shared_Pointer.hpp

</p>
</details>

<details><summary><b>üìö Weak Pointer</b></summary>
<p>

https://github.com/NHAnh2082/Cpp_Programming_Language/blob/3b23d1737f9b6e5db35057cdb03ac59fcceff890/Smart_%20Pointer/Lib/Weak_Pointer.hpp

</p>
</details>

</p>
</details>

</p>
</details>

<br>

<details><summary><b>Design Patterns</b></summary>
<p>

<details><summary><b>1. Gi·ªõi thi·ªáu v·ªÅ Design Patterns</b></summary>
<p>

Design Patterns l√† c√°c gi·∫£i ph√°p t·ªïng qu√°t cho c√°c v·∫•n ƒë·ªÅ ph·ªï bi·∫øn trong ph√°t tri·ªÉn ph·∫ßn m·ªÅm. Ch√∫ng l√† m·ªôt d·∫°ng "c√¥ng th·ª©c" gi√∫p c√°c l·∫≠p tr√¨nh vi√™n x·ª≠ l√Ω c√°c t√¨nh hu·ªëng th∆∞·ªùng g·∫∑p trong qu√° tr√¨nh thi·∫øt k·∫ø.

Design Patterns kh√¥ng ph·∫£i l√† ng√¥n ng·ªØ c·ª• th·ªÉ n√†o c·∫£. N√≥ c√≥ th·ªÉ th·ª±c hi·ªán ƒë∆∞·ª£c ·ªü ph·∫ßn l·ªõn c√°c ng√¥n ng·ªØ l·∫≠p tr√¨nh, ch·∫≥ng h·∫°n nh∆∞ C/C++, C#, Java,...

Design Patterns ƒë∆∞·ª£c chia th√†nh 3 nh√≥m ch√≠nh:

- Creational Pattern (m·∫´u kh·ªüi t·∫°o): Qu·∫£n l√Ω vi·ªác kh·ªüi t·∫°o ƒë·ªëi t∆∞·ª£ng, v√≠ d·ª•: Singleton, Factory, Prototype,...
- Behavioral Pattern (m·∫´u t∆∞∆°ng t√°c): X√°c ƒë·ªãnh c√°ch c√°c ƒë·ªëi t∆∞·ª£ng t∆∞∆°ng t√°c v·ªõi nhau v√≠ d·ª•: Observer, MVP, Iterator,...
- Structural Pattern (m·∫´u c·∫•u tr√∫c): T·ªï ch·ª©c c·∫•u tr√∫c c·ªßa c√°c l·ªõp v√† ƒë·ªëi t∆∞·ª£ng, v√≠ d·ª•: Decorator, Adapter, Composite,...

<br>

</p>
</details>

<details><summary><b>2. Single Pattern</b></summary>
<p>

- Singleton l√† m·ªôt m·∫´u thi·∫øt k·∫ø thu·ªôc nh√≥m Creational (m·∫´u kh·ªüi t·∫°o), n√≥ ƒë·∫£m b·∫£o r·∫±ng m·ªôt class ch·ªâ t·∫°o ƒë∆∞·ª£c duy nh·∫•t m·ªôt ƒë·ªëi t∆∞·ª£ng (object) v√† cung c·∫•p m·ªôt ph∆∞∆°ng th·ª©c tƒ©nh ƒë·ªÉ c√≥ th·ªÉ truy c·∫≠p ƒë·∫øn ƒë·ªëi t∆∞·ª£ng n√†y.
- Singleton th∆∞·ªùng s·ª≠ d·ª•ng cho nh·ªØng h·ªá th·ªëng ch·ªâ c·∫ßn m·ªôt phi√™n b·∫£n duy nh·∫•t nh∆∞: k·∫øt n·ªëi c∆° s·ªü d·ªØ li·ªáu, b·ªô nh·ªõ ƒë·ªám (cache), logger ƒë·ªÉ ghi log, ho·∫∑c c·∫•u h√¨nh h·ªá th·ªëng.

<br>

üíª **V√≠ d·ª• 1:**
```cpp
#include <iostream>

void gpioInit()
{
    std::cout << "C·∫•u h√¨nh GPIO" << std::endl;
}

void gpioSetPin(int pin, bool value)
{
    std::cout << "Pin " << pin << " set to " << (value ? "HIGH" : "LOW") << std::endl;
}

void gpioReadPin(int pin)
{
    std::cout << "Reading Pin " << pin << std::endl;
}

class GPIOManager
{
    private:
	// Constructor ·ªü private ƒë·ªÉ ngƒÉn ch·∫∑n t·∫°o object t·ª´ b√™n ngo√†i
        GPIOManager()
        {
	    gpioInit();
	    // b·ªï sung th√™m t√≠nh nƒÉng
	}

	// Thu·ªôc t√≠nh tƒ©nh d√πng ƒë·ªÉ qu·∫£n l√Ω ƒë·ªëi t∆∞·ª£ng duy nh·∫•t ƒë∆∞·ª£c t·∫°o ra
        static GPIOManager* instance;	

    public:
        static GPIOManager *getInstance()
	{
            if (!instance)
	    {
                instance = new GPIOManager(); // ƒê√¢y l√† ƒë·ªëi t∆∞·ª£ng duy nh·∫•t ƒë∆∞·ª£c t·∫°o             
            }
            return instance;
        }
        
        void setPin(int pin, bool value)
	{
            gpioSetPin(pin, value);
        }

        void readPin(int pin)
	{
            gpioReadPin(pin);
        }
};

GPIOManager* GPIOManager::instance = nullptr; // 0xc8 : ƒë·ªãa ch·ªâ c·ªë ƒë·ªãnh

int main(int argc, char const *argv[])
{
    GPIOManager* gpioManager1 = GPIOManager::getInstance();

    gpioManager1->setPin(1, true);

    gpioManager1->readPin(2);

    GPIOManager* gpioManager2 = GPIOManager::getInstance();

    return 0;
}
```
üìù gpioManager1 v√† gpioManager2 ƒë·ªÅu c√πng tr·ªè ƒë·∫øn c√πng m·ªôt ƒë·ªëi t∆∞·ª£ng ``` instance ``` c√≥ ƒë·ªãa ch·ªâ l√† 0xc8, ƒë∆∞·ª£c g·ªçi th√¥ng qua method ``` getIntance() ```, nghƒ©a l√† ch√∫ng ƒë·ªÅu c√πng tr·ªè ƒë·∫øn 1 v√πng l√†m vi·ªác chung.

üìù Constructor ``` GPIOManager() ``` n·∫±m ·ªü private ƒë·ªÉ kh√¥ng cho ph√©p kh·ªüi t·∫°o object th√¥ng th∆∞·ªùng.

üìù ``` static GPIOManager* instance ```: con tr·ªè instance thu·ªôc class GPIOManager v√† ph·∫£i ƒë∆∞·ª£c kh·ªüi t·∫°o tr∆∞·ªõc v√¨ l√† static trong class: ``` GPIOManager* GPIOManager::instance = nullptr ```, kh·ªüi t·∫°o ban ƒë·∫ßu l√† con tr·ªè NULL.

üìù Khi ``` gpioManager1 ``` c·∫•u h√¨nh Pin hay ƒë·ªçc gi√° tr·ªã Pin n√†o th√¨ ``` gpioManager2 ``` c≈©ng s·∫Ω th·ª±c hi·ªán t∆∞∆°ng t·ª±.

<br>

üíª **V√≠ d·ª• 2:**
```cpp
#include <iostream>
#include "stm32f10x.h"  

class UART
{
    private:
        static UART* instance;  
        
        UART()
	{
            initUART();
        }

        void initUART()
	{
            RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
            USART_InitTypeDef USART_InitStructure;

            USART_InitStructure.USART_BaudRate = 115200;
            USART_InitStructure.USART_WordLength = USART_WordLength_8b;
            USART_InitStructure.USART_StopBits = USART_StopBits_1;
            USART_InitStructure.USART_Parity = USART_Parity_No;
            USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
            USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;

            USART_Init(USART1, &USART_InitStructure);
            USART_Cmd(USART1, ENABLE);
        }

    public:
        static UART* getInstance()
	{
            if (instance == nullptr)
	    {
                instance = new UART();  // T·∫°o instance n·∫øu ch∆∞a c√≥
            }
            return instance;
        }

        void sendData(uint8_t data)
	{
            while (USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);
            USART_SendData(USART1, data);
        }

        uint8_t receiveData()
	{
            while (USART_GetFlagStatus(USART1, USART_FLAG_RXNE) == RESET);
            return USART_ReceiveData(USART1);
        }
};

UART* UART::instance = nullptr;

int main()
{
    UART* uart1 = UART::getInstance();

    // G·ª≠i m·ªôt k√Ω t·ª± qua UART
    uart1->sendData('H');

    UART* uart2 = UART::getInstance();

    // Nh·∫≠n m·ªôt k√Ω t·ª± t·ª´ UART
    uint8_t received = uart2->receiveData();

    while (1) {
        // Th·ª±c hi·ªán c√¥ng vi·ªác li√™n quan kh√°c
    }
}
```
üìù uart1 v√† uart2 c√πng tr·ªè ƒë·∫øn m·ªôt ƒë·ªëi t∆∞·ª£ng ``` instance ``` th√¥ng qua method ``` getInstance ``` n√™n s·∫Ω c√≥ chung c·∫•u h√¨nh, ƒëi·ªÅu n√†y ƒë·∫£m b·∫£o r·∫±ng c·∫•u h√¨nh UART l√† nh·∫•t qu√°n trong to√†n b·ªô h·ªá th·ªëng.

<br>

üíª **V√≠ d·ª• 3:**
```cpp
#include <iostream>
#include <string>
#include <vector>

using namespace std;

/*
 * M·∫´u thi·∫øt k·∫ø ƒë∆∞·ª£c √°p d·ª•ng v√†o trong nh·ªØng ho√†n c·∫£nh m√† y√™u c·∫ßu
 * class ch·ªâ cho ph√©p 1 ƒë·ªëi t∆∞·ª£ng ƒë∆∞·ª£c t·∫°o ra
 */

class Vehicle
{
    private:
        const string modelName;
        string ownerName;
        string license;

    public:
        Vehicle(string name): modelName(name){}

        virtual void run()
        {
            cout << modelName << " is running\n";
        }
};

class VehicleManager
{
    private:
        vector<Vehicle*> Vehicles;

        static VehicleManager *manager;

        // Gi·ªõi h·∫°n s·ªë l·∫ßn c·∫•p ph√°t ƒë·ªông ƒë·ªÉ t·∫°o ra ƒë·ªëi t∆∞·ª£ng
        VehicleManager(){}

    public:
        static VehicleManager* getManager()
        {
            if (manager == nullptr)
            {
                manager = new VehicleManager();
            }
            return manager;
        }

        void addVehicle(Vehicle *vehicle)
        {
            Vehicles.push_back(vehicle);
        }

        void start()
        {
            for (auto i : Vehicles)
            {
                i->run();
            }
        }
};

VehicleManager* VehicleManager::manager = nullptr;

int main(int argc, char const *argv[])
{
    Vehicle *taxi  = new Vehicle("Honda");
    Vehicle *motor = new Vehicle("Wave");

    VehicleManager *vm = VehicleManager::getManager();
    vm->addVehicle(taxi);
    vm->addVehicle(motor);
    vm->start();

    return 0;
}
```

<br>

**·ª®ng d·ª•ng**:

- Qu·∫£n l√Ω t√†i nguy√™n h·ªá th·ªëng (c∆° s·ªü d·ªØ li·ªáu, t·∫≠p tin, m√°y in).
- C√°c b·ªô nh·ªõ ƒë·ªám (cache), qu·∫£n l√Ω tr·∫°ng th√°i ·ª©ng d·ª•ng.
- ƒêƒÉng k√Ω logger cho to√†n b·ªô ·ª©ng d·ª•ng.

<br>

</p>
</details>

<details><summary><b>3. Observer Pattern</b></summary>
<p>

Observer l√† m·ªôt m·∫´u thi·∫øt k·∫ø thu·ªôc nh√≥m Behavioral, cho ph√©p m·ªôt ƒë·ªëi t∆∞·ª£ng (g·ªçi l√† Subject) th√¥ng b√°o cho nhi·ªÅu ƒë·ªëi t∆∞·ª£ng kh√°c (g·ªçi l√† Observer) v·ªÅ s·ª± thay ƒë·ªïi tr·∫°ng th√°i m√† kh√¥ng c·∫ßn bi·∫øt chi ti·∫øt v·ªÅ c√°c ƒë·ªëi t∆∞·ª£ng ƒë√≥.

**ƒê·∫∑c ƒëi·ªÉm ch√≠nh c·ªßa Observer Pattern**:

1. **M·ªëi quan h·ªá c·ªßa Subject v√† Observer**:

- Subject gi·ªØ m·ªôt danh s√°ch c√°c Observer. C√°c Observer ƒëƒÉng k√Ω nh·∫≠n th√¥ng b√°o t·ª´ Subject khi c√≥ s·ª± thay ƒë·ªïi tr·∫°ng th√°i. Observer c√≥ th·ªÉ th√™m, xo√° ho·∫∑c c·∫≠p nh·∫≠t trong danh s√°ch n√†y.

2. **T·ª± ƒë·ªông th√¥ng b√°o (Push Notification)**:

- Khi tr·∫°ng th√°i c·ªßa Subject thay ƒë·ªïi, n√≥ s·∫Ω t·ª± ƒë·ªông th√¥ng b√°o cho t·∫•t c·∫£ c√°c Observer ƒë√£ ƒëƒÉng k√Ω. C√°c Observer kh√¥ng c·∫ßn ch·ªß ƒë·ªông ki·ªÉm tra tr·∫°ng th√°i c·ªßa Subject m√† s·∫Ω nh·∫≠n th√¥ng b√°o ngay khi c√≥ thay ƒë·ªïi.

3. **T√≠nh linh ho·∫°t v√† m·ªü r·ªông**:

- Observer Pattern cho ph√©p d·ªÖ d√†ng th√™m ho·∫∑c x√≥a c√°c Observer m√† kh√¥ng c·∫ßn thay ƒë·ªïi Subject ho·∫∑c Observer c√≥ th·ªÉ d·ªÖ d√†ng ng·ª´ng nh·∫≠n th√¥ng b√°o t·ª´ Subject b·∫±ng c√°ch h·ªßy ƒëƒÉng k√Ω, gi√∫p ki·ªÉm so√°t t·ªët h∆°n vi·ªác qu·∫£n l√Ω t√†i nguy√™n v√† s·ª± ki·ªán trong h·ªá th·ªëng.

4. **Gi·∫£m s·ª± ph·ª• thu·ªôc ch·∫∑t ch·∫Ω**:

- Subject kh√¥ng c·∫ßn bi·∫øt ch√≠nh x√°c v·ªÅ c√°c Observer m√† n√≥ qu·∫£n l√Ω, ch·ªâ c·∫ßn bi·∫øt r·∫±ng ch√∫ng tu√¢n theo m·ªôt giao di·ªán chung ƒë·ªÉ nh·∫≠n th√¥ng b√°o. ƒêi·ªÅu n√†y gi√∫p gi·∫£m s·ª± ph·ª• thu·ªôc ch·∫∑t ch·∫Ω gi·ªØa c√°c ƒë·ªëi t∆∞·ª£ng v√† l√†m cho m√£ d·ªÖ b·∫£o tr√¨ h∆°n.

5. **Nhi·ªÅu Observer c√≥ th·ªÉ theo d√µi m·ªôt ho·∫∑c nhi·ªÅu Subject**:

- Nhi·ªÅu Observer c√≥ th·ªÉ c√πng theo d√µi m·ªôt Subject. ƒêi·ªÅu n√†y cho ph√©p c√πng m·ªôt s·ª± ki·ªán trong Subject c√≥ th·ªÉ ·∫£nh h∆∞·ªüng ƒë·∫øn nhi·ªÅu ƒë·ªëi t∆∞·ª£ng kh√°c nhau.
- M·ªôt Observer c√≥ th·ªÉ ƒëƒÉng k√Ω ƒë·ªÉ nh·∫≠n th√¥ng b√°o t·ª´ nhi·ªÅu Subject kh√°c nhau, v√† m·ªói Subject s·∫Ω th√¥ng b√°o cho Observer khi c√≥ s·ª± thay ƒë·ªïi li√™n quan.

<br>

üíª **V√≠ d·ª• 1:**
```cpp
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

using namespace std;

// Interface for observers (display, logger, etc.)
class Observer{

    public:
        virtual void update(float temperature, float humidity, float light) = 0;
};

// Subject (SensorManager) holds the state and notifies observers
class SensorManager
{
        float temperature;
        float humidity;
        float light;
        vector<Observer*> observers;

    public:
        void registerObserver(Observer* observer)
        {
            observers.push_back(observer);
        }

        void removeObserver(Observer* observer)
        {
            observers.erase(std::remove(observers.begin(), observers.end(), observer), observers.end());
        }

        void notifyObservers()
        {
            for (auto observer : observers)
            {
                observer->update(temperature, humidity, light);
            }
        }

        void setMeasurements(float temp, float hum, float lightLvl) 
        {
            temperature = temp;
            humidity = hum;
            light = lightLvl;
            notifyObservers();  // Push notification to all registered observers
        }
};

// Another Subject class
class WeatherStation
{
        float windSpeed;
        vector<Observer*> observers;

    public:
        void registerObserver(Observer* observer)
        {
            observers.push_back(observer);
        }

        void removeObserver(Observer* observer)
        {
            observers.erase(std::remove(observers.begin(), observers.end(), observer), observers.end());
        }

        void notifyObservers()
        {
            for (auto observer : observers)
            {
                observer->update(windSpeed, 0.0, 0.0);  // update for wind speed only
            }
        }

        void setWindSpeed(float speed)
        {
            windSpeed = speed;
            notifyObservers();  // Notify all observers of wind speed change
        }
};

// Display component (an observer)
class Display : public Observer 
{
    public:
        void update(float temperature, float humidity, float light) override 
        {
            cout << "Display: Temperature: " << temperature 
                 << ", Humidity: " << humidity 
                 << ", Light: " << light << endl;
        }
};

// Logger component (an observer)
class Logger : public Observer 
{
    public:
        void update(float temperature, float humidity, float light) override 
        {
            cout << "Logging data... Temp: " << temperature 
                 << ", Humidity: " << humidity 
                 << ", Light: " << light << endl;
        }
};

int main() 
{
    Display display;
    Logger  logger;

    SensorManager  sensorManager;
    WeatherStation weatherStation;

    // register observers to SensorManager
    sensorManager.registerObserver(&display);
    sensorManager.registerObserver(&logger);

    // register observers to WeatherManager
    weatherStation.registerObserver(&display);
    weatherStation.registerObserver(&logger);

    // simulate sensor data update
    sensorManager.setMeasurements(25.0, 60.0, 700.0);
    sensorManager.setMeasurements(26.0, 65.0, 800.0);
    cout << "\n";

    // simulate wind speed update
    weatherStation.setWindSpeed(15.0);
    weatherStation.setWindSpeed(25.4);
    cout << "\n";

    // Remove Logger from SensorManager notifications
    sensorManager.removeObserver(&logger);

    // Update sensor data again to see only Display receiving notifications
    sensorManager.setMeasurements(27.0, 70.0, 900.0);

    return 0;
}
```
**K·∫øt qu·∫£**:
```cpp
Display: Temperature: 25, Humidity: 60, Light: 700
Logging data... Temp: 25, Humidity: 60, Light: 700
Display: Temperature: 26, Humidity: 65, Light: 800
Logging data... Temp: 26, Humidity: 65, Light: 800

Display: Temperature: 15, Humidity: 0, Light: 0
Logging data... Temp: 15, Humidity: 0, Light: 0
Display: Temperature: 25.4, Humidity: 0, Light: 0
Logging data... Temp: 25.4, Humidity: 0, Light: 0

Display: Temperature: 27, Humidity: 70, Light: 900
```
üìù C√°c property ``` temperature, humidity, light ``` v√† ``` vector<Observer*> observers ``` m·∫∑c ƒë·ªãnh n·∫±m ·ªü pham vi truy c·∫≠p private.

üìù **SensorManager** v√† **WeatherStation** (Subject) qu·∫£n l√Ω danh s√°ch c√°c **Observer**. C√°c Observer c√≥ th·ªÉ ƒëƒÉng k√Ω th√¥ng qua ph∆∞∆°ng th·ª©c ``` registerObserver() ``` v√† c√≥ th·ªÉ b·ªã x√≥a b·∫±ng ``` removeObserver() ```. ƒêi·ªÅu n√†y ƒë·∫£m b·∫£o vi·ªác qu·∫£n l√Ω danh s√°ch Observer m·ªôt c√°ch linh ho·∫°t.

üìù Khi tr·∫°ng th√°i thay ƒë·ªïi trong SensorManager (v√≠ d·ª•: nhi·ªát ƒë·ªô, ƒë·ªô ·∫©m, √°nh s√°ng), t·∫•t c·∫£ c√°c Observer ƒë∆∞·ª£c th√¥ng b√°o qua ph∆∞∆°ng th·ª©c ``` notifyObservers() ``` m√† kh√¥ng c·∫ßn ch√∫ng ch·ªß ƒë·ªông ki·ªÉm tra.

üìù B·∫•t k·ª≥ Observer n√†o c≈©ng c√≥ th·ªÉ d·ªÖ d√†ng ƒë∆∞·ª£c th√™m ho·∫∑c x√≥a kh·ªèi Subject m√† kh√¥ng c·∫ßn thay ƒë·ªïi c·∫•u tr√∫c c·ªßa Subject ho·∫∑c Observer. V√≠ d·ª•: Sau khi Logger ƒë∆∞·ª£c x√≥a kh·ªèi danh s√°ch Observer c·ªßa SensorManager, ch·ªâ c√≥ Display nh·∫≠n ƒë∆∞·ª£c th√¥ng b√°o khi c√≥ s·ª± thay ƒë·ªïi.

üìù SensorManager kh√¥ng c·∫ßn bi·∫øt chi ti·∫øt v·ªÅ Display hay Logger, ch·ªâ c·∫ßn bi·∫øt r·∫±ng ch√∫ng tu√¢n theo giao di·ªán Observer (v·ªõi vi·ªác override method ``` update() ```). ƒêi·ªÅu n√†y gi√∫p gi·∫£m s·ª± ph·ª• thu·ªôc ch·∫∑t ch·∫Ω gi·ªØa c√°c ƒë·ªëi t∆∞·ª£ng v√† tƒÉng kh·∫£ nƒÉng b·∫£o tr√¨.

üìù Display v√† Logger theo d√µi c·∫£ SensorManager v√† WeatherStation. Khi b·∫•t k·ª≥ tr·∫°ng th√°i n√†o trong hai Subject n√†y thay ƒë·ªïi, c√°c Observer s·∫Ω nh·∫≠n ƒë∆∞·ª£c th√¥ng b√°o t∆∞∆°ng ·ª©ng.

<br>

üíª
```cpp
#include <iostream>
#include <vector>

using namespace std;

// Observer interface
class ButtonObserver
{
    public:
        virtual void update(int buttonID, bool state) = 0;
};

// Subject class - Button
class Button
{
        int buttonID;
        bool state;
        vector<ButtonObserver*> observers;

    public:
        Button(int id): buttonID(id), state(false){}

        void registerObserver(ButtonObserver* observer)
        {
            observers.push_back(observer);
        }

        void notifyObservers()
        {
            for (auto observer : observers)
            {
                observer->update(buttonID, state);
            }
        }

        void pressButton()
        {
            state = true;
            notifyObservers();
        }

        void releaseButton()
        {
            state = false;
            notifyObservers();
        }
};

// LED device acting as an observer
class LED : public ButtonObserver
{
    public:
        void update(int buttonID, bool state) override 
        {
            cout << "LED reacts to Button " << buttonID << " being " << (state ? "pressed" : "released") << std::endl;
        }
};

// Buzzer device acting as an observer
class Buzzer : public ButtonObserver
{
    public:
        void update(int buttonID, bool state) override {
            cout << "Buzzer reacts to Button " << buttonID << " being " << (state ? "pressed" : "released") << std::endl;
        }
};

int main() 
{
    Button button1(1);
    Button button2(2);

    Buzzer buzzer;
    LED    led;

    // Register observers
    button1.registerObserver(&led);
    button1.registerObserver(&buzzer);

    button2.registerObserver(&led);

    // Simulate button presses
    button1.pressButton();
    button1.releaseButton();
    cout << "\n";

    button2.pressButton();
    button2.releaseButton();

    return 0;
}
```
**K·∫øt qu·∫£**:
```cpp
LED reacts to Button 1 being pressed
Buzzer reacts to Button 1 being pressed
LED reacts to Button 1 being released
Buzzer reacts to Button 1 being released

LED reacts to Button 2 being pressed
LED reacts to Button 2 being released
```

**·ª®ng d·ª•ng**:

- Giao di·ªán ƒë·ªì h·ªça (c·∫≠p nh·∫≠t giao di·ªán khi d·ªØ li·ªáu thay ƒë·ªïi).
- H·ªá th·ªëng th√¥ng b√°o (qu·∫£n l√Ω s·ª± ki·ªán, h·ªá th·ªëng b√°o l·ªói).
- Trong Automotive, Observer c√≥ th·ªÉ ƒë∆∞·ª£c d√πng ƒë·ªÉ ph√°t hi·ªán v√† th√¥ng b√°o c√°c thay ƒë·ªïi tr·∫°ng th√°i c·ªßa sensor ho·∫∑c c√°c m√¥-ƒëun ƒëi·ªÅu khi·ªÉn.

<br>

</p>
</details>

<details><summary><b>4. Factory Pattern</b></summary>
<p>

Factory Pattern l√† m·ªôt m·∫´u thi·∫øt k·∫ø (design pattern) thu·ªôc nh√≥m Creational patterns, cung c·∫•p m·ªôt c∆° ch·∫ø ƒë·ªÉ t·∫°o ra c√°c ƒë·ªëi t∆∞·ª£ng m√† kh√¥ng c·∫ßn ch·ªâ r√µ l·ªõp c·ª• th·ªÉ c·ªßa c√°c ƒë·ªëi t∆∞·ª£ng ƒë√≥. Thay v√¨ kh·ªüi t·∫°o tr·ª±c ti·∫øp c√°c ƒë·ªëi t∆∞·ª£ng, Factory Pattern s·ª≠ d·ª•ng m·ªôt ph∆∞∆°ng th·ª©c ho·∫∑c m·ªôt l·ªõp trung gian (Factory) ƒë·ªÉ quy·∫øt ƒë·ªãnh lo·∫°i ƒë·ªëi t∆∞·ª£ng n√†o s·∫Ω ƒë∆∞·ª£c kh·ªüi t·∫°o d·ª±a tr√™n tham s·ªë ƒë·∫ßu v√†o ho·∫∑c logic c·ª• th·ªÉ.

ƒê·∫∑c ƒëi·ªÉm c·ªßa Factory Pattern:

- **T√≠nh tr·ª´u t∆∞·ª£ng**: Factory Pattern ·∫©n ƒëi chi ti·∫øt v·ªÅ c√°ch c√°c ƒë·ªëi t∆∞·ª£ng ƒë∆∞·ª£c t·∫°o ra, gi√∫p ch∆∞∆°ng tr√¨nh t√°ch bi·ªát gi·ªØa vi·ªác kh·ªüi t·∫°o ƒë·ªëi t∆∞·ª£ng v√† vi·ªác s·ª≠ d·ª•ng ƒë·ªëi t∆∞·ª£ng ƒë√≥.
- **T√≠nh m·ªü r·ªông**: Factory Pattern gi√∫p h·ªá th·ªëng d·ªÖ d√†ng m·ªü r·ªông khi c·∫ßn th√™m c√°c l·ªõp con m·ªõi m√† kh√¥ng l√†m ·∫£nh h∆∞·ªüng ƒë·∫øn m√£ ngu·ªìn hi·ªán c√≥.
- **T√≠nh linh ho·∫°t**: Khi h·ªá th·ªëng c·∫ßn thay ƒë·ªïi ho·∫∑c th√™m m·ªõi c√°c ƒë·ªëi t∆∞·ª£ng c·ª• th·ªÉ, ch√∫ng ta ch·ªâ c·∫ßn c·∫≠p nh·∫≠t factory m√† kh√¥ng c·∫ßn s·ª≠a ƒë·ªïi m√£ ngu·ªìn ch√≠nh.
- **Gi·∫£m s·ª± ph·ª• thu·ªôc**: Factory Pattern gi√∫p m√£ ngu·ªìn gi·∫£m s·ª± ph·ª• thu·ªôc v√†o c√°c l·ªõp c·ª• th·ªÉ, t·ª´ ƒë√≥ tƒÉng t√≠nh module v√† kh·∫£ nƒÉng t√°i s·ª≠ d·ª•ng.

<br>

üíª **V√≠ d·ª• 1:**
```cpp
#include <iostream>
#include <string>

using namespace std;

// Abstract class
class Sensor
{
    public:
        virtual void readData() = 0;
};

// Temperature class
class TemperatureSensor : public Sensor
{
    public:
        void readData() override
	{
            cout<<"reading temp data: "<<endl;
        }
};

// Humidity class
class HumiditySensor : public Sensor
{
    public:
        void readData() override
	{
            cout<<"reading humidity data: "<<endl;
        }
};

// Factory class (Creator)
class SensorFactory
{
    public:
        static Sensor* createSensor(const string& sensorType)
	{
            if(sensorType == "temp")
 	    {
                return new TemperatureSensor();     // tr·∫£ v·ªÅ ƒë·ªëi t∆∞·ª£ng TemperatureSensor
            }
            else if (sensorType == "humi")
	    {
                return new HumiditySensor();        // tr·∫£ v·ªÅ ƒë·ªëi t∆∞·ª£ng PressureSensor
            }
            else
	    {
                return nullptr;                     // tr·∫£ v·ªÅ con tr·ªè null
            }
        }
};


int main(int argc, char const *argv[])
{
    Sensor* sensor = SensorFactory::createSensor("humi");
    sensor->readData();
    return 0;
}
```

üìù **Abstract class** ``` Sensor ```: ƒê√¢y l√† l·ªõp c∆° s·ªü tr·ª´u t∆∞·ª£ng cho t·∫•t c·∫£ c√°c lo·∫°i c·∫£m bi·∫øn. L·ªõp n√†y ƒë·ªãnh nghƒ©a ph∆∞∆°ng th·ª©c readData() l√† ph∆∞∆°ng th·ª©c ·∫£o thu·∫ßn t√∫y (pure virtual), y√™u c·∫ßu c√°c l·ªõp con ph·∫£i tri·ªÉn khai n√≥.

üìù  C√°c l·ªõp con c·ª• th·ªÉ nh∆∞ ``` TemperatureSensor ```, ``` PressureSensor ```, v√† ``` HumiditySensor ``` tri·ªÉn khai ph∆∞∆°ng th·ª©c ``` readData() ``` theo c√°ch ri√™ng ƒë·ªÉ ƒë·ªçc d·ªØ li·ªáu t·ª´ c√°c c·∫£m bi·∫øn t∆∞∆°ng ·ª©ng.

üìù **Factory class** ``` SensorFactory ```: L·ªõp n√†y ch·ª©a m·ªôt ph∆∞∆°ng th·ª©c tƒ©nh ``` createSensor() ``` ƒë·ªÉ t·∫°o v√† tr·∫£ v·ªÅ ƒë·ªëi t∆∞·ª£ng c·∫£m bi·∫øn d·ª±a tr√™n lo·∫°i c·∫£m bi·∫øn ƒë∆∞·ª£c ch·ªâ ƒë·ªãnh qua chu·ªói k√Ω t·ª± ƒë·∫ßu v√†o. ƒê√¢y ch√≠nh l√† t√≠nh tr·ª´u t∆∞·ª£ng v√¨ ng∆∞·ªùi d√πng ch·ªâ ƒë∆∞·ª£c ph√©p truy·ªÅn v√†o t√™n c·∫£m bi·∫øn c√≤n qu√° tr√¨nh tri·ªÉn khai c·∫£m bi·∫øn nh∆∞ th·∫ø n√†o ƒë√£ b·ªã ·∫©n ƒëi.

üìù Trong h√†m main(), ta ch·ªâ c·∫ßn g·ªçi ph∆∞∆°ng th·ª©c ``` SensorFactory::createSensor() ``` v√† cung c·∫•p lo·∫°i c·∫£m bi·∫øn m√† ta c·∫ßn. Factory s·∫Ω tr·∫£ v·ªÅ ƒë·ªëi t∆∞·ª£ng c·∫£m bi·∫øn ph√π h·ª£p m√† kh√¥ng c·∫ßn kh·ªüi t·∫°o th·ªß c√¥ng t·ª´ng l·ªõp c·ª• th·ªÉ

<br>

üíª **V√≠ d·ª• 2:**
```cpp
#include <iostream>
#include <string>

using namespace std;

// Base class
class Sensor 
{
    public:
        // ph∆∞∆°ng th·ª©c ·∫£o thu·∫ßn t√∫y ƒë·ªçc d·ªØ li·ªáu c·∫£m bi·∫øn
        virtual void readData() = 0;
};

// Concrete product: temperature
class TemperatureSensor : public Sensor 
{
    public:
        // ƒê·ªçc d·ªØ li·ªáu t·ª´ c·∫£m bi·∫øn nhi·ªát ƒë·ªô
        void readData() override 
        {
            cout << "reading temp data..." << endl;
            // c·∫•u h√¨nh, logic x·ª≠ l√Ω
        }
};

// Concrete product: humidity
class HumiditySensor : public Sensor 
{
    public:
        // ƒê·ªçc d·ªØ li·ªáu t·ª´ c·∫£m bi·∫øn ƒë·ªô ·∫©m
        void readData() override 
        {
            cout << "reading humidity data..." << endl;
        }
};

// Concrete product: pressure
class PressureSensor : public Sensor 
{
    public:
        // ƒê·ªçc d·ªØ li·ªáu t·ª´ c·∫£m bi·∫øn √°p su·∫•t
        void readData() override 
        {
            cout << "reading pressure data..." << endl;
        }
};

// Concrete product: light
class LightSensor : public Sensor
{
    public:
        // ƒê·ªçc d·ªØ li·ªáu t·ª´ c·∫£m bi·∫øn √°p su·∫•t
        void readData() override 
        {
            cout << "reading light data..." << endl;
        }
};

// ƒê·ªãnh nghƒ©a c√°c lo·∫°i c·∫£m bi·∫øn
typedef enum 
{
    TEMPERATURE,
    PRESSURE,
    HUMIDITY,
    LIGHT
} SensorType;

// Sensor Factory ƒë·ªÉ t·∫°o ra c√°c ƒë·ªëi t∆∞·ª£ng c·∫£m bi·∫øn
class SensorFactory 
{
    public:
        // T·∫°o ƒë·ªëi t∆∞·ª£ng c·∫£m bi·∫øn d·ª±a tr√™n lo·∫°i c·∫£m bi·∫øn
        static Sensor* createSensor(SensorType type) 
        {
            switch (type) 
            {
                case SensorType::TEMPERATURE:
                    return new TemperatureSensor(); // 0xc8

                case SensorType::HUMIDITY:
                    return new HumiditySensor();    // 0xa1

                case SensorType::PRESSURE:
                    return new PressureSensor();    // 0xf4
                
                case SensorType::LIGHT:
                    return new LightSensor();       // 0x04

                default:
                    cout << "Invalid sensor type!\n";
                    return nullptr;
            }

            // if (type == "temp"){
            //     return new TemperatureSensor();
            // } else if (type == "humi"){
            //     return new HumiditySensor(); 
            // }
        }
};

int main(int argc, char const *argv[]) 
{
    Sensor* sensor1 = SensorFactory::createSensor(SensorType::TEMPERATURE);
    sensor1->readData();

    Sensor* sensor2 = SensorFactory::createSensor(SensorType::TEMPERATURE);
    sensor2->readData();

    auto sensor3 = SensorFactory::createSensor(SensorType::PRESSURE);
    sensor3->readData();

    auto sensor4 = SensorFactory::createSensor(SensorType::HUMIDITY);
    sensor4->readData();

    SensorFactory::createSensor(SensorType::LIGHT);

    return 0;
}
```
üìù Enum ``` SensorType ```: s·ª≠ d·ª•ng m·ªôt enum ƒë·ªÉ ƒë·∫°i di·ªán cho c√°c lo·∫°i c·∫£m bi·∫øn kh√°c nhau (Temperature, Pressure, Humidity). ƒêi·ªÅu n√†y gi√∫p gi·∫£m thi·ªÉu l·ªói li√™n quan ƒë·∫øn vi·ªác nh·∫≠p sai chu·ªói (string) v√† l√†m m√£ d·ªÖ b·∫£o tr√¨ h∆°n.

üìù **Factory Method** ``` createSensor() ```: method n√†y gi·ªù ƒë√¢y nh·∫≠n tham s·ªë ki·ªÉu SensorType (enum) thay v√¨ m·ªôt chu·ªói. D·ª±a tr√™n gi√° tr·ªã c·ªßa enum, n√≥ kh·ªüi t·∫°o v√† tr·∫£ v·ªÅ ƒë·ªëi t∆∞·ª£ng c·∫£m bi·∫øn t∆∞∆°ng ·ª©ng.

üìù Trong h√†m ``` main() ```, thay v√¨ s·ª≠ d·ª•ng chu·ªói ƒë·ªÉ ch·ªâ ƒë·ªãnh lo·∫°i c·∫£m bi·∫øn, ta truy·ªÅn v√†o m·ªôt gi√° tr·ªã c·ªßa SensorType enum, gi√∫p m√£ d·ªÖ hi·ªÉu v√† tr√°nh l·ªói kh√¥ng mong mu·ªën.

<br>

</p>
</details>

<details><summary><b>5. Decorator Pattern</b></summary>
<p>

Decorator Pattern l√† m·ªôt m·∫´u thi·∫øt k·∫ø thu·ªôc nh√≥m structural patterns, cho ph√©p th√™m c√°c ch·ª©c nƒÉng ho·∫∑c h√†nh vi m·ªõi cho m·ªôt ƒë·ªëi t∆∞·ª£ng m√† kh√¥ng c·∫ßn thay ƒë·ªïi c·∫•u tr√∫c c·ªßa l·ªõp ƒë·ªëi t∆∞·ª£ng ƒë√≥. Thay v√¨ k·∫ø th·ª´a ƒë·ªÉ m·ªü r·ªông t√≠nh nƒÉng, Decorator s·ª≠ d·ª•ng s·ª± k·∫øt h·ª£p c·ªßa ƒë·ªëi t∆∞·ª£ng ƒë·ªÉ th√™m c√°c h√†nh vi cho ƒë·ªëi t∆∞·ª£ng hi·ªán c√≥.

ƒê·∫∑c ƒëi·ªÉm c·ªßa Decorator Pattern:

- **T√≠nh linh ho·∫°t**: Decorator Pattern cho ph√©p th√™m h√†nh vi m·ªõi v√†o ƒë·ªëi t∆∞·ª£ng m·ªôt c√°ch linh ho·∫°t m√† kh√¥ng l√†m thay ƒë·ªïi c√°c ƒë·ªëi t∆∞·ª£ng kh√°c.
- **T√≠nh m·ªü r·ªông**: Decorator Pattern cho ph√©p m·ªü r·ªông t√≠nh nƒÉng m√† kh√¥ng c·∫ßn thay ƒë·ªïi m√£ g·ªëc.
- **D·ªÖ b·∫£o tr√¨**: B·∫°n c√≥ th·ªÉ d·ªÖ d√†ng b·ªï sung ho·∫∑c thay th·∫ø c√°c t√≠nh nƒÉng b·∫±ng c√°ch thay ƒë·ªïi c√°c decorator m√† kh√¥ng ·∫£nh h∆∞·ªüng ƒë·∫øn c√°c l·ªõp kh√°c.
- **Gi·∫£m s·ª± ph·ª©c t·∫°p c·ªßa k·∫ø th·ª´a**: Thay v√¨ t·∫°o ra nhi·ªÅu l·ªõp con ƒë·ªÉ m·ªü r·ªông h√†nh vi, Decorator Pattern cho ph√©p k·∫øt h·ª£p c√°c h√†nh vi m·ªôt c√°ch linh ho·∫°t b·∫±ng c√°ch x·∫øp ch·ªìng c√°c decorator.

<br>

```cpp
#include <iostream>

using namespace std;

class Shape 
{
    protected:
        string color;

    public:
        Shape(const string &color_ = "black") : color(color_){}

        virtual void draw() const 
        {
            cout << "Drawing a generic shape" << endl;
        }

        virtual double calculateArea() const 
        {
            return 0.0; 
        }
};

class Circle : public Shape 
{
    private:
        double radius;

    public:
        Circle(double r, const string &color_ = "black") 
            : radius(r), Shape(color_){}

        void draw() const override 
        {
            cout << "Drawing a Circle in color " << color << endl;
        }

        void setColor(const string& c) 
        {
            color = c;
        }

        string getColor() const 
        {
            return color;
        }

        double calculateArea() const override 
        {
            return 3.14 * radius * radius;
        }
};

class Rectangle : public Shape 
{
    private:
        double width, height;

    public:
        Rectangle(double w, double h, const string &color_ = "black") 
            : width(w), height(h), Shape(color_){}

        void draw() const override 
        {
            cout << "Drawing a Rectangle in color " << color << endl;
        }

        double calculateArea() const override 
        {
            return width * height;
        }
};

int main() 
{
    Shape *shapes[] = { new Circle(5, "red"), new Rectangle(4, 6, "yellow") };

    for (auto shape : shapes) 
    {
        shape->draw();
        cout << "Area: " << shape->calculateArea() << endl;
    }

    for (auto shape : shapes) 
    {
        delete shape;
    }

    return 0;
}
```

<br>

üíª **V√≠ d·ª• 1:**
```cpp

```

<br>

üíª **V√≠ d·ª• 2:**
```cpp
#include <iostream>

using namespace std;

/**
 * @class   Sensor
 * @brief   Base Component: L·ªõp c∆° s·ªü tr·ª´u t∆∞·ª£ng ƒë·∫°i di·ªán cho c·∫£m bi·∫øn.
 * @details ƒê·ªãnh nghƒ©a ph∆∞∆°ng th·ª©c ·∫£o readData ƒë·ªÉ c√°c l·ªõp k·∫ø th·ª´a 
 *          c√≥ th·ªÉ tri·ªÉn khai t√≠nh nƒÉng ƒë·ªçc d·ªØ li·ªáu t·ª´ c·∫£m bi·∫øn.
 */
class Sensor
{
    public:
        /********************************************************
         * @brief   Ph∆∞∆°ng th·ª©c ·∫£o ƒë·ªÉ ƒë·ªçc d·ªØ li·ªáu t·ª´ c·∫£m bi·∫øn.
         * @return  void
         ********************************************************/
        virtual void readData() const = 0;
};


/**
 * @class   TemperatureSensor
 * @brief   Concrete Component: L·ªõp c·∫£m bi·∫øn nhi·ªát ƒë·ªô c·ª• th·ªÉ, k·∫ø th·ª´a t·ª´ Sensor.
 * @details L·ªõp n√†y tri·ªÉn khai ph∆∞∆°ng th·ª©c readData ƒë·ªÉ ƒë·ªçc d·ªØ li·ªáu nhi·ªát ƒë·ªô.
 */
class TemperatureSensor : public Sensor
{
    public:
        /********************************************************
         * @brief  ƒê·ªçc d·ªØ li·ªáu nhi·ªát ƒë·ªô.
         * @return void
         ********************************************************/
        void readData() const override 
        {
            cout << "Reading temperature data...\n";
        }
};


/**
 * @class   SensorDecorator
 * @brief   Base Decorator: L·ªõp c∆° s·ªü cho c√°c decorator c·ªßa c·∫£m bi·∫øn.
 * @details L·ªõp n√†y ch·ª©a m·ªôt con tr·ªè ƒë·∫øn ƒë·ªëi t∆∞·ª£ng c·∫£m bi·∫øn g·ªëc 
 *          v√† tri·ªÉn khai c∆° b·∫£n ph∆∞∆°ng th·ª©c readData b·∫±ng c√°ch g·ªçi c·∫£m bi·∫øn g·ªëc.
 */
class SensorDecorator : public Sensor
{
    protected:
        Sensor *wrappedSensor;  /**< con tr·ªè ƒë·∫øn ƒë·ªëi t∆∞·ª£ng c·∫£m bi·∫øn g·ªëc */

    public:
        /********************************************************
         * @brief Kh·ªüi t·∫°o decorator v·ªõi m·ªôt c·∫£m bi·∫øn g·ªëc.
         * @param sensor Con tr·ªè ƒë·∫øn c·∫£m bi·∫øn g·ªëc c·∫ßn m·ªü r·ªông ch·ª©c nƒÉng.
         ********************************************************/
        SensorDecorator(Sensor* sensor): wrappedSensor(sensor){} 


        /********************************************************
         * @brief G·ªçi ph∆∞∆°ng th·ª©c ƒë·ªçc d·ªØ li·ªáu t·ª´ c·∫£m bi·∫øn g·ªëc.
         * @return void
         ********************************************************/
        void readData() const override 
        {
            wrappedSensor->readData();
        }
};


/**
 * @class   LoggingSensor
 * @brief   Concrete Decorator: L·ªõp decorator th√™m ch·ª©c nƒÉng ghi log cho c·∫£m bi·∫øn.
 * @details L·ªõp n√†y k·∫ø th·ª´a t·ª´ SensorDecorator v√† m·ªü r·ªông ch·ª©c nƒÉng b·∫±ng c√°ch
 *          ghi log d·ªØ li·ªáu sau khi ƒë·ªçc t·ª´ c·∫£m bi·∫øn g·ªëc.
 */
class LoggingSensor : public SensorDecorator
{
    public:
        /********************************************************
         * @brief Kh·ªüi t·∫°o LoggingSensor v·ªõi m·ªôt c·∫£m bi·∫øn g·ªëc.
         * @param sensor Con tr·ªè ƒë·∫øn c·∫£m bi·∫øn c·∫ßn th√™m ch·ª©c nƒÉng ghi log.
         ********************************************************/
        LoggingSensor(Sensor* sensor): SensorDecorator(sensor){}   


        /********************************************************
         * @brief   ƒê·ªçc d·ªØ li·ªáu t·ª´ c·∫£m bi·∫øn v√† ghi log sau ƒë√≥.
         * @return  void
         ********************************************************/
        void readData() const override
        {
            SensorDecorator::readData();
            logData();
        }


        /********************************************************
         * @brief Ghi log d·ªØ li·ªáu c·∫£m bi·∫øn.
         * @return void
         ********************************************************/
        void logData() const
        {
            cout << "Logging temperature data...\n";
            // code to log sensor data
        }
};


/**
 * @class   CheckLimitSensor
 * @brief   Concrete Decorator: L·ªõp decorator th√™m ch·ª©c nƒÉng ki·ªÉm tra gi·ªõi h·∫°n cho c·∫£m bi·∫øn.
 * @details L·ªõp n√†y k·∫ø th·ª´a t·ª´ SensorDecorator v√† m·ªü r·ªông ch·ª©c nƒÉng b·∫±ng c√°ch
 *          ki·ªÉm tra gi·ªõi h·∫°n sau khi ƒë·ªçc d·ªØ li·ªáu t·ª´ c·∫£m bi·∫øn g·ªëc.
 */
class CheckLimitSensor : public SensorDecorator
{
    public:
        /********************************************************
         * @brief Kh·ªüi t·∫°o CheckLimitSensor v·ªõi m·ªôt c·∫£m bi·∫øn g·ªëc.
         * @param sensor Con tr·ªè ƒë·∫øn c·∫£m bi·∫øn c·∫ßn th√™m ch·ª©c nƒÉng ki·ªÉm tra gi·ªõi h·∫°n.
         ********************************************************/
        CheckLimitSensor(Sensor* sensor): SensorDecorator(sensor){}


        /********************************************************
         * @brief  ƒê·ªçc d·ªØ li·ªáu t·ª´ c·∫£m bi·∫øn v√† ki·ªÉm tra gi·ªõi h·∫°n.
         * @return void
         ********************************************************/
        void readData() const override
        {
            SensorDecorator::readData();
            checkLimits();
        }


        /********************************************************
         * @brief  Ki·ªÉm tra gi·ªõi h·∫°n nhi·ªát ƒë·ªô.
         * @return void
         ********************************************************/
        void checkLimits() const
        {
            cout << "Checking temperature limits...\n";
            // code
        }
};


int main(int argc, char const *argv[])
{
    // Base sensor object
    Sensor *sensor = new TemperatureSensor();   // sensor -> 0x01 (object temperature)

    // Adding checking function via decorator
    sensor = new CheckLimitSensor(sensor);      // sensor -> 0xa2 (object checking), wrap -> 0x01

    // Adding logging function via decorator
    sensor = new LoggingSensor(sensor);         // sensor -> 0xb4 (object logging), wrap -> 0xa2

    // Reading data with all added function
    sensor->readData();

    delete sensor;

    return 0;
}

/**
 * sensor: 0xc8 (temperature)
 * sensor: 0xf4 (checkLimit)
 * sensor: 0xa1 (logging)
 * 0xf4 (0xc8)
 * 0xa1 (0xf4)
 */
```

üìù **Base Component** ``` Sensor ```: ƒê√¢y l√† giao di·ªán tr·ª´u t∆∞·ª£ng c·ªßa c·∫£m bi·∫øn, ƒë·ªãnh nghƒ©a ph∆∞∆°ng th·ª©c readData() m√† m·ªçi l·ªõp con ph·∫£i th·ª±c hi·ªán.

üìù **Concrete Component** ``` TemperatureSensor ```: class c·∫£m bi·∫øn nhi·ªát ƒë·ªô, th·ª±c hi·ªán vi·ªác ƒë·ªçc d·ªØ li·ªáu t·ª´ c·∫£m bi·∫øn th·ª±c t·∫ø.

üìù **Base Decorator** ``` SensorDecorator ```: ƒê√¢y l√† l·ªõp tr·ª´u t∆∞·ª£ng cho c√°c decorator, k·∫ø th·ª´a t·ª´ Sensor v√† ch·ª©a m·ªôt tham chi·∫øu ƒë·∫øn Sensor. L·ªõp n√†y cho ph√©p c√°c l·ªõp con m·ªü r·ªông h√†nh vi c·ªßa ƒë·ªëi t∆∞·ª£ng Sensor ƒë∆∞·ª£c g√≥i b√™n trong n√≥.

üìù **Concrete Decorator** ``` LoggingSensorDecorator ``` v√† ``` LimitCheckSensorDecorator ```: ƒê√¢y l√† c√°c l·ªõp decorator c·ª• th·ªÉ, ch√∫ng m·ªü r·ªông h√†nh vi c·ªßa c·∫£m bi·∫øn b·∫±ng c√°ch th√™m ch·ª©c nƒÉng ghi log (LoggingSensorDecorator) v√† ki·ªÉm tra gi·ªõi h·∫°n (LimitCheckSensorDecorator). M·ªói decorator v·∫´n g·ªçi h√†m readData() c·ªßa c·∫£m bi·∫øn g·ªëc, nh∆∞ng th√™m c√°c h√†nh vi b·ªï sung v√†o qu√° tr√¨nh.

<br>

üíª **V√≠ d·ª• 2:**
```cpp
#include <iostream>
#include <string>

using namespace std;

/**
 * @class   HMI
 * @brief   Interface c∆° b·∫£n cho h·ªá th·ªëng HUD.
 * @details ƒê·ªãnh nghƒ©a giao di·ªán hi·ªÉn th·ªã v√† c√°c ph∆∞∆°ng th·ª©c l·∫•y th√¥ng tin
 *          c∆° b·∫£n nh∆∞ t·ªëc ƒë·ªô v√† m·ª©c nhi√™n li·ªáu.
 */
class HMI
{
    public:
        virtual void display() const = 0;       /** Hi·ªÉn th·ªã th√¥ng tin l√™n m√†n h√¨nh HUD */
        virtual double getSpeed() const = 0;    /** ƒê·ªçc t·ªëc ƒë·ªô hi·ªán t·∫°i c·ªßa xe */
        virtual double getFuel() const = 0;     /** ƒê·ªçc m·ª©c nhi√™n li·ªáu hi·ªán t·∫°i */
};


/**
 * @class   HUD
 * @brief   L·ªõp c∆° b·∫£n hi·ªÉn th·ªã th√¥ng tin HUD.
 */
class HUD : public HMI
{
    private:
        double speed;       // t·ªëc ƒë·ªô xe
        double fuelLevel;   // m·ª©c nhi√™n li·ªáu

    public:
        HUD(double _speed, double _fuelLevel): speed(_speed), fuelLevel(_fuelLevel){}

        double getSpeed() const { return speed; }

        double getFuel() const { return fuelLevel; }

        void display() const override
        {
            cout << "Speed: " << getSpeed() << " km/h, Fuel Level: " << getFuel() << "%" << endl;
        }
};


/**
 * @class   HUDDecorator
 * @brief   L·ªõp c∆° s·ªü cho c√°c decorator c·ªßa HUD.
 */
class HUDDecorator : public HMI
{
    protected:
        HMI *wrapHMI;

    public:
        HUDDecorator(HMI *hmi): wrapHMI(hmi){}

        double getSpeed() const override
        {
            return wrapHMI->getSpeed();
        }

        double getFuel() const override
        {
            return wrapHMI->getFuel();
        }

        void display() const override
        {
            wrapHMI->display();
        }
};


/**
 * @class   SpeedWarning
 * @brief   Hi·ªÉn th·ªã c·∫£nh b√°o t·ªëc ƒë·ªô.
 */
class SpeedWarning : public HUDDecorator
{
    protected:
        double maxSpeed;    // t·ªëc ƒë·ªô t·ªëi ƒëa
        double minSpeed;    // t·ªëc ƒë·ªô t·ªëi thi·ªÉu

    public:
        SpeedWarning(HMI *hud, double maxLimit, double minLimit): HUDDecorator(hud), maxSpeed(maxLimit), minSpeed(minLimit){}

        void display() const override
        {
            HUDDecorator::display();
            warning();
        }

        double getMaxSpeed() const { return maxSpeed; }

        double getMinSpeed() const { return minSpeed; }

        void warning() const
        {
            double currentSpeed = getSpeed();
            if (currentSpeed > maxSpeed)
            {
                cout << "Warning: Speed Exceeds " << getMaxSpeed() << " km/h!" << endl;
            } 
            else if (currentSpeed < minSpeed)
            {
                cout << "Warning: Speed Below " << getMinSpeed() << " km/h" << endl;
            }
        }
};


/**
 * @class   FuelWarning
 * @brief   Hi·ªÉn th·ªã c·∫£nh b√°o nhi√™n li·ªáu.
 */
class FuelWarning : public HUDDecorator
{
    protected:
        double fuelThreshold; // Ng∆∞·ª°ng c·∫£nh b√°o nhi√™n li·ªáu

    public:
        FuelWarning(HMI *hud, double threshold): HUDDecorator(hud), fuelThreshold(threshold){}

        void display() const override
        {
            HUDDecorator::display();
            warning();
        }

        void warning() const 
        {
            double currentFuel = getFuel();

            if (currentFuel < fuelThreshold) 
            {
                cout << "Warning: Fuel Level Low (" << currentFuel << "%)!" << endl;
            }
        }
};


/**
 * @class   Color
 * @brief   Hi·ªÉn th·ªã th√¥ng tin v·ªõi m√†u s·∫Øc.
 */
class Color : public HUDDecorator
{
    private:
        string RedColor;    // m√†u ƒë·ªè cho v∆∞·ª£t qu√° t·ªëc ƒë·ªô
        string YellowColor; // m√†u v√†ng cho d∆∞·ªõi t·ªëc ƒë·ªô quy ƒë·ªãnh

    public:
        Color(HMI *hud, const string &_color1, const string &_color2)
            : HUDDecorator(hud), RedColor(_color1), YellowColor(_color2){}

        void display() const override
        {
            HUDDecorator::display();
            addColor();
        }

        void addColor() const
        {
            double currentSpeed = getSpeed();
            const SpeedWarning *sw = dynamic_cast<const SpeedWarning*>(wrapHMI);

            if (sw)
            {
                if (currentSpeed > sw->getMaxSpeed())
                {
                    cout << "Display color: " << RedColor << endl;
                } 
                else if (currentSpeed < sw->getMinSpeed())
                {
                    cout << "Display color: " << YellowColor << endl;
                }
            }
        }
};

int main(int argc, char const *argv[])
{   
    double speed = 120;     // T·ªëc ƒë·ªô hi·ªán t·∫°i (km/h)
    double fuel  = 10;      // M·ª©c nhi√™n li·ªáu hi·ªán t·∫°i (%)

    // T·∫°o ƒë·ªëi t∆∞·ª£ng HUD
    HMI *hud = new HUD(speed, fuel);

    // Th√™m t√≠nh nƒÉng
    hud = new SpeedWarning(hud, 100, 40);
    hud = new Color(hud, "Red", "Yellow");
    hud = new FuelWarning(hud, 20);

    // Hi·ªÉn th·ªã th√¥ng tin
    hud->display();

    delete hud;

    return 0;
}
```

<br>

</p>
</details>

<details><summary><b>6. Model-View-Presenter (MVP) Pattern</b></summary>
<p>

MVP (Model - View - Presenter) l√† m·ªôt m·∫´u thi·∫øt k·∫ø thu·ªôc nh√≥m Behavioral, ph·ªï bi·∫øn trong l·∫≠p tr√¨nh giao di·ªán ng∆∞·ªùi d√πng (UI) v√† ph√°t tri·ªÉn ·ª©ng d·ª•ng. MVP t√°ch bi·ªát c√°c th√†nh ph·∫ßn c·ªßa ·ª©ng d·ª•ng th√†nh ba ph·∫ßn ch√≠nh: **Model**, **View**, v√† **Presenter**. C·∫•u tr√∫c n√†y gi√∫p d·ªÖ d√†ng qu·∫£n l√Ω, ki·ªÉm th·ª≠, v√† b·∫£o tr√¨ m√£ ngu·ªìn.

- ``` Model ```: Ch·ª©a logic li√™n quan ƒë·∫øn d·ªØ li·ªáu c·ªßa ·ª©ng d·ª•ng, bao g·ªìm c√°c ƒë·ªëi t∆∞·ª£ng, c∆° s·ªü d·ªØ li·ªáu, v√† giao ti·∫øp v·ªõi c√°c API kh√°c.
- ``` View ```: Hi·ªÉn th·ªã giao di·ªán (Interface) v√† nh·∫≠n t∆∞∆°ng t√°c t·ª´ ng∆∞·ªùi d√πng (nh∆∞ nh·∫≠p li·ªáu, b·∫•m n√∫t). 
- ``` Presenter ```: L√† c·∫ßu n·ªëi gi·ªØa Model v√† View, ch·ªãu tr√°ch nhi·ªám x·ª≠ l√Ω logic, ƒëi·ªÅu ph·ªëi d·ªØ li·ªáu t·ª´ Model ƒë·∫øn View v√† ng∆∞·ª£c l·∫°i.

**Lu·ªìng ho·∫°t ƒë·ªông c·ªßa MVP Pattern:**

- Ng∆∞·ªùi d√πng t∆∞∆°ng t√°c v·ªõi giao di·ªán ng∆∞·ªùi d√πng (View).
- View chuy·ªÉn s·ª± ki·ªán n√†y cho Presenter.
- Presenter x·ª≠ l√Ω y√™u c·∫ßu b·∫±ng c√°ch l·∫•y d·ªØ li·ªáu t·ª´ Model.
- Model x·ª≠ l√Ω d·ªØ li·ªáu v√† tr·∫£ v·ªÅ k·∫øt qu·∫£ cho Presenter.
- Presenter ti·∫øp t·ª•c c·∫≠p nh·∫≠t View v·ªõi d·ªØ li·ªáu ƒë√£ x·ª≠ l√Ω t·ª´ Model.

<br>

üíª **V√≠ d·ª• 1:**
```cpp
#include <iostream>
#include <string>

using namespace std;

/**
 * @class   SinhVienModel
 * @brief   Class l∆∞u tr·ªØ th√¥ng tin c·ªßa m·ªôt sinh vi√™n.
 * @details Class n√†y ch·ª©a c√°c thu·ªôc t√≠nh c∆° b·∫£n c·ªßa sinh vi√™n, bao g·ªìm t√™n, tu·ªïi v√† m√£ s·ªë sinh vi√™n.
 *          Class n√†y cung c·∫•p c√°c ph∆∞∆°ng th·ª©c ƒë·ªÉ truy c·∫≠p v√† thay ƒë·ªïi th√¥ng tin sinh vi√™n.
 */
class SinhVienModel 
{
    private:
        string name;      /**< T√™n c·ªßa sinh vi√™n  */
        int age;          /**< Tu·ªïi c·ªßa sinh vi√™n */
        string studentId; /**< M√£ s·ªë sinh vi√™n    */

    public:
        /**
         * @brief Constructor kh·ªüi t·∫°o th√¥ng tin sinh vi√™n.
         * @param name T√™n c·ªßa sinh vi√™n.
         * @param age Tu·ªïi c·ªßa sinh vi√™n.
         * @param studentId M√£ s·ªë sinh vi√™n c·ªßa sinh vi√™n.
         */
        SinhVienModel(const string& name, int age, const string& studentId) : name(name), age(age), studentId(studentId) {}

        /**
         * @brief C·∫≠p nh·∫≠t t√™n c·ªßa sinh vi√™n.
         * @param newName T√™n m·ªõi c·ªßa sinh vi√™n.
         */
        void setName(const string& newName) 
        {
            name = newName;
        }

        /**
         * @brief C·∫≠p nh·∫≠t tu·ªïi c·ªßa sinh vi√™n.
         * @param newAge Tu·ªïi m·ªõi c·ªßa sinh vi√™n.
         */
        void setAge(int newAge) 
        {
            age = newAge;
        }

        /**
         * @brief C·∫≠p nh·∫≠t m√£ s·ªë sinh vi√™n.
         * @param newStudentId M√£ s·ªë sinh vi√™n m·ªõi.
         */
        void setStudentId(const string& newStudentId)
        {
            studentId = newStudentId;
        }

        /**
         * @brief  L·∫•y t√™n c·ªßa sinh vi√™n.
         * @return string: T√™n c·ªßa sinh vi√™n.
         */
        string getName() const 
        {
            return name;
        }

        /**
         * @brief  L·∫•y tu·ªïi c·ªßa sinh vi√™n.
         * @return int: Tu·ªïi c·ªßa sinh vi√™n.
         */
        int getAge() const 
        {
            return age;
        }

        /**
         * @brief  L·∫•y m√£ s·ªë sinh vi√™n.
         * @return string: M√£ s·ªë sinh vi√™n.
         */
        string getStudentId() const 
        {
            return studentId;
        }
};

/**
 * @class   SinhVienView
 * @brief   Class qu·∫£n l√Ω giao di·ªán hi·ªÉn th·ªã v√† nh·∫≠p li·ªáu cho sinh vi√™n.
 * @details Class n√†y ch·ªãu tr√°ch nhi·ªám hi·ªÉn th·ªã th√¥ng tin sinh vi√™n ra m√†n h√¨nh
 *          v√† l·∫•y th√¥ng tin sinh vi√™n t·ª´ ng∆∞·ªùi d√πng th√¥ng qua giao di·ªán console.
 */
class SinhVienView 
{
    public:
        /**
         * @brief Hi·ªÉn th·ªã th√¥ng tin sinh vi√™n l√™n console.
         * @param name T√™n c·ªßa sinh vi√™n.
         * @param age Tu·ªïi c·ªßa sinh vi√™n.
         * @param studentId M√£ s·ªë sinh vi√™n.
         */
        void displayStudentInfo(const string& name, int age, const string& studentId) 
        {
            cout << "Th√¥ng tin sinh vi√™n:" << endl;
            cout << "T√™n: " << name << endl;
            cout << "Tu·ªïi: " << age << endl;
            cout << "M√£ s·ªë sinh vi√™n: " << studentId << endl;
        }

        /**
         * @brief Nh·∫≠n th√¥ng tin sinh vi√™n t·ª´ ng∆∞·ªùi d√πng qua console.
         * @param name Tham chi·∫øu ƒë·∫øn bi·∫øn l∆∞u tr·ªØ t√™n sinh vi√™n.
         * @param age Tham chi·∫øu ƒë·∫øn bi·∫øn l∆∞u tr·ªØ tu·ªïi sinh vi√™n.
         * @param studentId Tham chi·∫øu ƒë·∫øn bi·∫øn l∆∞u tr·ªØ m√£ s·ªë sinh vi√™n.
         */
        void inputStudentInfo(string& name, int& age, string& studentId) 
        {
            cout << "Nh·∫≠p th√¥ng tin sinh vi√™n:" << endl;

            cout << "T√™n: ";
            getline(cin, name);

            cout << "Tu·ªïi: ";
            cin >> age;
            cin.ignore();  // B·ªè qua k√Ω t·ª± newline trong buffer

            cout << "M√£ s·ªë sinh vi√™n: ";
            getline(cin, studentId);
        }
};

/**
 * @class   SinhVienPresenter
 * @brief   Class ƒë√≥ng vai tr√≤ trung gian gi·ªØa SinhVienModel v√† SinhVienView.
 * @details Class n√†y ƒëi·ªÅu ph·ªëi lu·ªìng d·ªØ li·ªáu gi·ªØa Model v√† View. N√≥ c·∫≠p nh·∫≠t d·ªØ li·ªáu t·ª´ ng∆∞·ªùi d√πng v√†o Model
 *          th√¥ng qua View v√† hi·ªÉn th·ªã th√¥ng tin t·ª´ Model l√™n View.
 */
class SinhVienPresenter 
{
    private:
        SinhVienModel& model; /**< Tham chi·∫øu ƒë·∫øn ƒë·ªëi t∆∞·ª£ng SinhVienModel ƒë·ªÉ l∆∞u tr·ªØ d·ªØ li·ªáu sinh vi√™n */
        SinhVienView& view;   /**< Tham chi·∫øu ƒë·∫øn ƒë·ªëi t∆∞·ª£ng SinhVienView ƒë·ªÉ qu·∫£n l√Ω giao di·ªán hi·ªÉn th·ªã v√† nh·∫≠p li·ªáu */

    public:
        /**
         * @brief Constructor kh·ªüi t·∫°o presenter v·ªõi model v√† view.
         * @param m Tham chi·∫øu ƒë·∫øn SinhVienModel.
         * @param v Tham chi·∫øu ƒë·∫øn SinhVienView.
         */
        SinhVienPresenter(SinhVienModel& m, SinhVienView& v) : model(m), view(v) {}

        /**
         * @brief   C·∫≠p nh·∫≠t th√¥ng tin sinh vi√™n th√¥ng qua giao di·ªán ng∆∞·ªùi d√πng.
         * @details Ph∆∞∆°ng th·ª©c n√†y l·∫•y d·ªØ li·ªáu t·ª´ ng∆∞·ªùi d√πng qua View v√† c·∫≠p nh·∫≠t v√†o Model.
         */
        void updateStudentInfo() 
        {
            string name;
            int age;
            string studentId;
            
            view.inputStudentInfo(name, age, studentId);
            model.setName(name);
            model.setAge(age);
            model.setStudentId(studentId);
        }

        /**
         * @brief   Hi·ªÉn th·ªã th√¥ng tin sinh vi√™n ra giao di·ªán ng∆∞·ªùi d√πng.
         * @details Ph∆∞∆°ng th·ª©c n√†y l·∫•y d·ªØ li·ªáu t·ª´ Model v√† g·ª≠i ƒë·∫øn View ƒë·ªÉ hi·ªÉn th·ªã.
         */
        void showStudentInfo() 
        {
            view.displayStudentInfo(model.getName(), model.getAge(), model.getStudentId());
        }
};


int main() 
{
    SinhVienModel model("Tu·∫•n", 20, "HTN123");  /**< T·∫°o model v·ªõi th√¥ng tin sinh vi√™n m·∫∑c ƒë·ªãnh */
    SinhVienView view;                          /**< T·∫°o view ƒë·ªÉ qu·∫£n l√Ω giao di·ªán */
    SinhVienPresenter presenter(model, view);   /**< T·∫°o presenter ƒë·ªÉ ƒëi·ªÅu ph·ªëi model v√† view */

    int choice;
    do{
        cout << "\n1. Hi·ªÉn th·ªã th√¥ng tin sinh vi√™n" << std::endl;
        cout << "2. C·∫≠p nh·∫≠t th√¥ng tin sinh vi√™n" << std::endl;
        cout << "3. Tho√°t" << std::endl;
        cout << "Nh·∫≠p l·ª±a ch·ªçn: ";
        cin >> choice;
        cin.ignore();

        switch (choice) 
        {
            case 1:
                presenter.showStudentInfo();
                break;
                
            case 2:
                presenter.updateStudentInfo();
                break;

            case 3:
                cout << "Tho√°t ch∆∞∆°ng tr√¨nh." << endl;
                break;

            default:
                cout << "L·ª±a ch·ªçn kh√¥ng h·ª£p l·ªá!" << endl;
        }
        
    } while (choice != 3);

    return 0;
}
```

üìù T·∫°o m·ªôt ƒë·ªëi t∆∞·ª£ng SinhVienModel v·ªõi th√¥ng tin sinh vi√™n ban ƒë·∫ßu.

üìù ƒê·ªëi t∆∞·ª£ng SinhVienView ƒë∆∞·ª£c t·∫°o ƒë·ªÉ x·ª≠ l√Ω hi·ªÉn th·ªã v√† nh·∫≠p d·ªØ li·ªáu t·ª´ ng∆∞·ªùi d√πng.

üìù ƒê·ªëi t∆∞·ª£ng SinhVienPresenter ƒë∆∞·ª£c kh·ªüi t·∫°o, nh·∫≠n ƒë·ªëi t∆∞·ª£ng SinhVienModel v√† SinhVienView l√†m ƒë·ªëi s·ªë ƒë·ªÉ l√†m c·∫ßu n·ªëi gi·ªØa Model v√† View.

üìù C√≥ 3 l·ª±a ch·ªçn cho ng∆∞·ªùi d√πng 

üìù L·ª±a ch·ªçn 1: Hi·ªÉn th·ªã th√¥ng tin sinh vi√™n

- Ch∆∞∆°ng tr√¨nh g·ªçi ph∆∞∆°ng th·ª©c presenter.showStudentInfo().

- Ph∆∞∆°ng th·ª©c showStudentInfo() trong SinhVienPresenter s·∫Ω l·∫•y th√¥ng tin t·ª´ Model (t√™n, tu·ªïi, m√£ s·ªë sinh vi√™n) qua c√°c ph∆∞∆°ng th·ª©c getName(), getAge(), v√† getStudentId() c·ªßa SinhVienModel.

- Presenter chuy·ªÉn d·ªØ li·ªáu n√†y cho View qua ph∆∞∆°ng th·ª©c displayStudentInfo() c·ªßa SinhVienView ƒë·ªÉ hi·ªÉn th·ªã th√¥ng tin ra m√†n h√¨nh

üìù L·ª±a ch·ªçn 2: C·∫≠p nh·∫≠t th√¥ng tin sinh vi√™n

- Ch∆∞∆°ng tr√¨nh g·ªçi ph∆∞∆°ng th·ª©c presenter.updateStudentInfo().

- Ph∆∞∆°ng th·ª©c updateStudentInfo() trong SinhVienPresenter s·∫Ω y√™u c·∫ßu View thu th·∫≠p th√¥ng tin m·ªõi t·ª´ ng∆∞·ªùi d√πng th√¥ng qua inputStudentInfo().

- View nh·∫≠n c√°c gi√° tr·ªã m·ªõi t·ª´ ng∆∞·ªùi d√πng v√† tr·∫£ l·∫°i cho Presenter.

- Presenter sau ƒë√≥ g·ªçi c√°c ph∆∞∆°ng th·ª©c setName(), setAge(), v√† setStudentId() trong SinhVienModel ƒë·ªÉ c·∫≠p nh·∫≠t th√¥ng tin m·ªõi v√†o Model.

üìù L·ª±a ch·ªçn 3: Tho√°t ch∆∞∆°ng tr√¨nh

<br>

</p>
</details>

</p>
</details>

<br>

<details><summary><b>Multithreading</b></summary>
<p>

<details><summary><b>1. Gi·ªõi thi·ªáu v·ªÅ Process</b></summary>
<p>

- L√† 1 ch∆∞∆°ng tr√¨nh ƒëang ch·∫°y tr√™n h·ªá th·ªëng ho·∫∑c m·ªôt t·∫≠p h·ª£p c√°c c√¥ng vi·ªác ƒë∆∞·ª£c th·ª±c hi·ªán tr√™n m√°y t√≠nh.
- M·ªói process c√≥ v√πng nh·ªõ ri√™ng bi·ªát.
- C√≥ th·ªÉ thao t√°c v·ªõi nh·ªØng ph·∫ßn c·ª©ng b√™n d∆∞·ªõi (b√†n ph√≠m, chu·ªôt, ...)
- Vi·ªác giao ti·∫øp gi·ªØa c√°c process th∆∞·ªùng kh√≥ khƒÉn v√† y√™u c·∫ßu c√°c ph∆∞∆°ng th·ª©c nh∆∞ IPC (Inter-Process Communication).
- M·ªói ti·∫øn tr√¨nh c√≥ th·ªÉ bao g·ªìm m·ªôt ho·∫∑c nhi·ªÅu lu·ªìng (thread) c·ªßa vi·ªác th·ª±c hi·ªán c√¥ng vi·ªác.

![image](https://github.com/user-attachments/assets/998179b3-a5ad-4b8d-9416-413d3fa1181e)

**V√≠ d·ª• 1:**

- Khi m·ªü m·ªôt c·ª≠a s·ªï Google Chrome th√¨ ƒë√≥ l√† m·ªôt **ti·∫øn tr√¨nh ch√≠nh** ƒë∆∞·ª£c kh·ªüi t·∫°o.
- Khi b·∫°n m·ªü nhi·ªÅu **tab** trong Chrome th√¨ m·ªói tab ƒë∆∞·ª£c g·ªçi l√† **ti·∫øn tr√¨nh con (Child Process)**, Chrome s·ª≠ d·ª•ng m√¥ h√¨nh n√†y ƒë·ªÉ c√¥ l·∫≠p c√°c tab nh·∫±m ƒë·∫£m b·∫£o r·∫±ng n·∫øu m·ªôt tab g·∫∑p s·ª± c·ªë, n√≥ kh√¥ng l√†m ·∫£nh h∆∞·ªüng ƒë·∫øn c√°c tab kh√°c. ƒêi·ªÅu n√†y c≈©ng tƒÉng c∆∞·ªùng b·∫£o m·∫≠t v√¨ m·ªói ti·∫øn tr√¨nh c√≥ kh√¥ng gian b·ªô nh·ªõ ri√™ng.
- ·ªû m·ªói tab, n·∫øu c√≥ nhi·ªÅu t√°c v·ª• nh∆∞ download t√†i li·ªáu v·ªÅ m√°y t√≠nh, upload t√†i li·ªáu t·ª´ m√°y t√≠nh, hi·ªÉn th·ªã h√¨nh ·∫£nh, v.v th√¨ m·ªói t√°c v·ª• ƒë√≥ ƒë∆∞·ª£c g·ªçi l√† m·ªôt lu·ªìng (thread).

<br>

**V√≠ d·ª• 2:**

- Khi b·∫°n kh·ªüi ƒë·ªông ·ª©ng d·ª•ng Zalo, h·ªá ƒëi·ªÅu h√†nh t·∫°o ra m·ªôt ti·∫øn tr√¨nh ch√≠nh ƒë·ªÉ qu·∫£n l√Ω to√†n b·ªô ·ª©ng d·ª•ng. ƒê√¢y l√† ti·∫øn tr√¨nh m·∫π, ch·ªãu tr√°ch nhi·ªám:

	+ Qu·∫£n l√Ω giao di·ªán ch√≠nh c·ªßa ·ª©ng d·ª•ng.
 	+ ƒêi·ªÅu ph·ªëi c√°c ti·∫øn tr√¨nh con v√† c√°c lu·ªìng b√™n trong.
	+ K·∫øt n·ªëi v·ªõi m√°y ch·ªß c·ªßa Zalo ƒë·ªÉ g·ª≠i/nh·∫≠n d·ªØ li·ªáu.

- Ti·∫øn tr√¨nh con:

	+ M·ªôt ti·∫øn tr√¨nh ƒë·ªÉ x·ª≠ l√Ω tin nh·∫Øn.
	+ M·ªôt ti·∫øn tr√¨nh ƒë·ªÉ x·ª≠ l√Ω cu·ªôc g·ªçi (√¢m thanh v√† video).
	+ M·ªôt ti·∫øn tr√¨nh ƒë·ªÉ ƒë·ªìng b·ªô h√≥a th√¥ng b√°o v·ªõi m√°y ch·ªß.

- C√°c lu·ªìng trong t·ª´ng ti·∫øn tr√¨nh:

	+ Lu·ªìng giao di·ªán ng∆∞·ªùi d√πng (UI Thread): X·ª≠ l√Ω giao di·ªán v√† t∆∞∆°ng t√°c c·ªßa ng∆∞·ªùi d√πng.
	+ Lu·ªìng m·∫°ng: K·∫øt n·ªëi v·ªõi m√°y ch·ªß Zalo ƒë·ªÉ g·ª≠i/nh·∫≠n d·ªØ li·ªáu.
	+ Lu·ªìng nh·∫≠p d·ªØ li·ªáu.
 	+ Lu·ªìng truy·ªÅn d·ªØ li·ªáu.
  	+ Lu·ªìng nh·∫≠n d·ªØ li·ªáu.   

<br>

**V√≠ d·ª• 3:**

- Khi m·ªü IDE VSCode th√¨ ƒë√¢y l√† **ti·∫øn tr√¨nh ch√≠nh**.
- Khi b·∫°n ch·∫°y c√°c file ``` .c, .cpp, .py, .js, v.v ``` (sau khi bi√™n d·ªãch) th√¨ m·ªói file s·∫Ω t·∫°o ra m·ªôt ti·∫øn tr√¨nh con duy nh·∫•t ƒë∆∞·ª£c h·ªá ƒëi·ªÅu h√†nh t·∫°o ra ƒë·ªÉ th·ª±c thi ch∆∞∆°ng tr√¨nh c·ªßa b·∫°n.
- M·ªói ti·∫øn tr√¨nh con ch√≠nh l√† to√†n b·ªô ch∆∞∆°ng tr√¨nh ƒë√£ vi·∫øt, bao g·ªìm **lu·ªìng ch√≠nh** v√† c√°c **lu·ªìng ph·ª•** b√™n trong.

<br>

</p>
</details>

<details><summary><b>2. Gi·ªõi thi·ªáu v·ªÅ Thread</b></summary>
<p>

- Thread l√† ƒë∆°n v·ªã nh·ªè h∆°n c·ªßa m·ªôt process, c√≤n ƒë∆∞·ª£c g·ªçi l√† "lu·ªìng". M·ªôt process c√≥ th·ªÉ ch·ª©a nhi·ªÅu thread, v√† c√°c thread n√†y chia s·∫ª c√πng kh√¥ng gian ƒë·ªãa ch·ªâ b·ªô nh·ªõ c·ªßa process ƒë√≥.
- C√°c lu·ªìng trong c√πng m·ªôt ti·∫øn tr√¨nh c√≥ th·ªÉ chia s·∫ª c√πng m·ªôt kh√¥ng gian b·ªô nh·ªõ v√† c√°c t√†i nguy√™n kh√°c c·ªßa ti·∫øn tr√¨nh, bao g·ªìm c·∫£ bi·∫øn to√†n c·ª•c v√† bi·∫øn c·ª•c b·ªô.

<details><summary><b>üìö T·∫°o v√† ch·∫°y nhi·ªÅu thread</b></summary>
<p>

- c√∫ ph√°p: 

    ``` std::thread thread_id(function, args...) ```

    + ``` std::thread ```: class d√πng ƒë·ªÉ t·∫°o, kh·ªüi ch·∫°y, qu·∫£n l√Ω c√°c lu·ªìng

    + ``` thread_id ```: t√™n ƒë·∫°i di·ªán cho lu·ªìng

    + ``` function ```: h√†m (method) ho·∫∑c lambda m√† lu·ªìng s·∫Ω th·ª±c thi

    + ``` args... ```: danh s√°ch tham s·ªë truy·ªÅn v√†o h√†m

<br>

üíª **V√≠ d·ª•:**
```cpp
#include <iostream>
#include <thread>
#include <chrono>

using namespace std;

void delay(uint32_t time)
{
    this_thread::sleep_for(chrono::seconds(time));
    /**
     * H√†m n√†y m√¥ ph·ªèng m·ªôt t√°c v·ª• t·∫°m d·ª´ng (delay) trong kho·∫£ng th·ªùi gian (us, ms, s, v.v).
     * std::this_thread::sleep_for() t·∫°m d·ª´ng lu·ªìng hi·ªán t·∫°i trong th·ªùi gian ƒë∆∞·ª£c ch·ªâ ƒë·ªãnh.
     * V√≠ d·ª•, n·∫øu time = 1, lu·ªìng s·∫Ω b·ªã t·∫°m d·ª´ng trong 1 gi√¢y.
     */
}

void task1(uint32_t time)
{
    int i = 0;
    for (int j = 0; j < 8; j++)
    {
        cout << "task 1, i = " << i++ << endl;
        delay(time);
    }
}

void task2(uint32_t time)
{
    int i = 0;
    for (int j = 0; j < 8; j++)
    {
        cout << "task 2, i = " << i++ << endl;
        delay(time);
    }
}

int main(int argc, char const *argv[])
{
    thread t1(task1, 1);     // t1: ƒë·∫°i di·ªán cho lu·ªìng 1
    thread t2(task2, 3);     // t2: ƒë·∫°i di·ªán cho lu·ªìng 2
    
    while(1)
    {
        cout << "This is main thread\n";
        delay(1);
    }

    return 0;
}
```
üìù Khi lu·ªìng ch√≠nh (main thread) th√¨ to√†n b·ªô ti·∫øn tr√¨nh con c≈©ng s·∫Ω k·∫øt th√∫c.

üìù Trong m√£ ngu·ªìn tr√™n, n·∫øu thay ``` while(1) ``` b·∫±ng ``` for (int i=0; i<3; i++) ``` th√¨ khi ch·∫°y s·∫Ω g·∫∑p l·ªói ``` terminate called without an active exception ```. ƒê√¢y l√† l·ªói xung ƒë·ªôt v√¨ lu·ªìng ch√≠nh k·∫øt th√∫c tr∆∞·ªõc c√°c lu·ªìng ph·ª•, trong khi lu·ªìng ph·ª• v·∫´n c√≤n ch·∫°y v√† c√≥ th·ªÉ tr·∫£ v·ªÅ k·∫øt qu·∫£ (t√†i nguy√™n c·ªßa lu·ªìng ch∆∞a ƒë∆∞·ª£c gi·∫£i ph√≥ng).

<br>

</p>
</details>

<details><summary><b>üìö Qu·∫£n l√Ω c√°c thread</b></summary>
<p>

<details><summary><b>üìöüìö join()</b></summary>
<p>

- D√πng cho c√°c lu·ªìng ph·ª•, ƒë·ªìng b·ªô h√≥a lu·ªìng ph·ª• v·ªõi lu·ªìng ch√≠nh (main thread).
- Khi 1 lu·ªìng ph·ª• g·ªçi ph∆∞∆°ng th·ª©c ``` join() ```, n√≥ ƒë·∫£m b·∫£o r·∫±ng lu·ªìng hi·ªán t·∫°i s·∫Ω kh√¥ng ti·∫øp t·ª•c th·ª±c hi·ªán cho ƒë·∫øn khi lu·ªìng ƒë∆∞·ª£c join() ho√†n t·∫•t. ƒêi·ªÅu n√†y h·ªØu √≠ch khi b·∫°n c·∫ßn ch·∫Øc ch·∫Øn r·∫±ng m·ªôt lu·ªìng ƒë√£ ho√†n th√†nh c√¥ng vi·ªác tr∆∞·ªõc khi ti·∫øp t·ª•c v·ªõi lu·ªìng ch√≠nh.
- C√≥ th·ªÉ l·∫•y k·∫øt qu·∫£ tr·∫£ v·ªÅ c·ªßa lu·ªìng ph·ª• sau khi ``` join ``` k·∫øt th√∫c.
- M·ªói lu·ªìng ch·ªâ c√≥ th·ªÉ g·ªçi method join() duy nh·∫•t 1 l·∫ßn.
- N·∫øu m·ªôt lu·ªìng ƒë√£ ƒë∆∞·ª£c join(), n√≥ kh√¥ng c√≤n kh·∫£ nƒÉng tham gia (joinable) n·ªØa.

<br>

üíª **V√≠ d·ª•:**
```cpp
#include <iostream>
#include <thread>
#include <chrono>

using namespace std;

int result1 = 0;
int result2 = 0;

void delay(uint32_t time)
{
    this_thread::sleep_for(chrono::seconds(time));
}

void task1(uint32_t time)
{
    int i = 0;
    for (int j = 0; j < 5; j++)
    {
        cout << "task 1, i = " << i++ << endl;
        delay(time);
    }

    result1 = i;
}

void task2(uint32_t time)
{
    int i = 0;
    for (int j = 0; j < 5; j++)
    {
        cout << "task 2, i = " << i++ << endl;
        delay(time);
    }

    result2 = i;
}

int main(int argc, char const *argv[])
{
    thread t1(task1, 1);     // t1: ƒë·∫°i di·ªán cho lu·ªìng 1
    thread t2(task2, 2);     // t2: ƒë·∫°i di·ªán cho lu·ªìng 2

    t1.join();
    t2.join();

    cout << "K·∫øt qu·∫£ cu·ªëi c√πng c·ªßa lu·ªìng 1: " << result1 << endl;
    cout << "K·∫øt qu·∫£ cu·ªëi c√πng c·ªßa lu·ªìng 2: " << result2 << endl;
    
    for (int i=0; i<7; i++)
    {
        cout << "This is main thread\n";
        delay(1);
    }

    return 0;
}
```

üìù ƒê·∫∑t lu·ªìng ch√≠nh ``` (while(1)) ``` sau khi g·ªçi join().

üìù Lu·ªìng 1 (th·ª±c thi h√†m ``` task1 ```) v√† lu·ªìng 2 (th·ª±c thi h√†m ``` task2 ```) s·∫Ω ch·∫°y song song v·ªõi nhau.

üìù Lu·ªìng ch√≠nh ``` (while(1)) ``` ch·ªâ b·∫Øt ƒë·∫ßu ch·∫°y khi lu·ªìng 1 k·∫øt th√∫c v√† lu·ªìng 2 c≈©ng k·∫øt th√∫c. ƒêi·ªÅu n√†y s·∫Ω ƒë·∫£m b·∫£o kh√¥ng x·∫£y ra xung ƒë·ªôt v√¨ c√°c lu·ªìng ph·ª• ƒë√£ k·∫øt th√∫c tr∆∞·ªõc lu·ªìng ch√≠nh.


</p>
</details>

<details><summary><b>üìöüìö joinable()</b></summary>
<p>

- Ki·ªÉm tra xem m·ªôt thread ƒë√£ k·∫øt th√∫c ho·∫∑c ƒë√£ g·ªçi join() hay ch∆∞a. N·∫øu ch∆∞a th√¨ tr·∫£ v·ªÅ true, khi n√†y ta c√≥ th·ªÉ b·∫Øt ƒë·∫ßu kh·ªüi ch·∫°y thread. Ng∆∞·ª£c l·∫°i, n·∫øu thread ƒë√£ k·∫øt th√∫c r·ªìi th√¨ tr·∫£ v·ªÅ false.

üíª **V√≠ d·ª•:**
```cpp
#include <iostream>
#include <thread>
#include <chrono>

using namespace std;

void delay(uint32_t time)
{
    this_thread::sleep_for(chrono::seconds(time));
}

void task1(uint32_t time)
{
    int i = 0;
    for (int j = 0; j < 5; j++)
    {
        cout << "task 1, i = " << i++ << endl;
        delay(time);
    }
}

void task2(uint32_t time)
{
    int i = 0;
    for (int j = 0; j < 5; j++)
    {
        cout << "task 2, i = " << i++ << endl;
        delay(time);
    }
}

int main(int argc, char const *argv[])
{
    thread t1(task1, 1);     // t1: ƒë·∫°i di·ªán cho lu·ªìng 1
    thread t2(task2, 2);     // t2: ƒë·∫°i di·ªán cho lu·ªìng 2

    if (t1.joinable())
    {
        cout << "Thread 1 ch∆∞a k·∫øt th√∫c ho·∫∑c ch∆∞a g·ªçi join()\n";
        t1.join();
    }
    else
    {
        cout << "Thread 1 ƒë√£ k·∫øt th√∫c ho·∫∑c ƒë√£ g·ªçi join()\n";
    }
    

    if (t2.joinable())
    {
        cout << "Thread 2 ch∆∞a k·∫øt th√∫c ho·∫∑c ch∆∞a g·ªçi join()\n";
        t2.join();
    }
    else
    {
        cout << "Thread 2 ƒë√£ k·∫øt th√∫c ho·∫∑c ƒë√£ g·ªçi join()\n";
    }
    
    for (int i=0; i<7; i++)
    {
        cout << "This is main thread\n";
        delay(1);
    }

    return 0;
}
```

</p>
</details>

<details><summary><b>üìöüìö detach()</b></summary>
<p>

- D√πng cho c√°c lu·ªìng ph·ª•.
- Lu·ªìng ph·ª• g·ªçi ph∆∞∆°ng th·ª©c ``` detach() ``` s·∫Ω t√°ch lu·ªìng kh·ªèi lu·ªìng ch√≠nh v√† cho ph√©p n√≥ ch·∫°y ƒë·ªôc l·∫≠p, nghƒ©a l√† lu·ªìng ch√≠nh v√† lu·ªìng ph·ª• g·ªçi ``` detach ``` s·∫Ω kh√¥ng ch·ªù l·∫´n nhau.
- Kh√¥ng th·ªÉ join() m·ªôt lu·ªìng ƒë√£ ƒë∆∞·ª£c detach(). N·∫øu m·ªôt lu·ªìng ƒë√£ ƒë∆∞·ª£c t√°ch ra, n√≥ kh√¥ng c√≤n kh·∫£ nƒÉng tham gia (joinable) n·ªØa.
- Lu·ªìng ch√≠nh khi k·∫øt th√∫c tr∆∞·ªõc lu·ªìng g·ªçi detach th√¨ lu·ªìng ƒë√≥ c≈©ng b·ªã h·ªßy v√† k·∫øt th√∫c do ti·∫øn tr√¨nh ƒë√£ k·∫øt th√∫c. ƒêi·ªÅu n√†y x·∫£y ra v√¨ khi ti·∫øn tr√¨nh k·∫øt th√∫c (do lu·ªìng ch√≠nh k·∫øt th√∫c), t·∫•t c·∫£ c√°c lu·ªìng trong ti·∫øn tr√¨nh (bao g·ªìm lu·ªìng ƒë√£ detach) s·∫Ω b·ªã h·ªá ƒëi·ªÅu h√†nh h·ªßy ngay l·∫≠p t·ª©c.

üíª **V√≠ d·ª•:**
```cpp
#include <iostream>
#include <thread>
#include <chrono>

using namespace std;

int result1 = 0;
int result2 = 0;

void delay(uint32_t time)
{
    this_thread::sleep_for(chrono::seconds(time));
}

void task1(uint32_t time)
{
    int i = 0;
    for (int j = 0; j < 5; j++)
    {
        cout << "task 1, i = " << i++ << endl;
        delay(time);
    }

    result1 = i;
}

void task2(uint32_t time)
{
    int i = 0;
    for (int j = 0; j < 5; j++)
    {
        cout << "task 2, i = " << i++ << endl;
        delay(time);
    }

    result2 = i;
}

int main(int argc, char const *argv[])
{
    thread t1(task1, 1);     // t1: ƒë·∫°i di·ªán cho lu·ªìng 1
    thread t2(task2, 2);     // t2: ƒë·∫°i di·ªán cho lu·ªìng 2

    t1.detach();
    t2.detach();

    cout << "K·∫øt qu·∫£ cu·ªëi c√πng c·ªßa lu·ªìng 1: " << result1 << endl;
    cout << "K·∫øt qu·∫£ cu·ªëi c√πng c·ªßa lu·ªìng 2: " << result2 << endl;
    
    for (int i=0; i<7; i++)
    {
        cout << "This is main thread\n";
        delay(1);
    }

    return 0;
}
```

üìù Lu·ªìng task1, lu·ªìng task2 v√† lu·ªìng ch√≠nh ch·∫°y song song v√† ƒë·ªôc l·∫≠p v·ªõi nhau.

üìù Lu·ªìng ch√≠nh kh√¥ng c√≤n ch·ªù lu·ªìng task1 v√† lu·ªìng task2 ch·∫°y xong r·ªìi m·ªõi th·ª±c hi·ªán.

üìù K·∫øt qu·∫£ c·ªßa lu·ªìng task1 v√† task2 s·∫Ω kh√¥ng l·∫•y ra ƒë∆∞·ª£c:

```cpp
K·∫øt qu·∫£ cu·ªëi c√πng c·ªßa lu·ªìng 1: 0
K·∫øt qu·∫£ cu·ªëi c√πng c·ªßa lu·ªìng 2: 0
This is main thread
task 2, i = 0
task 1, i = 0
This is main thread
task 1, i = 1
This is main thread
task 2, i = 1
task 1, i = 2
This is main thread
task 1, i = 3
This is main thread
task 2, i = 2
task 1, i = 4
This is main thread
This is main thread
task 2, i = 3
```

<br>

- **Khi n√†o s·ª≠ d·ª•ng join()? Khi n√†o s·ª≠ d·ª•ng detach()?**

    + S·ª≠ d·ª•ng join() khi lu·ªìng ph·ª• th·ª±c hi·ªán m·ªôt c√¥ng vi·ªác quan tr·ªçng m√† k·∫øt qu·∫£ c·ªßa n√≥ c·∫ßn thi·∫øt cho lu·ªìng ch√≠nh

    + S·ª≠ d·ª•ng detach() khi c√¥ng vi·ªác c·ªßa c√°c lu·ªìng ph·ª• kh√¥ng ·∫£nh h∆∞·ªüng ƒë·∫øn lu·ªìng ch√≠nh 

<br>

</p>
</details>

</p>
</details>

</p>
</details>

<details><summary><b>3. ƒê·ªìng b·ªì h√≥a c√°c threads</b></summary>
<p>

<details><summary><b>üìö Atomic Operator</b></summary>
<p>

- ``` std::atomic ``` l√† m·ªôt **struct template** trong C++ ƒë∆∞·ª£c thi·∫øt k·∫ø ƒë·ªÉ th·ª±c hi·ªán c√°c thao t√°c tr√™n c√°c bi·∫øn to√†n c·ª•c m√† c√°c thao t√°c n√†y kh√¥ng th·ªÉ b·ªã gi√°n ƒëo·∫°n b·ªüi c√°c lu·ªìng kh√°c. ƒêi·ªÅu n√†y gi√∫p ƒë·∫£m b·∫£o t√≠nh nh·∫•t qu√°n c·ªßa d·ªØ li·ªáu v√† tr√°nh t√¨nh tr·∫°ng **data race** khi nhi·ªÅu lu·ªìng c√πng truy c·∫≠p v√† thay ƒë·ªïi d·ªØ li·ªáu chia s·∫ª.
- C√°c thao t√°c atomic:

	+ G√°n v√† ƒë·ªçc gi√° tr·ªã (store v√† load): Ghi v√† ƒë·ªçc gi√° tr·ªã c·ªßa bi·∫øn atomic.
	+ TƒÉng v√† gi·∫£m gi√° tr·ªã (++, --): TƒÉng ho·∫∑c gi·∫£m gi√° tr·ªã c·ªßa bi·∫øn atomic.
	+ C·ªông v√† tr·ª´ gi√° tr·ªã (+=, -=): Th·ª±c hi·ªán ph√©p c·ªông, tr·ª´ gi√° tr·ªã nguy√™n t·ª≠.

<br>

üíª **V√≠ d·ª• 1:**
```cpp
#include <iostream>
#include <thread>
#include <atomic>

using namespace std;

atomic<int> sharedCounter(0); // bi·∫øn chia s·∫ª gi·ªØa c√°c lu·ªìng

void incrementTask(int iter)
{
    for (int i=0; i<iter; i++)
    {
        cout << ++sharedCounter << endl;
    }
}

int main(int argc, char const *argv[])
{
    thread t1(incrementTask, 100);
    thread t2(incrementTask, 100);

    t1.join();
    t2.join();

    cout << "Final result: " << sharedCounter << endl;

    return 0;
}
```

<br>

üíª **V√≠ d·ª• 2:**
```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <atomic>

using namespace std;

mutex mtx;

atomic<int> value_int(0);

void delay(uint32_t time)
{
    this_thread::sleep_for(chrono::seconds(time));
}

void display(int id, uint32_t time)
{
    while(1)
    {
        unique_lock<mutex> ulock(mtx);
        cout << "This is task display: " << id << endl;
        ulock.unlock();

        ulock.lock();
        value_int.fetch_add(1); // TƒÉng gi√° tr·ªã l√™n 1
        cout << "Data after fetch_add: " << value_int.load() << endl;
        ulock.unlock();

        ulock.lock();
        value_int.fetch_sub(1); // Gi·∫£m gi√° tr·ªã ƒëi 1
        cout << "Data after fetch_sub: " << value_int.load() << endl;
        ulock.unlock();

        ulock.lock();
        value_int.store(50); // ƒê·∫∑t gi√° tr·ªã m·ªõi tr·ª±c ti·∫øp l√† 50
        cout << "Data after store: " << value_int.load() << endl;
        ulock.unlock();

        ulock.lock();
        int old_value = value_int.exchange(100); // ƒê·ªïi gi√° tr·ªã hi·ªán t·∫°i th√†nh 100
        cout << "Data after exchange (old value): " << old_value << ", new value: " << value_int.load() << endl;
        ulock.unlock();

        ulock.lock();
        int expected = 100;
        if (value_int.compare_exchange_weak(expected, 200)) // ƒê·ªïi gi√° tr·ªã th√†nh 200 n·∫øu gi√° tr·ªã hi·ªán t·∫°i l√† 100
        {
            cout << "compare_exchange_weak succeeded, new value: " << value_int.load() << endl;
        }
        else
        {
            cout << "compare_exchange_weak failed, expected: " << expected << ", current value: " << value_int.load() << endl;
        }
        ulock.unlock();

        delay(time);        
    }
}

int main() 
{
    thread t1(display, 1, 1);
    thread t2(display, 2, 2);
    thread t3(display, 3, 2);


    t1.join();
    t2.join();
    t3.join();

    return 0;
}

/********************************************
 * atomic: d√πng cho bi·∫øn to√†n c·ª•c
 * lock_guard, unique_lock: d√πng cho ngo·∫°i vi
 *******************************************/
```

üìù ``` store(new_value) ```: G√°n m·ªôt gi√° tr·ªã m·ªõi v√†o bi·∫øn m·ªôt c√°ch an to√†n tr∆∞·ªõc khi th·ª±c hi·ªán c√°c thao t√°c kh√°c.

üìù ``` load() ```: L·∫•y gi√° tr·ªã hi·ªán t·∫°i c·ªßa bi·∫øn

üìù ``` fetch_add(n) ```: TƒÉng gi√° tr·ªã c·ªßa bi·∫øn l√™n ``` n ``` ƒë∆°n v·ªã.

üìù ``` fetch_add(1) ```: TƒÉng gi√° tr·ªã c·ªßa bi·∫øn l√™n 1 ƒë∆°n v·ªã, gi·ªëng v·ªõi to√°n t·ª≠ ``` ++ ```.

üìù ``` fetch_sub(n) ```: Gi·∫£m gi√° tr·ªã c·ªßa bi·∫øn xu·ªëng ``` n ``` ƒë∆°n v·ªã.

üìù ``` fetch_sub(1) ```: Gi·∫£m gi√° tr·ªã c·ªßa bi·∫øn xu·ªëng 1 ƒë∆°n v·ªã, , gi·ªëng v·ªõi to√°n t·ª≠ ``` -- ```.

üìù ``` exchange(new_value) ```: ƒê·ªïi gi√° tr·ªã c·ªßa bi·∫øn nguy√™n t·ª≠ th√†nh m·ªôt gi√° tr·ªã m·ªõi v√† tr·∫£ v·ªÅ gi√° tr·ªã c≈©.

üìù ``` compare_exchange_weak(expected, desired) ```: N·∫øu gi√° tr·ªã hi·ªán t·∫°i c·ªßa bi·∫øn nguy√™n t·ª≠ b·∫±ng **expected**, thay ƒë·ªïi gi√° tr·ªã th√†nh **desired**. N·∫øu kh√¥ng, c·∫≠p nh·∫≠t **expected** b·∫±ng gi√° tr·ªã hi·ªán t·∫°i.

```cpp
int expected = 100;
value_int.compare_exchange_weak(expected, 200);
```

- N·∫øu value_int l√† 100, n√≥ s·∫Ω ƒë∆∞·ª£c ƒë·ªïi th√†nh 200.

<br>

</p>
</details>

<details><summary><b>üìö Mutex</b></summary>
<p>

- **Mutex (Mutual Exclusion)**: L√† m·ªôt ƒë·ªëi t∆∞·ª£ng ƒë·ªìng b·ªô h√≥a cung c·∫•p c∆° ch·∫ø ƒë·ªÉ gi·ªõi h·∫°n truy c·∫≠p t√†i nguy√™n (ngo·∫°i vi: b√†n ph√≠m, m√†n h√¨nh, camera, ...) ch·ªâ cho m·ªôt lu·ªìng t·∫°i m·ªôt th·ªùi ƒëi·ªÉm. Khi m·ªôt lu·ªìng kh√≥a (lock) mutex, c√°c lu·ªìng kh√°c ph·∫£i ch·ªù cho ƒë·∫øn khi mutex ƒë∆∞·ª£c m·ªü kh√≥a (unlock) m·ªõi c√≥ th·ªÉ ti·∫øp t·ª•c truy c·∫≠p t√†i nguy√™n.
- Tr·∫°ng th√°i c·ªßa mutex: c√≥ hai tr·∫°ng th√°i ch√≠nh:

	+ **Kh√≥a (locked)**: Khi m·ªôt lu·ªìng gi·ªØ (lock) mutex, tr·∫°ng th√°i c·ªßa mutex l√† locked. ƒêi·ªÅu n√†y nghƒ©a l√† mutex hi·ªán ƒëang ƒë∆∞·ª£c "s·ªü h·ªØu" b·ªüi m·ªôt lu·ªìng v√† kh√¥ng lu·ªìng n√†o kh√°c c√≥ th·ªÉ truy c·∫≠p t√†i nguy√™n ƒë∆∞·ª£c b·∫£o v·ªá b·ªüi mutex cho ƒë·∫øn khi lu·ªìng gi·ªØ mutex m·ªü kh√≥a (unlock). N·∫øu m·ªôt lu·ªìng kh√°c c·ªë g·∫Øng lock mutex khi n√≥ ƒëang ·ªü tr·∫°ng th√°i locked, lu·ªìng ƒë√≥ s·∫Ω b·ªã block (ch·ªù ƒë·ª£i) cho ƒë·∫øn khi mutex ƒë∆∞·ª£c unlock.
	+ **M·ªü kh√≥a (unlocked)**: Khi mutex kh√¥ng b·ªã b·∫•t k·ª≥ lu·ªìng n√†o gi·ªØ (lock), tr·∫°ng th√°i c·ªßa mutex l√† unlocked. Trong tr·∫°ng th√°i n√†y, b·∫•t k·ª≥ lu·ªìng n√†o c≈©ng c√≥ th·ªÉ lock mutex v√† tr·ªü th√†nh lu·ªìng s·ªü h·ªØu n√≥. Sau khi m·ªôt lu·ªìng s·ªü h·ªØu mutex, tr·∫°ng th√°i chuy·ªÉn th√†nh locked, v√† c√°c lu·ªìng kh√°c ph·∫£i ch·ªù.

- ``` std::mutex ``` ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a trong th∆∞ vi·ªán <mutex>. C√°c ph∆∞∆°ng th·ª©c c∆° b·∫£n bao g·ªìm:

	+ **lock()**: Kh√≥a mutex.
	+ **unlock()**: M·ªü kh√≥a mutex.
	+ **try_lock()**: Th·ª≠ kh√≥a mutex. N·∫øu mutex ch∆∞a b·ªã kh√≥a, n√≥ s·∫Ω kh√≥a mutex v√† tr·∫£ v·ªÅ true. N·∫øu ƒë√£ b·ªã kh√≥a b·ªüi m·ªôt lu·ªìng kh√°c, n√≥ s·∫Ω kh√¥ng ch·∫∑n lu·ªìng hi·ªán t·∫°i m√† tr·∫£ v·ªÅ false.

<br>

üíª **V√≠ d·ª• 1:**
```cpp
#include <iostream>
#include <thread>
#include <atomic>
#include <mutex>
using namespace std;

atomic<int> sharedCounter(0); // bi·∫øn chia s·∫ª gi·ªØa c√°c lu·ªìng

mutex mtx;

void incrementTask(int iter)
{
    for (int i=0; i<iter; i++)
    {
        mtx.lock();                      // Kh√≥a mutex tr∆∞·ªõc khi truy c·∫≠p bi·∫øn chia s·∫ª
        cout << ++sharedCounter << endl; // Thao t√°c tr√™n bi·∫øn chia s·∫ª v√† in ra terminal
        mtx.unlock();                    // M·ªü kh√≥a mutex sau khi truy c·∫≠p
    }
}

int main(int argc, char const *argv[])
{
    thread t1(incrementTask, 100);
    thread t2(incrementTask, 100);

    t1.join();
    t2.join();

    cout << "Final result: " << sharedCounter << endl;
    return 0;
}
```

<br>

- ``` std::lock_guard ``` l√† m·ªôt l·ªõp RAII (Resource Acquisition Is Initialization) qu·∫£n l√Ω t·ª± ƒë·ªông vi·ªác kh√≥a v√† m·ªü kh√≥a, gi√∫p gi·∫£m l·ªói l·∫≠p tr√¨nh nh∆∞ qu√™n m·ªü kh√≥a. C√°c ƒë·ªëi t∆∞·ª£ng std::lock_guard th∆∞·ªùng ƒë∆∞·ª£c khai b√°o c·ª•c b·ªô trong m·ªôt h√†m ho·∫∑c m·ªôt kh·ªëi l·ªánh.
- Ch√∫ng kh√¥ng l∆∞u tr·ªØ t√†i nguy√™n ƒë∆∞·ª£c b·∫£o v·ªá, m√† ch·ªâ qu·∫£n l√Ω vi·ªác kh√≥a/m·ªü kh√≥a std::mutex m·ªôt c√°ch t·ª± ƒë·ªông.
- T·ª± ƒë·ªông kh√≥a mutex khi ƒë·ªëi t∆∞·ª£ng ƒë∆∞·ª£c t·∫°o.
- T·ª± ƒë·ªông m·ªü kh√≥a khi ƒë·ªëi t∆∞·ª£ng b·ªã h·ªßy.

üíª **Driver:**
```cpp
template<typename _Mutex>
class lock_guard
{
    public:
        typedef _Mutex mutex_type;

        lock_guard(mutex_type& __m) : _M_device(__m){ 
            _M_device.lock(); 
        }

        // lock_guard(mutex_type& __m, adopt_lock_t) noexcept : _M_device(__m){} // calling thread owns mutex

        ~lock_guard(){ 
            _M_device.unlock(); 
        }

        lock_guard(const lock_guard&) = delete;
        lock_guard& operator=(const lock_guard&) = delete;

    private:
        mutex_type&  _M_device;
};
```

<br>

üíª **V√≠ d·ª• 2:**
```cpp
#include <iostream>
#include <thread>
#include <chrono>
#include <atomic>
#include <mutex>
using namespace std;

atomic<double> counter(0);

mutex mtx;

void delay(uint32_t time)
{
    this_thread::sleep_for(chrono::seconds(time));
}

void display(int id)
{
    while (1)
    {
        lock_guard<mutex> lock(mtx);
        cout << "This is task display: " << id << endl;
        counter = counter + 3.14;
        cout << "Counter: " << counter << endl;
        delay(1);
    }
}

int main(int argc, char const *argv[])
{
    thread t1(display, 1);
    thread t2(display, 2);
    thread t3(display, 3);

    t1.join();
    t2.join();
    t3.join();
    return 0;
}
```

<br>

- ``` std::unique_lock ``` t·ª± ƒë·ªông kh√≥a mutex khi ƒë∆∞·ª£c t·∫°o nh∆∞ng cung c·∫•p t√≠nh linh ho·∫°t h∆°n std::lock_guard, cho ph√©p m·ªü kh√≥a th·ªß c√¥ng ho·∫∑c t·ª± ƒë·ªông m·ªü kh√≥a khi ra kh·ªèi ph·∫°m vi, ho·∫∑c th·ª≠ kh√≥a v·ªõi th·ªùi gian ch·ªù.

üíª **Driver:**
```cpp
template<typename _Mutex>
class unique_lock
{
    public:
        typedef _Mutex mutex_type;

        unique_lock() noexcept : _M_device(0), _M_owns(false){}

        unique_lock(mutex_type& __m): _M_device(std::__addressof(__m)), _M_owns(false)
        {
            lock();
            _M_owns = true;
        }     

        void lock()
        {
            if (!_M_device){
                __throw_system_error(int(errc::operation_not_permitted));
            }
            else if (_M_owns){
                __throw_system_error(int(errc::resource_deadlock_would_occur));
            }
            else{
                _M_device->lock();
                _M_owns = true;
            }
        }

        ~unique_lock()
        {
            if (_M_owns)
                unlock();
        }

        void unlock()
        {
            if (!_M_owns)
                __throw_system_error(int(errc::operation_not_permitted));
            else if (_M_device){
                _M_device->unlock();
                _M_owns = false;
            }
        }
        
    private:
        mutex_type* _M_device;
        bool        _M_owns;
};
```

<br>

üíª **V√≠ d·ª• 3:**
```cpp
#include <iostream>
#include <thread>
#include <chrono>
#include <mutex>

using namespace std;

mutex mtx;

bool lock_test = false;

void delay(uint32_t time){ this_thread::sleep_for(chrono::seconds(time)); }

void display(int id)
{
    while (1)
    {
        unique_lock<mutex> lock(mtx);   
        cout << "This is task display: " << id << endl;
        delay(1);
        lock.unlock();
    }
}

int main(int argc, char const *argv[])
{
    thread t1(display, 1);
    thread t2(display, 2);
    thread t3(display, 3);

    t1.join();
    t2.join();
    t3.join();
    return 0;
}
```

<br>

üíª **V√≠ d·ª• 4:**
```cpp
#include <iostream>
#include <thread>
#include <chrono>
#include <mutex>
using namespace std;

mutex mtx;

void delay(uint32_t time){ this_thread::sleep_for(chrono::seconds(time)); }

void task(int id)
{
    while(1)
    {
        unique_lock<mutex> ulock(mtx);
        cout << "Peripheral HMI " << id << endl;
        ulock.unlock();
        delay(1);

        ulock.lock();
        cout << "Peripheral camera " << id << endl;
        ulock.unlock();
        delay(2);

        ulock.lock();
        cout << "Peripheral keyboard " << id << endl;
        ulock.unlock();
        delay(3);
    }
}

int main(int argc, char const *argv[])
{
    thread t1(task, 1);
    thread t2(task, 2);
    thread t3(task, 3);

    t1.join();
    t2.join();
    t3.join();
    return 0;
}
```

<br>

üìù ``` mutex ``` khai b√°o **to√†n c·ª•c**, c√≤n ``` unique_lock, lock_guard ``` th√¨ khai b√°o **c·ª•c b·ªô**.

- **``` mutex ``` c·∫ßn ƒë∆∞·ª£c d√πng chung gi·ªØa c√°c lu·ªìng:**

	+ M·ªôt mutex ph·∫£i ƒë∆∞·ª£c chia s·∫ª b·ªüi t·∫•t c·∫£ c√°c lu·ªìng mu·ªën ƒë·ªìng b·ªô h√≥a truy c·∫≠p v√†o c√πng m·ªôt t√†i nguy√™n.
	+ N·∫øu mutex ƒë∆∞·ª£c khai b√°o c·ª•c b·ªô (trong ph·∫°m vi h√†m ho·∫∑c scope), m·ªói lu·ªìng s·∫Ω c√≥ b·∫£n sao ri√™ng c·ªßa mutex, l√†m m·∫•t t√°c d·ª•ng c·ªßa ƒë·ªìng b·ªô h√≥a.

- **``` unique_lock, lock_guard ``` ch·ªâ t·ªìn t·∫°i trong ph·∫°m vi c·∫ßn thi·∫øt**:

	+ ``` unique_lock ``` v√† ``` lock_guard ``` ch·ªâ l√† c√¥ng c·ª• qu·∫£n l√Ω kh√≥a t·∫°m th·ªùi, ƒë∆∞·ª£c s·ª≠ d·ª•ng trong c√°c v√πng code c·∫ßn b·∫£o v·ªá, v√¨ v·∫≠y ch√∫ng n√™n ƒë∆∞·ª£c khai b√°o c·ª•c b·ªô.
	+ ƒêi·ªÅu n√†y gi√∫p gi·∫£m thi·ªÉu th·ªùi gian gi·ªØ kh√≥a, tr√°nh **deadlock** v√† tƒÉng hi·ªáu su·∫•t ch∆∞∆°ng tr√¨nh.

üìù Trong l·∫≠p tr√¨nh ƒëa lu·ªìng, ``` mutex ``` (mutual exclusion) ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ ƒë·∫£m b·∫£o r·∫±ng ch·ªâ c√≥ m·ªôt lu·ªìng truy c·∫≠p v√†o t√†i nguy√™n d√πng chung t·∫°i m·ªôt th·ªùi ƒëi·ªÉm.

üìù ``` unique_lock ``` v√† ``` lock_guard ``` ƒë∆∞·ª£c thi·∫øt k·∫ø ƒë·ªÉ l√†m vi·ªác v·ªõi mutex nh·∫±m ƒë·∫£m b·∫£o vi·ªác kh√≥a v√† m·ªü kh√≥a mutex m·ªôt c√°ch an to√†n v√† t·ª± ƒë·ªông.

<br>

</p>
</details>

<details><summary><b>üìö Condition variable</b></summary>
<p>

- ``` std::condition_variable ``` l√† 1 c∆° ch·∫ø giao ti·∫øp v√† ƒë·ªìng b·ªô h√≥a gi·ªØa 2 ho·∫∑c nhi·ªÅu lu·ªìng, cho ph√©p m·ªôt lu·ªìng ch·ªù cho ƒë·∫øn khi m·ªôt ƒëi·ªÅu ki·ªán c·ª• th·ªÉ ƒë∆∞·ª£c ƒë√°p ·ª©ng, v√† m·ªôt lu·ªìng kh√°c c√≥ th·ªÉ th√¥ng b√°o khi ƒëi·ªÅu ki·ªán ƒë√≥ ƒë∆∞·ª£c th·ªèa m√£n.
- C√°ch ho·∫°t ƒë·ªông c·ªßa std::condition_variable:

a) M·ªôt lu·ªìng ch·ªù (``` wait() ```) cho ƒë·∫øn khi c√≥ t√≠n hi·ªáu t·ª´ m·ªôt lu·ªìng kh√°c:

- Lu·ªìng n√†y s·∫Ω ch·ªù trong tr·∫°ng th√°i ch·ªù ƒëi·ªÅu ki·ªán, tr√°nh l√£ng ph√≠ t√†i nguy√™n CPU.
- ƒê·ªÉ s·ª≠ d·ª•ng wait(), c·∫ßn c√≥ m·ªôt ``` std::unique_lock<std::mutex> ``` v√† m·ªôt ƒë·ªëi t∆∞·ª£ng ``` std::condition_variable ```, v√¨ n√≥ ph·∫£i t·∫°m th·ªùi m·ªü kh√≥a mutex ƒë·ªÉ c√°c lu·ªìng kh√°c c√≥ th·ªÉ truy c·∫≠p v√†o mutex v√† thay ƒë·ªïi ƒëi·ªÅu ki·ªán. Sau khi ƒëi·ªÅu ki·ªán ƒë∆∞·ª£c th·ªèa m√£n v√† lu·ªìng ƒë∆∞·ª£c ƒë√°nh th·ª©c, ``` std::unique_lock ``` s·∫Ω t·ª± ƒë·ªông kh√≥a l·∫°i mutex ƒë·ªÉ ƒë·∫£m b·∫£o t√≠nh nh·∫•t qu√°n tr∆∞·ªõc khi ti·∫øp t·ª•c.
- L∆∞u √Ω: ``` std::lock_guard ``` kh√¥ng h·ªó tr·ª£ m·ªü kh√≥a v√† kh√≥a l·∫°i mutex nh∆∞ v·∫≠y. Khi m·ªôt ``` std::lock_guard ``` ƒë∆∞·ª£c t·∫°o, n√≥ s·∫Ω gi·ªØ mutex cho ƒë·∫øn khi ƒë·ªëi t∆∞·ª£ng b·ªã h·ªßy (khi ra kh·ªèi ph·∫°m vi), do ƒë√≥ kh√¥ng ph√π h·ª£p ƒë·ªÉ s·ª≠ d·ª•ng v·ªõi wait.

b) M·ªôt lu·ªìng kh√°c th√¥ng b√°o (notify_one() ho·∫∑c notify_all()) r·∫±ng ƒëi·ªÅu ki·ªán ƒë√£ ƒë∆∞·ª£c ƒë√°p ·ª©ng:

- ``` notify_one() ```: g·ª≠i th√¥ng b√°o t·ªõi 1 lu·ªìng ƒëang ch·ªù.
- ``` notify_all() ```: g·ª≠i th√¥ng b√°o t·ªõi nhi·ªÅu lu·ªìng ƒëang ch·ªù.

<br>

üíª **V√≠ d·ª• 1:**
```cpp
#include <iostream>
#include <thread>               // T·∫°o lu·ªìng
#include <mutex>                // Kh√≥a d·ªØ li·ªáu khi c√≥ nhi·ªÅu lu·ªìng truy c·∫≠p
#include <condition_variable>   // Bi·∫øn ƒëi·ªÅu ki·ªán gi√∫p ƒë·ªìng b·ªô h√≥a gi·ªØa c√°c lu·ªìng
#include <chrono>               // Qu·∫£n l√Ω th·ªùi gian
#include <atomic>               // Bi·∫øn nguy√™n t·ª≠ ƒë·ªÉ tr√°nh xung ƒë·ªôt d·ªØ li·ªáu

using namespace std;

/********************************************************
 * @brief H√†m t·∫°o ƒë·ªô tr·ªÖ cho lu·ªìng
 * @param time Th·ªùi gian tr·ªÖ (ƒë∆°n v·ªã: gi√¢y)
 ********************************************************/
void delay(uint32_t time) { 
    this_thread::sleep_for(chrono::seconds(time)); 
}

// Bi·∫øn to√†n c·ª•c d√πng ƒë·ªÉ l∆∞u d·ªØ li·ªáu c·∫£m bi·∫øn
atomic<int> sensor_data(0);

// C·ªù ki·ªÉm tra xem d·ªØ li·ªáu ƒë√£ s·∫µn s√†ng hay ch∆∞a
bool check_data = false;

// ƒê·ªëi t∆∞·ª£ng mutex d√πng ƒë·ªÉ ƒë·ªìng b·ªô d·ªØ li·ªáu gi·ªØa c√°c lu·ªìng
mutex mtx;

// Bi·∫øn ƒëi·ªÅu ki·ªán ƒë·ªÉ b√°o hi·ªáu khi c√≥ d·ªØ li·ªáu m·ªõi
condition_variable cv;

/********************************************************
 * @brief H√†m m√¥ ph·ªèng qu√° tr√¨nh ƒë·ªçc d·ªØ li·ªáu t·ª´ c·∫£m bi·∫øn
 * @details C·ª© m·ªói 2 gi√¢y, h√†m n√†y s·∫Ω c·∫≠p nh·∫≠t d·ªØ li·ªáu c·∫£m bi·∫øn
 *          v√† g·ª≠i t√≠n hi·ªáu cho lu·ªìng x·ª≠ l√Ω d·ªØ li·ªáu.
 * @return void
 ********************************************************/
void sensor_read()
{
    while (1)
    {
        delay(2);  // T·∫°o ƒë·ªô tr·ªÖ 2 gi√¢y
        unique_lock<mutex> lock(mtx);
        sensor_data = rand() % 100; // Gi·∫£ l·∫≠p gi√° tr·ªã c·∫£m bi·∫øn ng·∫´u nhi√™n
        check_data = true;          // ƒê√°nh d·∫•u d·ªØ li·ªáu ƒë√£ s·∫µn s√†ng
        cout << "Read data done!\n";
        lock.unlock();
        cv.notify_one(); // B√°o hi·ªáu cho lu·ªìng x·ª≠ l√Ω d·ªØ li·ªáu
    }
}

/********************************************************
 * @brief H√†m x·ª≠ l√Ω d·ªØ li·ªáu t·ª´ c·∫£m bi·∫øn
 * @details Ch·ªù d·ªØ li·ªáu c·∫£m bi·∫øn s·∫µn s√†ng, sau ƒë√≥ in ra m√†n h√¨nh
 * @return void
 ********************************************************/
void process_data()
{
    while (1)
    {
        unique_lock<mutex> lock(mtx);
        cv.wait(lock, []{return check_data;});  // Ch·ªù ƒë·∫øn khi d·ªØ li·ªáu s·∫µn s√†ng
        cout << "Data: " << sensor_data << endl; // Hi·ªÉn th·ªã d·ªØ li·ªáu
        lock.unlock();
        check_data = false; // Reset c·ªù d·ªØ li·ªáu
    }
}

int main(int argc, char const *argv[])
{
    thread task1(sensor_read);  // T·∫°o lu·ªìng ƒë·ªçc d·ªØ li·ªáu c·∫£m bi·∫øn
    thread task2(process_data); // T·∫°o lu·ªìng x·ª≠ l√Ω d·ªØ li·ªáu

    task1.join(); // Ch·ªù lu·ªìng 1 k·∫øt th√∫c
    task2.join(); // Ch·ªù lu·ªìng 2 k·∫øt th√∫c
    return 0;
}
```

<br>

üíª **V√≠ d·ª• 2:**
```cpp
#include <iostream>
#include <thread>               // T·∫°o lu·ªìng
#include <mutex>                // Kh√≥a d·ªØ li·ªáu khi c√≥ nhi·ªÅu lu·ªìng truy c·∫≠p
#include <condition_variable>   // Bi·∫øn ƒëi·ªÅu ki·ªán gi√∫p ƒë·ªìng b·ªô h√≥a gi·ªØa c√°c lu·ªìng
#include <chrono>               // Qu·∫£n l√Ω th·ªùi gian
#include <atomic>               // Bi·∫øn nguy√™n t·ª≠ ƒë·ªÉ tr√°nh xung ƒë·ªôt d·ªØ li·ªáu

using namespace std;

/********************************************************
 * @brief H√†m t·∫°o ƒë·ªô tr·ªÖ cho lu·ªìng
 * @param time Th·ªùi gian tr·ªÖ (ƒë∆°n v·ªã: gi√¢y)
 ********************************************************/
void delay(uint32_t time){ this_thread::sleep_for(chrono::seconds(time)); }

// Bi·∫øn to√†n c·ª•c d√πng ƒë·ªÉ l∆∞u d·ªØ li·ªáu c·∫£m bi·∫øn
atomic<int> sensor_data(0);

// C·ªù ki·ªÉm tra xem d·ªØ li·ªáu ƒë√£ s·∫µn s√†ng hay ch∆∞a
bool check_data = false;

// ƒê·ªëi t∆∞·ª£ng mutex d√πng ƒë·ªÉ ƒë·ªìng b·ªô d·ªØ li·ªáu gi·ªØa c√°c lu·ªìng
mutex mtx;

// Bi·∫øn ƒëi·ªÅu ki·ªán ƒë·ªÉ b√°o hi·ªáu khi c√≥ d·ªØ li·ªáu m·ªõi
condition_variable cv;

/********************************************************
 * @brief H√†m m√¥ ph·ªèng qu√° tr√¨nh ƒë·ªçc d·ªØ li·ªáu t·ª´ c·∫£m bi·∫øn
 * @details C·ª© m·ªói 2 gi√¢y, h√†m n√†y s·∫Ω c·∫≠p nh·∫≠t d·ªØ li·ªáu c·∫£m bi·∫øn
 *          v√† g·ª≠i t√≠n hi·ªáu cho t·∫•t c·∫£ c√°c lu·ªìng x·ª≠ l√Ω d·ªØ li·ªáu.
 * @return void
 ********************************************************/
void sensor_read()
{
    while (1)
    {
        delay(2);  // T·∫°o ƒë·ªô tr·ªÖ 2 gi√¢y
        sensor_data = rand() % 100; // Gi·∫£ l·∫≠p gi√° tr·ªã c·∫£m bi·∫øn ng·∫´u nhi√™n
        check_data = true;          // ƒê√°nh d·∫•u d·ªØ li·ªáu ƒë√£ s·∫µn s√†ng
        
        unique_lock<mutex> lock(mtx);    // C√≥ th·ªÉ kh√¥ng c·∫ßn v√¨ atomic c√≥ th·ªÉ t·ª± b·∫£o v·ªá
        cout << "Read data done!\n";
        lock.unlock();

        cv.notify_all(); // B√°o hi·ªáu cho t·∫•t c·∫£ c√°c lu·ªìng x·ª≠ l√Ω d·ªØ li·ªáu
    }
}

/********************************************************
 * @brief H√†m x·ª≠ l√Ω d·ªØ li·ªáu t·ª´ c·∫£m bi·∫øn (lu·ªìng 1)
 * @details Ch·ªù d·ªØ li·ªáu c·∫£m bi·∫øn s·∫µn s√†ng, sau ƒë√≥ in ra m√†n h√¨nh.
 * @return void
 ********************************************************/
void process_data_1()
{
    while (1)
    {
        unique_lock<mutex> lock(mtx);
        cv.wait(lock, []()->bool{return check_data;}); // Ch·ªù ƒë·∫øn khi d·ªØ li·ªáu s·∫µn s√†ng
        cout << "Process Data 1: " << sensor_data << endl;
        lock.unlock();
        check_data = false;  
    }
}

/********************************************************
 * @brief H√†m x·ª≠ l√Ω d·ªØ li·ªáu t·ª´ c·∫£m bi·∫øn (lu·ªìng 2)
 * @details Ch·ªù d·ªØ li·ªáu c·∫£m bi·∫øn s·∫µn s√†ng, sau ƒë√≥ in ra m√†n h√¨nh.
 * @return void
 ********************************************************/
void process_data_2()
{
    while (1)
    {
        unique_lock<mutex> lock(mtx);
        cv.wait(lock, []()->bool{return check_data;}); // Ch·ªù ƒë·∫øn khi d·ªØ li·ªáu s·∫µn s√†ng
        cout << "Process Data 2: " << sensor_data << endl;
        lock.unlock();  // Gi·∫£m ƒë·ªô ngh·∫Ωn (unlock ngay sau khi ho√†n th√†nh t√°c v·ª•)
        check_data = false;       
    }
}

int main(int argc, char const *argv[])
{
    thread task1(sensor_read);     // T·∫°o lu·ªìng ƒë·ªçc d·ªØ li·ªáu c·∫£m bi·∫øn
    thread task2(process_data_1);  // T·∫°o lu·ªìng x·ª≠ l√Ω d·ªØ li·ªáu 1
    thread task3(process_data_2);  // T·∫°o lu·ªìng x·ª≠ l√Ω d·ªØ li·ªáu 2

    task1.join(); // Ch·ªù lu·ªìng 1 k·∫øt th√∫c
    task2.join(); // Ch·ªù lu·ªìng 2 k·∫øt th√∫c
    task3.join(); // Ch·ªù lu·ªìng 3 k·∫øt th√∫c

    return 0;
}
```

<br>

üíª **V√≠ d·ª• 3:**
```cpp
#include <iostream>
#include <thread>               // Qu·∫£n l√Ω lu·ªìng
#include <chrono>               // Qu·∫£n l√Ω th·ªùi gian
#include <mutex>                // ƒê·ªìng b·ªô h√≥a lu·ªìng
#include <atomic>               // Bi·∫øn nguy√™n t·ª≠
#include <condition_variable>   // ƒêi·ªÅu ki·ªán ƒë·ªìng b·ªô h√≥a gi·ªØa c√°c lu·ªìng
#include <vector>               // S·ª≠ d·ª•ng buffer ƒë·ªÉ l∆∞u d·ªØ li·ªáu c·∫£m bi·∫øn

using namespace std;

// ƒê·ªëi t∆∞·ª£ng mutex d√πng ƒë·ªÉ ƒë·ªìng b·ªô d·ªØ li·ªáu gi·ªØa c√°c lu·ªìng
mutex mtx;

// Bi·∫øn ƒëi·ªÅu ki·ªán ƒë·ªÉ ki·ªÉm so√°t vi·ªác ƒë·ªçc v√† x·ª≠ l√Ω d·ªØ li·ªáu
condition_variable cv;

// Bi·∫øn nguy√™n t·ª≠ d√πng ƒë·ªÉ ƒë·∫øm d·ªØ li·ªáu c·∫£m bi·∫øn
atomic<int> data_sensor(0);

// B·ªô ƒë·ªám d√πng ƒë·ªÉ l∆∞u d·ªØ li·ªáu c·∫£m bi·∫øn tr∆∞·ªõc khi x·ª≠ l√Ω
vector<int> buffer;

// K√≠ch th∆∞·ªõc t·ªëi ƒëa c·ªßa buffer
const unsigned int MAX_BUFFER_SIZE = 5;

// Bi·∫øn c·ªù ki·ªÉm so√°t vi·ªác d·ª´ng ch∆∞∆°ng tr√¨nh
bool stop = false;

/********************************************************
 * @brief H√†m t·∫°o ƒë·ªô tr·ªÖ
 * @param time Th·ªùi gian tr·ªÖ (ƒë∆°n v·ªã: gi√¢y)
 ********************************************************/
void delay(int time)
{
    this_thread::sleep_for(chrono::seconds(time));
}

/********************************************************
 * @brief Lu·ªìng ƒë·ªçc d·ªØ li·ªáu c·∫£m bi·∫øn
 * @details D·ªØ li·ªáu ƒë∆∞·ª£c ƒë·ªçc v√† th√™m v√†o buffer n·∫øu ch∆∞a ƒë·∫ßy.
 *          Khi buffer ƒë·∫ßy, lu·ªìng s·∫Ω ch·ªù ƒë·∫øn khi c√≥ kh√¥ng gian tr·ªëng.
 *          D·ªØ li·ªáu s·∫Ω tƒÉng d·∫ßn theo bi·∫øn to√†n c·ª•c `data_sensor`.
 * @return void
 ********************************************************/
void readData()
{
    while (!stop)
    {
        unique_lock<mutex> ulock(mtx);
        cv.wait(ulock, [](){ return buffer.size() < MAX_BUFFER_SIZE || stop; });

        if (stop) break; // Tho√°t n·∫øu c√≥ y√™u c·∫ßu d·ª´ng

        // Th√™m d·ªØ li·ªáu v√†o buffer
        buffer.push_back(++data_sensor);
        cout << "Added data: " << data_sensor << endl;

        cv.notify_one();  // Th√¥ng b√°o cho lu·ªìng x·ª≠ l√Ω d·ªØ li·ªáu
        ulock.unlock();    // Gi·∫£i ph√≥ng mutex tr∆∞·ªõc khi ng·ªß

        delay(1);
    }
}

/********************************************************
 * @brief Lu·ªìng x·ª≠ l√Ω d·ªØ li·ªáu
 * @details L·∫•y d·ªØ li·ªáu t·ª´ buffer v√† x·ª≠ l√Ω. Khi buffer tr·ªëng,
 *          lu·ªìng s·∫Ω ch·ªù ƒë·∫øn khi c√≥ d·ªØ li·ªáu m·ªõi.
 *          X·ª≠ l√Ω d·ªØ li·ªáu ƒë·∫ßu ti√™n trong buffer theo FIFO.
 * @return void
 ********************************************************/
void processData()
{
    while (!stop)
    {
        unique_lock<mutex> ulock(mtx);
        cv.wait(ulock, [](){ return !buffer.empty() || stop; });

        if (stop && buffer.empty()) break; // Tho√°t n·∫øu buffer r·ªóng v√† c√≥ y√™u c·∫ßu d·ª´ng

        // X·ª≠ l√Ω d·ªØ li·ªáu ƒë·∫ßu ti√™n trong buffer
        cout << "Processed data " << buffer.front() << endl;
        buffer.erase(buffer.begin());  // X√≥a d·ªØ li·ªáu ƒë·∫ßu ti√™n

        cv.notify_one();  // Th√¥ng b√°o cho lu·ªìng ƒë·ªçc d·ªØ li·ªáu
        ulock.unlock();    // Gi·∫£i ph√≥ng mutex tr∆∞·ªõc khi ng·ªß

        delay(8);
    }
}


int main()
{
    thread t1(readData);   // T·∫°o lu·ªìng ƒë·ªçc d·ªØ li·ªáu c·∫£m bi·∫øn
    thread t2(processData); // T·∫°o lu·ªìng x·ª≠ l√Ω d·ªØ li·ªáu

    delay(35); // Ch·∫°y trong 35 gi√¢y

    // D·ª´ng lu·ªìng an to√†n
    {
        lock_guard<mutex> lock(mtx);
        stop = true;
    }
    cv.notify_all(); // Th√¥ng b√°o cho t·∫•t c·∫£ c√°c lu·ªìng tho√°t

    t1.join(); // Ch·ªù lu·ªìng ƒë·ªçc d·ªØ li·ªáu k·∫øt th√∫c
    t2.join(); // Ch·ªù lu·ªìng x·ª≠ l√Ω d·ªØ li·ªáu k·∫øt th√∫c

    cout << "Main: All threads stopped. Exiting program.\n";

    return 0;
}
```

üìù **Lu·ªìng ch√≠nh (main)**

- **Kh·ªüi t·∫°o hai lu·ªìng**:

	+ Lu·ªìng t1 ch·∫°y h√†m ``` readData ``` ƒë·ªÉ th√™m d·ªØ li·ªáu v√†o buffer.
	+ Lu·ªìng t2 ch·∫°y h√†m ``` processData ``` ƒë·ªÉ l·∫•y d·ªØ li·ªáu t·ª´ buffer v√† x·ª≠ l√Ω.

- **Ch·∫°y trong 10 gi√¢y**:

	+ S·ª≠ d·ª•ng delay(10) ƒë·ªÉ lu·ªìng ch√≠nh ch·ªù trong 10 gi√¢y tr∆∞·ªõc khi d·ª´ng c·∫£ hai lu·ªìng.

- **D·ª´ng ch∆∞∆°ng tr√¨nh**:

	+ ƒê·∫∑t c·ªù ``` stop = true ``` ƒë·ªÉ b√°o hi·ªáu hai lu·ªìng k·∫øt th√∫c v√≤ng l·∫∑p.
	+ G·ªçi ``` cv.notify_all() ``` ƒë·ªÉ ƒë√°nh th·ª©c b·∫•t k·ª≥ lu·ªìng n√†o ƒëang ch·ªù.

- **ƒê·ª£i hai lu·ªìng k·∫øt th√∫c**:

	+ G·ªçi ``` t1.join() ``` v√† ``` t2.join() ``` ƒë·ªÉ ƒë·∫£m b·∫£o hai lu·ªìng k·∫øt th√∫c tr∆∞·ªõc khi ch∆∞∆°ng tr√¨nh tho√°t.

üìù **Lu·ªìng ƒë·ªçc d·ªØ li·ªáu (read data)**

- **Nhi·ªám v·ª•**: Th√™m d·ªØ li·ªáu li√™n t·ª•c v√†o buffer, gi·∫£ l·∫≠p vi·ªác thu th·∫≠p d·ªØ li·ªáu t·ª´ c·∫£m bi·∫øn.
- **Flow**:

	1. **Ch·ªù ƒëi·ªÅu ki·ªán**:
	
 		+ ``` cv.wait() ``` ki·ªÉm tra ƒëi·ªÅu ki·ªán ``` buffer.size() < MAX_BUFFER_SIZE ```.
		+ N·∫øu buffer ƒë·∫ßy, lu·ªìng s·∫Ω ch·ªù ƒë·∫øn khi consumer (lu·ªìng processData) x·ª≠ l√Ω b·ªõt d·ªØ li·ªáu.

	2. **Th√™m d·ªØ li·ªáu**:

		+ N·∫øu buffer ch∆∞a ƒë·∫ßy, d·ªØ li·ªáu m·ªõi (data) ƒë∆∞·ª£c th√™m v√†o cu·ªëi vector buffer.
		+ In th√¥ng b√°o: ``` "Added data: <data>" ```.
	
 	3. **Th√¥ng b√°o t·ªõi lu·ªìng x·ª≠ l√Ω**:

		+ G·ªçi ``` cv.notify_one() ``` ƒë·ªÉ b√°o cho lu·ªìng ``` processData ``` bi·∫øt r·∫±ng ƒë√£ c√≥ d·ªØ li·ªáu m·ªõi.

	4. **Delay**:

		+ Gi·∫£ l·∫≠p vi·ªác ƒë·ªçc d·ªØ li·ªáu b·∫±ng c√°ch ch·ªù 1 gi√¢y (delay(1)).

	5. **Tho√°t v√≤ng l·∫∑p**:

		+ N·∫øu c·ªù ``` stop = true ```, lu·ªìng k·∫øt th√∫c.

üìù **Lu·ªìng x·ª≠ l√Ω d·ªØ li·ªáu (process data)**

- **Nhi·ªám v·ª•**: L·∫•y d·ªØ li·ªáu t·ª´ buffer v√† x·ª≠ l√Ω, gi·∫£ l·∫≠p ph√¢n t√≠ch d·ªØ li·ªáu t·ª´ c·∫£m bi·∫øn.
- **Flow**:

	1. **Ch·ªù ƒëi·ªÅu ki·ªán**:
	
 		+ ``` cv.wait() ``` ki·ªÉm tra ƒëi·ªÅu ki·ªán ``` !buffer.empty() ```.
		+ N·∫øu buffer r·ªóng, lu·ªìng s·∫Ω ch·ªù ƒë·∫øn khi producer (lu·ªìng readData) th√™m d·ªØ li·ªáu.

	2. **L·∫•y v√† x√≥a d·ªØ li·ªáu**:

		+ L·∫•y ph·∫ßn t·ª≠ ƒë·∫ßu ti√™n trong buffer (``` buffer.front() ```)..
		+ X√≥a ph·∫ßn t·ª≠ ƒë·∫ßu ti√™n (``` buffer.erase(buffer.begin()) ```).
	
 	3. **Th√¥ng b√°o t·ªõi lu·ªìng ƒë·ªçc**:

		+ G·ªçi ``` cv.notify_one() ``` ƒë·ªÉ b√°o cho lu·ªìng ``` readData ``` bi·∫øt r·∫±ng buffer ƒë√£ c√≥ ch·ªó tr·ªëng.

	4. **Delay**:

		+ Gi·∫£ l·∫≠p vi·ªác ƒë·ªçc d·ªØ li·ªáu b·∫±ng c√°ch ch·ªù 1 gi√¢y (delay(1)).

	5. **Tho√°t v√≤ng l·∫∑p**:

		+ N·∫øu c·ªù ``` stop = true ```, lu·ªìng k·∫øt th√∫c.

<br>


</p>
</details>

<details><summary><b>üìö Semaphore</b></summary>
<p>

Semaphore l√† m·ªôt c∆° ch·∫ø ƒë·ªìng b·ªô h√≥a trong l·∫≠p tr√¨nh ƒëa lu·ªìng, gi√∫p qu·∫£n l√Ω truy c·∫≠p v√†o t√†i nguy√™n d√πng chung. Semaphore ƒë∆∞·ª£c chia l√†m 2 lo·∫°i:

- **Counting Semaphore:** (Semaphore ƒë·∫øm): C√≥ th·ªÉ c√≥ gi√° tr·ªã b·∫•t k·ª≥, gi√∫p qu·∫£n l√Ω m·ªôt s·ªë l∆∞·ª£ng nh·∫•t ƒë·ªãnh c√°c t√†i nguy√™n.
- **Binary Semaphore:** (Semaphore nh·ªã ph√¢n): Ch·ªâ c√≥ hai gi√° tr·ªã 0 ho·∫∑c 1, t∆∞∆°ng t·ª± nh∆∞ m·ªôt mutex (kh√≥a), d√πng ƒë·ªÉ ki·ªÉm so√°t truy c·∫≠p v√†o m·ªôt t√†i nguy√™n duy nh·∫•t.

<br>

Semaphore ƒë∆∞·ª£c kh·ªüi t·∫°o v·ªõi m·ªôt gi√° tr·ªã nguy√™n d∆∞∆°ng, v√† m·ªói l·∫ßn m·ªôt thread y√™u c·∫ßu t√†i nguy√™n, gi√° tr·ªã n√†y s·∫Ω gi·∫£m ƒëi m·ªôt ƒë∆°n v·ªã (down/wait). Khi m·ªôt thread gi·∫£i ph√≥ng t√†i nguy√™n, gi√° tr·ªã semaphore s·∫Ω tƒÉng l√™n m·ªôt ƒë∆°n v·ªã (up/signal).

<br>

C√°c thao t√°c ch√≠nh trong Semaphore:

- **wait (down)**: N·∫øu semaphore l·ªõn h∆°n 0, gi·∫£m n√≥ ƒëi 1. N·∫øu semaphore b·∫±ng 0, thread s·∫Ω ch·ªù ƒë·∫øn khi semaphore > 0.
- **signal (up)**: TƒÉng gi√° tr·ªã semaphore l√™n 1, cho ph√©p c√°c thread kh√°c ti·∫øp t·ª•c.

C++ kh√¥ng h·ªó tr·ª£ tr·ª±c ti·∫øp semaphore trong th∆∞ vi·ªán chu·∫©n, nh∆∞ng b·∫°n c√≥ th·ªÉ s·ª≠ d·ª•ng th∆∞ vi·ªán <semaphore> trong C++20, ho·∫∑c th∆∞ vi·ªán POSIX tr√™n Linux (<semaphore.h>) ho·∫∑c c√°c l·ªõp semaphore t·ª± tri·ªÉn khai.

<br>

üíª **V√≠ d·ª• 1:**
```cpp
/***************************************************************************
 * @file    Ex_Semaphore_1.cpp
 * @brief   Ch∆∞∆°ng tr√¨nh qu·∫£n l√Ω k·∫øt n·ªëi m·∫°ng b·∫±ng semaphore ƒë·∫øm
 * @details Ch∆∞∆°ng tr√¨nh n√†y s·ª≠ d·ª•ng semaphore ƒë·∫øm ƒë·ªÉ gi·ªõi h·∫°n s·ªë l∆∞·ª£ng k·∫øt n·ªëi
 *          m·∫°ng ƒë·ªìng th·ªùi t·ªëi ƒëa l√† 5 k·∫øt n·ªëi. C√°c k·∫øt n·ªëi ƒë∆∞·ª£c th·ª±c hi·ªán th√¥ng
 *          qua c√°c lu·ªìng (threads) v√† gi·∫£ l·∫≠p qu√° tr√¨nh k·∫øt n·ªëi m·∫°ng trong 2 gi√¢y.
 * @version 1.0
 * @date    2024-11-11
 * @author  Anh Nguyen
 ***************************************************************************/

#include <iostream>
#include <thread>
#include <semaphore>
#include <chrono>
#include <mutex>

using namespace std;

/**************************************************************************
 * @brief   Mutex ƒë·ªÉ ƒë·ªìng b·ªô lu·ªìng khi ghi ra terminal
 * @details Mutex n√†y ƒë·∫£m b·∫£o ch·ªâ c√≥ 1 lu·ªìng ghi ra m√†n h√¨nh t·∫°i m·ªôt th·ªùi ƒëi·ªÉm.
 **************************************************************************/
mutex mtx;

/**************************************************************************
 * @brief   ƒê·ªëi t∆∞·ª£ng semaphore ƒë·∫øm cho qu·∫£n l√Ω k·∫øt n·ªëi m·∫°ng
 * @details ƒê·ªëi t∆∞·ª£ng semaphore n√†y gi·ªõi h·∫°n s·ªë l∆∞·ª£ng k·∫øt n·ªëi m·∫°ng ƒë·ªìng th·ªùi
 *          t·ªëi ƒëa l√† 5 k·∫øt n·ªëi, ƒë·∫£m b·∫£o t√†i nguy√™n m·∫°ng ƒë∆∞·ª£c ph√¢n b·ªï h·ª£p l√Ω.
 **************************************************************************/
counting_semaphore<5> connection_semaphore(5);

/**************************************************************************
 * @brief   K·∫øt n·ªëi m·∫°ng gi·∫£ l·∫≠p
 * @details H√†m n√†y s·ª≠ d·ª•ng semaphore ƒë·ªÉ qu·∫£n l√Ω truy c·∫≠p v√†o t√†i nguy√™n m·∫°ng,
 *          m√¥ ph·ªèng th·ªùi gian k·∫øt n·ªëi trong 2 gi√¢y v√† sau ƒë√≥ gi·∫£i ph√≥ng t√†i nguy√™n.
 * @param   id    ID c·ªßa k·∫øt n·ªëi m·∫°ng, gi√∫p ph√¢n bi·ªát c√°c k·∫øt n·ªëi kh√°c nhau.
 * @return  void
 **************************************************************************/
void connect_to_network(int id) 
{
    /**< Khi c√≥ 1 lu·ªìng truy c·∫≠p, semaphore gi·∫£m gi√° tr·ªã ƒëi 1 */
    connection_semaphore.acquire(); 

    /**< Hi·ªÉn th·ªã th√¥ng b√°o ra m√†n h√¨nh terminal, s·ª≠ d·ª•ng mutex ƒë·ªÉ ƒë·∫£m b·∫£o ch·ªâ 1 lu·ªìng ghi ra m√†n h√¨nh */
    unique_lock<mutex> ulock(mtx); 
    cout << "Connection " << id << " ƒëang s·ª≠ d·ª•ng t√†i nguy√™n m·∫°ng...\n";
    ulock.unlock();

    /**< M√¥ ph·ªèng th·ªùi gian k·∫øt n·ªëi */
    this_thread::sleep_for(chrono::seconds(2));

    /**< Hi·ªÉn th·ªã th√¥ng b√°o ra m√†n h√¨nh terminal, s·ª≠ d·ª•ng mutex ƒë·ªÉ ƒë·∫£m b·∫£o ch·ªâ 1 lu·ªìng ghi ra m√†n h√¨nh */
    ulock.lock();
    cout << "Connection " << id << " ƒë√£ gi·∫£i ph√≥ng t√†i nguy√™n m·∫°ng.\n";
    ulock.unlock();

    /**< Sau khi 1 lu·ªìng th·ª±c thi xong, semaphore tƒÉng gi√° tr·ªã th√™m 1 */
    connection_semaphore.release();  // Gi·∫£i ph√≥ng t√†i nguy√™n m·∫°ng
}

int main() 
{
    thread connections[10];     /**< T·∫°o 1 m·∫£ng ch·ª©a 10 lu·ªìng */
    
    for (int i = 0; i < 10; ++i) 
    {
        connections[i] = thread(connect_to_network, i + 1);
    }

    for (auto& connection : connections) 
    {
        connection.join();
    }

    return 0;
}

/**
 * @note    Ch·ªâ bi√™n d·ªãch ƒë∆∞·ª£c v·ªõi C++20 tr·ªü l√™n. Bi√™n d·ªãch v·ªõi l·ªánh:
 *          g++ -std=c++20 Ex_Semaphore_1.cpp -o Ex_Semaphore_1
 */
```

<br>

üíª **V√≠ d·ª• 2:**
```cpp
/**************************************************************************
 * @file    Ex_Semaphore_2.cpp
 * @brief   ƒêi·ªÅu khi·ªÉn m·ªü v√† ƒë√≥ng c·ª≠a xe s·ª≠ d·ª•ng semaphore nh·ªã ph√¢n
 * @details File n√†y ch·ª©a c√°c h√†m ƒë·ªÉ th·ª±c hi·ªán m·ªü v√† ƒë√≥ng c·ª≠a xe √¥ t√¥, ƒë·∫£m b·∫£o
 *          r·∫±ng kh√¥ng c√≥ xung ƒë·ªôt gi·ªØa c√°c thao t√°c m·ªü v√† ƒë√≥ng nh·ªù s·ª≠ d·ª•ng
 *          semaphore nh·ªã ph√¢n. Ch·ªâ m·ªôt thao t√°c m·ªü ho·∫∑c ƒë√≥ng c·ª≠a c√≥ th·ªÉ di·ªÖn
 *          ra t·∫°i m·ªôt th·ªùi ƒëi·ªÉm, ngƒÉn ng·ª´a xung ƒë·ªôt.
 * @version 1.0
 * @date    2024-11-11
 * @author  Anh Nguyen
 **************************************************************************/

#include <iostream>
#include <thread>
#include <semaphore>
#include <chrono>
#include <mutex>

using namespace std;

/**************************************************************************
 * @brief   Mutex ƒë·ªÉ ƒë·ªìng b·ªô lu·ªìng khi ghi ra terminal
 * @details Mutex n√†y ƒë·∫£m b·∫£o ch·ªâ c√≥ 1 lu·ªìng ghi ra m√†n h√¨nh t·∫°i m·ªôt th·ªùi ƒëi·ªÉm.
 **************************************************************************/
mutex mtx;

/**************************************************************************
 * @brief   Semaphore nh·ªã ph√¢n qu·∫£n l√Ω tr·∫°ng th√°i c·ª≠a xe
 * @details Gi√° tr·ªã semaphore l√† 1 khi c·ª≠a s·∫µn s√†ng cho thao t√°c m·ªõi v√† l√† 0 
 *          khi ƒëang thao t√°c (m·ªü ho·∫∑c ƒë√≥ng).
 **************************************************************************/
binary_semaphore door_semaphore(1);

/**************************************************************************
 * @brief   M·ªü c·ª≠a xe
 * @details Ch·ª©c nƒÉng n√†y th·ª±c hi·ªán m·ªü c·ª≠a xe v√† ki·ªÉm so√°t thao t√°c m·ªü b·∫±ng semaphore.
 *          Khi c·ª≠a ƒëang ƒë∆∞·ª£c m·ªü, c√°c thao t√°c kh√°c s·∫Ω b·ªã ngƒÉn ch·∫∑n.
 * @param[in]  id - ID c·ªßa ng∆∞·ªùi ƒëi·ªÅu khi·ªÉn c·ª≠a xe
 * @return  void
 **************************************************************************/
void open_door(int id) 
{
    /**< Kh√≥a semaphore ƒë·ªÉ th·ª±c hi·ªán thao t√°c m·ªü c·ª≠a */
    door_semaphore.acquire();

    /**< Hi·ªÉn th·ªã th√¥ng b√°o ra m√†n h√¨nh terminal, s·ª≠ d·ª•ng mutex ƒë·ªÉ ƒë·∫£m b·∫£o ch·ªâ 1 lu·ªìng ghi ra m√†n h√¨nh */
    unique_lock<mutex> ulock(mtx); 
    cout << "C·ª≠a xe ƒëang m·ªü b·ªüi ng∆∞·ªùi ƒëi·ªÅu khi·ªÉn " << id << ".\n";
    ulock.unlock();

    /**< Gi·∫£ l·∫≠p th·ªùi gian m·ªü c·ª≠a */
    this_thread::sleep_for(chrono::seconds(1));

    /**< Hi·ªÉn th·ªã th√¥ng b√°o ra m√†n h√¨nh terminal, s·ª≠ d·ª•ng mutex ƒë·ªÉ ƒë·∫£m b·∫£o ch·ªâ 1 lu·ªìng ghi ra m√†n h√¨nh */
    ulock.lock();
    cout << "C·ª≠a xe ƒë√£ m·ªü.\n";
    ulock.unlock();

    /**< Gi·∫£i ph√≥ng semaphore sau khi m·ªü c·ª≠a ho√†n t·∫•t */
    door_semaphore.release();
}

/**************************************************************************
 * @brief   ƒê√≥ng c·ª≠a xe
 * @details Ch·ª©c nƒÉng n√†y th·ª±c hi·ªán ƒë√≥ng c·ª≠a xe v√† ki·ªÉm so√°t thao t√°c ƒë√≥ng b·∫±ng semaphore.
 *          Khi c·ª≠a ƒëang ƒë∆∞·ª£c ƒë√≥ng, c√°c thao t√°c kh√°c s·∫Ω b·ªã ngƒÉn ch·∫∑n.
 * @param[in]  id - ID c·ªßa ng∆∞·ªùi ƒëi·ªÅu khi·ªÉn c·ª≠a xe
 * @return  void
 **************************************************************************/
void close_door(int id) 
{
    /**< Kh√≥a semaphore ƒë·ªÉ th·ª±c hi·ªán thao t√°c ƒë√≥ng c·ª≠a */
    door_semaphore.acquire(); 

    /**< Hi·ªÉn th·ªã th√¥ng b√°o ra m√†n h√¨nh terminal, s·ª≠ d·ª•ng mutex ƒë·ªÉ ƒë·∫£m b·∫£o ch·ªâ 1 lu·ªìng ghi ra m√†n h√¨nh */
    unique_lock<mutex> ulock(mtx);      
    cout << "C·ª≠a xe ƒëang ƒë√≥ng b·ªüi ng∆∞·ªùi ƒëi·ªÅu khi·ªÉn " << id << ".\n";
    ulock.unlock();

    /**< Gi·∫£ l·∫≠p th·ªùi gian ƒë√≥ng c·ª≠a */
    this_thread::sleep_for(chrono::seconds(1));

    /**< Hi·ªÉn th·ªã th√¥ng b√°o ra m√†n h√¨nh terminal, s·ª≠ d·ª•ng mutex ƒë·ªÉ ƒë·∫£m b·∫£o ch·ªâ 1 lu·ªìng ghi ra m√†n h√¨nh */
    ulock.lock();
    cout << "C·ª≠a xe ƒë√£ ƒë√≥ng.\n";
    ulock.unlock();

    /**< Gi·∫£i ph√≥ng semaphore sau khi ƒë√≥ng c·ª≠a ho√†n t·∫•t */
    door_semaphore.release();
}

int main() 
{
    // T·∫°o thread ƒë·ªÉ th·ª±c hi·ªán m·ªü c·ª≠a b·ªüi ng∆∞·ªùi ƒëi·ªÅu khi·ªÉn 1
    thread t1(open_door, 1);

    // T·∫°o thread ƒë·ªÉ th·ª±c hi·ªán ƒë√≥ng c·ª≠a b·ªüi ng∆∞·ªùi ƒëi·ªÅu khi·ªÉn 2
    thread t2(close_door, 2);

    // Ch·ªù c·∫£ hai thread ho√†n t·∫•t thao t√°c
    t1.join();
    t2.join();

    return 0;
}

/**
 * @note    Ch·ªâ bi√™n d·ªãch ƒë∆∞·ª£c v·ªõi C++20 tr·ªü l√™n. Bi√™n d·ªãch v·ªõi l·ªánh:
 *          g++ -std=c++20 Ex_Semaphore_2.cpp -o Ex_Semaphore_2
 */
```

<br>

</p>
</details>

<details><summary><b>üìö Race Condition</b></summary>
<p>

Race condition l√† m·ªôt v·∫•n ƒë·ªÅ trong l·∫≠p tr√¨nh ƒëa lu·ªìng x·∫£y ra khi:

- K·∫øt qu·∫£ ho·∫∑c h√†nh vi c·ªßa ch∆∞∆°ng tr√¨nh ph·ª• thu·ªôc v√†o th·ª© t·ª± th·ª±c thi kh√¥ng x√°c ƒë·ªãnh c·ªßa c√°c lu·ªìng.

- Hai ho·∫∑c nhi·ªÅu lu·ªìng truy c·∫≠p v√†o c√πng m·ªôt t√†i nguy√™n chia s·∫ª (bi·∫øn, ngo·∫°i vi) m√† kh√¥ng c√≥ c∆° ch·∫ø ƒë·ªìng b·ªô h√≥a ph√π h·ª£p.

- V√≠ d·ª• ƒëi·ªÉn h√¨nh: Nhi·ªÅu lu·ªìng c√πng truy c·∫≠p ngo·∫°i vi, Nhi·ªÅu lu·ªìng ghi v√†o file log m√† kh√¥ng ƒë·ªìng b·ªô h√≥a.

<br>

</p>
</details>

<details><summary><b>üìö Data Race</b></summary>
<p>

Data race l√† m·ªôt tr∆∞·ªùng h·ª£p c·ª• th·ªÉ c·ªßa race condition x·∫£y ra khi:

- Hai ho·∫∑c nhi·ªÅu lu·ªìng truy c·∫≠p v√†o c√πng m·ªôt d·ªØ li·ªáu (bi·∫øn).

- √çt nh·∫•t m·ªôt trong c√°c lu·ªìng th·ª±c hi·ªán ghi v√†o t√†i nguy√™n.

- V√≠ d·ª• ƒëi·ªÉn h√¨nh: Hai lu·ªìng ghi v√†o c√πng m·ªôt bi·∫øn chia s·∫ª m√† kh√¥ng ƒë·ªìng b·ªô h√≥a.

<br>

</p>
</details>

</p>
</details>

<details><summary><b>4. Asynchronous</b></summary>
<p>

<details><summary><b>üìö Gi·ªõi thi·ªáu </b></summary>
<p>

- Lu·ªìng b·∫•t ƒë·ªìng b·ªô (asynchronous thread) l√† m·ªôt c∆° ch·∫ø trong l·∫≠p tr√¨nh cho ph√©p th·ª±c thi m·ªôt t√°c v·ª• tr√™n m·ªôt lu·ªìng ri√™ng bi·ªát m√† kh√¥ng l√†m gi√°n ƒëo·∫°n lu·ªìng ch√≠nh, ƒë·ªìng th·ªùi k·∫øt qu·∫£ c·ªßa t√°c v·ª• c√≥ th·ªÉ ƒë∆∞·ª£c truy v·∫•n sau khi lu·ªìng k·∫øt th√∫c.
- Lu·ªìng b·∫•t ƒë·ªìng b·ªô trong C++ th∆∞·ªùng ƒë∆∞·ª£c t·∫°o ra th√¥ng qua vi·ªác s·ª≠ d·ª•ng ``` std::async ``` t·ª´ th∆∞ vi·ªán ``` <future> ```. Khi b·∫°n g·ªçi m·ªôt h√†m s·ª≠ d·ª•ng ``` std::async ```, n√≥ s·∫Ω th·ª±c thi h√†m ƒë√≥ tr√™n m·ªôt lu·ªìng ri√™ng bi·ªát, v√† tr·∫£ v·ªÅ m·ªôt ƒë·ªëi t∆∞·ª£ng ``` std::future ```.
- Lu·ªìng b·∫•t ƒë·ªìng b·ªô kh√°c v·ªõi lu·ªìng th√¥ng th∆∞·ªùng ·ªü ch·ªó:

	+ Lu·ªìng ƒë∆∞·ª£c qu·∫£n l√Ω t·ª± ƒë·ªông b·ªüi h·ªá th·ªëng runtime c·ªßa C++.
	+ C√°c lu·ªìng c·ªßa ``` std::thread ``` kh√¥ng c√≥ c∆° ch·∫ø x·ª≠ l√Ω k·∫øt qu·∫£, nghƒ©a l√† ƒë·ªëi v·ªõi ``` join ``` mu·ªën l·∫•y k·∫øt qu·∫£ cu·ªëi c√πng c·ªßa lu·ªìng th√¨ ph·∫£i khai b√°o 1 bi·∫øn to√†n c·ª•c ƒë·ªÉ l∆∞u tr·ªØ v√†o ƒë√≥, ƒë·ªëi v·ªõi ``` detach ``` th√¨ kh√¥ng l·∫•y ƒë∆∞·ª£c k·∫øt qu·∫£ cu·ªëi c√πng c·ªßa lu·ªìng d√π c√≥ khai b√°o bi·∫øn to√†n c·ª•c ƒë·ªÉ l∆∞u tr·ªØ. Nh∆∞ng ƒë·ªëi v·ªõi lu·ªìng b·∫•t ƒë·ªìng b·ªô th√¨ k·∫øt qu·∫£ c·ªßa lu·ªìng c√≥ th·ªÉ ƒë∆∞·ª£c l·∫•y ra khi c·∫ßn thi·∫øt.

- Trong C++, l·∫≠p tr√¨nh b·∫•t ƒë·ªìng b·ªô cho ph√©p ch·∫°y c√°c t√°c v·ª• trong c√°c lu·ªìng ri√™ng bi·ªát, x·ª≠ l√Ω c√°c t√°c v·ª• m·∫•t th·ªùi gian (nh∆∞ I/O, t√≠nh to√°n n·∫∑ng) m√† kh√¥ng l√†m gi√°n ƒëo·∫°n lu·ªìng ch√≠nh. C√°c th√†nh ph·∫ßn ch√≠nh ƒë·ªÉ h·ªó tr·ª£ l·∫≠p tr√¨nh b·∫•t ƒë·ªìng b·ªô trong C++ bao g·ªìm:

	+ ``` std::async ```: Kh·ªüi ch·∫°y m·ªôt t√°c v·ª• b·∫•t ƒë·ªìng b·ªô, tr·∫£ v·ªÅ ƒë·ªëi t∆∞·ª£ng.
	+ ``` std::future ```: ƒê∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ l∆∞u tr·ªØ k·∫øt qu·∫£ c·ªßa m·ªôt t√°c v·ª• s·∫Ω ho√†n th√†nh trong t∆∞∆°ng lai.
	+ ``` std::shared_future ```: Cho ph√©p nhi·ªÅu lu·ªìng c√πng truy c·∫≠p k·∫øt qu·∫£ c·ªßa m·ªôt t√°c v·ª• b·∫•t ƒë·ªìng b·ªô.

<br>

</p>
</details>

<details><summary><b>üìö T·∫°o v√† ch·∫°y lu·ªìng b·∫•t ƒë·ªìng b·ªô </b></summary>
<p>

- ``` std::async ``` l√† m·ªôt h√†m trong C++ (t·ª´ C++11 tr·ªü ƒëi) t·∫°o ra m·ªôt lu·ªìng ƒë·ªÉ th·ª±c thi m·ªôt c√¥ng vi·ªác (task) c√≥ th·ªÉ ch·∫°y b·∫•t ƒë·ªìng b·ªô, d·ª±a tr√™n m·ªôt h√†m ho·∫∑c bi·ªÉu th·ª©c lambda m√† b·∫°n cung c·∫•p. K·∫øt qu·∫£ c·ªßa c√¥ng vi·ªác n√†y ƒë∆∞·ª£c tr·∫£ v·ªÅ d∆∞·ªõi d·∫°ng ``` std::future ```, ki·ªÉu d·ªØ li·ªáu cho ph√©p truy xu·∫•t gi√° tr·ªã c·ªßa t√°c v·ª• sau khi n√≥ ho√†n t·∫•t.
- C√∫ ph√°p: ``` std::future<T> std::async(std::launch policy, Callable&& func, Args&&... args) ```

- **policy**: ch·∫ø ƒë·ªô ch·∫°y:

	+ ``` std::launch::async ```: h√†m s·∫Ω ch·∫°y ngay l·∫≠p t·ª©c tr√™n m·ªôt lu·ªìng m·ªõi.
	+ ``` std::launch::deferred ```: h√†m ch·ªâ ch·∫°y khi k·∫øt qu·∫£ c·ªßa ``` std::future ``` ƒë∆∞·ª£c y√™u c·∫ßu (lazy evaluation), nghƒ©a l√† khi b·∫°n g·ªçi ``` future.get() ```.

- **func**: H√†m ho·∫∑c bi·ªÉu th·ª©c lambda c·∫ßn th·ª±c hi·ªán b·∫•t ƒë·ªìng b·ªô.
- **args**: C√°c tham s·ªë truy·ªÅn v√†o func (n·∫øu c√≥).

<br>

</p>
</details>

<details><summary><b>üìö Truy xu·∫•t k·∫øt qu·∫£ </b></summary>
<p>

- Khi ``` std::async ``` ƒë∆∞·ª£c g·ªçi, m·ªôt t√°c v·ª• b·∫•t ƒë·ªìng b·ªô ƒë∆∞·ª£c t·∫°o ra v√† v√πng b·ªô nh·ªõ cho k·∫øt qu·∫£ s·∫Ω ƒë∆∞·ª£c c·∫•p ph√°t ƒë·ªông (tr√™n heap).
- ``` std::future ``` ho·∫∑c ``` std::shared_future ``` s·∫Ω n·∫Øm quy·ªÅn qu·∫£n l√Ω k·∫øt qu·∫£ n√†y v√† gi·ªØ m·ªôt con tr·ªè ƒë·∫øn v√πng nh·ªõ ch·ª©a k·∫øt qu·∫£.
- Khi ``` get() ``` ƒë∆∞·ª£c g·ªçi, gi√° tr·ªã ƒë∆∞·ª£c tr·∫£ v·ªÅ t·ª´ b·ªô nh·ªõ n√†y. N·∫øu l√† ``` std::future ```, ``` get() ``` s·∫Ω ch·ªâ c√≥ th·ªÉ g·ªçi m·ªôt l·∫ßn. N·∫øu l√† ``` std::shared_future ```, ``` get() ``` c√≥ th·ªÉ g·ªçi nhi·ªÅu l·∫ßn.
- S·ª± kh√°c nhau gi·ªØa ``` std::future ``` v√† ``` std::shared_future ```:

	+ ``` std::future ```: ƒê·∫°i di·ªán cho m·ªôt gi√° tr·ªã s·∫Ω c√≥ trong t∆∞∆°ng lai v√† ch·ªâ cho ph√©p m·ªôt lu·ªìng duy nh·∫•t l·∫•y gi√° tr·ªã ƒë√≥. Sau khi ph∆∞∆°ng th·ª©c get() ƒë∆∞·ª£c g·ªçi, gi√° tr·ªã s·∫Ω ƒë∆∞·ª£c "di chuy·ªÉn" v√† kh√¥ng th·ªÉ l·∫•y l·∫°i t·ª´ std::future l·∫ßn n·ªØa. N·∫øu c√≥ nhi·ªÅu thread c·ªë g·∫Øng g·ªçi get() tr√™n c√πng m·ªôt std::future, ch∆∞∆°ng tr√¨nh s·∫Ω b·ªã l·ªói.
	+ ``` std::shared_future ```: Cho ph√©p nhi·ªÅu lu·ªìng c√πng chia s·∫ª v√† truy c·∫≠p k·∫øt qu·∫£ c·ªßa m·ªôt t√°c v·ª• b·∫•t ƒë·ªìng b·ªô. ƒê·ªëi t∆∞·ª£ng shared_future c√≥ th·ªÉ ƒë∆∞·ª£c sao ch√©p v√† chia s·∫ª gi·ªØa c√°c thread, m·ªói thread c√≥ th·ªÉ g·ªçi get() m√† kh√¥ng l√†m m·∫•t k·∫øt qu·∫£.

- Khi kh·ªüi t·∫°o b·∫±ng ``` std::async ```, std::future l√† l·ª±a ch·ªçn m·∫∑c ƒë·ªãnh. N·∫øu c·∫ßn chia s·∫ª k·∫øt qu·∫£ gi·ªØa nhi·ªÅu thread, b·∫°n ph·∫£i chuy·ªÉn ``` std::future ``` sang ``` std::shared_future ```.

<br>

üíª **V√≠ d·ª• 1:**
```cpp
#include <iostream>
#include <thread>
#include <future>
#include <mutex>

using namespace std;

int sensor_data = 0;

mutex mtx;

void delay(uint32_t time){this_thread::sleep_for(chrono::seconds(time));}

int sensor_read(){
    for (int i=0; i<7; i++){
        unique_lock<mutex> ulock(mtx);
        cout << "sensor read, i = " << i << endl;
        ulock.unlock();
        delay(1);
    }
    sensor_data = rand() % 100;
    cout << "Read data done!\n";
    return sensor_data;
}

void task1(uint32_t time){
    int i = 0;
    while(1){
        unique_lock<mutex> ulock(mtx);
        cout << "task 1, i = " << i++ << endl;
        ulock.unlock();
        delay(time);
    }
}

void task2(uint32_t time){
    int i = 0;
    while(1){
        unique_lock<mutex> ulock(mtx);
        cout << "task 2, i = " << i++ << endl;
        ulock.unlock();
        delay(time);
    }
}

int main(int argc, char const *argv[])
{
    future<int> sensor_future = async(launch::async, sensor_read);
    /*
    std::async v·ªõi launch::async s·∫Ω kh·ªüi ch·∫°y sensor_read trong m·ªôt thread ri√™ng bi·ªát,
    nghƒ©a l√† h√†m `sensor_read` ch·∫°y trong m·ªôt thread ri√™ng m√† kh√¥ng l√†m ·∫£nh h∆∞·ªüng ch∆∞∆°ng tr√¨nh ch√≠nh.
    Ki·ªÉu tr·∫£ v·ªÅ l√† future<int>, cho ph√©p l·∫•y gi√° tr·ªã k·∫øt qu·∫£ t·ª´ sensor_read sau khi ho√†n th√†nh.
    */

    thread t1(task1, 1);     // t1: ƒë·∫°i di·ªán cho lu·ªìng 1
    thread t2(task2, 3);     // t2: ƒë·∫°i di·ªán cho lu·ªìng 2

    int i = 0;
    while (i<10){
        unique_lock<mutex> ulock(mtx);
        cout << "This is main, i = " << i++ << endl;
        ulock.unlock();
        delay(1);
    }

    cout << "Data ƒë√£ ho√†n th√†nh 1: " << sensor_future.get() << endl;// delete
    // cout << "Data ƒë√£ ho√†n th√†nh 2: " << sensor_future.get() << endl;

    t1.join();
    t2.join();

    return 0;
}
```

<br>

**V√≠ d·ª• 2:**

```cpp
#include <iostream>
#include <thread>
#include <future>
#include <mutex>
#include <chrono>

using namespace std;

mutex mtx;

int asyncTask(){
    this_thread::sleep_for(chrono::seconds(3));
    return 100;
}

void processResult(int id, shared_future<int> f){
    unique_lock<mutex> lock(mtx);
    cout << "Task " << id << ": " << f.get() << endl;
    lock.unlock();
}
/*********************************************************************************************************************
 * H√†m n√†y nh·∫≠n hai tham s·ªë: id l√† m·ªôt s·ªë nguy√™n ƒë·∫°i di·ªán cho ID c·ªßa t√°c v·ª• v√† f l√† m·ªôt shared_future<int> d√πng ƒë·ªÉ l·∫•y k·∫øt 
 * qu·∫£ t·ª´ t√°c v·ª• b·∫•t ƒë·ªìng b·ªô.
 * Trong h√†m, f.get() ƒë∆∞·ª£c g·ªçi ƒë·ªÉ l·∫•y gi√° tr·ªã t·ª´ shared_future v√† in ra k·∫øt qu·∫£. K·∫øt qu·∫£ n√†y s·∫Ω l√† 100 v√¨ ƒë√≥ l√† gi√° tr·ªã 
 * tr·∫£ v·ªÅ c·ªßa asyncTask.
 * shared_future cho ph√©p nhi·ªÅu lu·ªìng c√πng truy c·∫≠p v√†o k·∫øt qu·∫£ c·ªßa m·ªôt t√°c v·ª• b·∫•t ƒë·ªìng b·ªô.
 ********************************************************************************************************************/

int main(int argc, char const *argv[])
{
    shared_future<int> shared_ft = async(launch::async, asyncTask).share();
    /*********************************************************************************************************************
     * Ph∆∞∆°ng th·ª©c .share() ƒë∆∞·ª£c g·ªçi tr√™n ƒë·ªëi t∆∞·ª£ng future ƒë·ªÉ chuy·ªÉn ƒë·ªïi n√≥ th√†nh std::shared_future<int>. ƒêi·ªÅu n√†y cho 
     * ph√©p nhi·ªÅu lu·ªìng c√πng chia s·∫ª k·∫øt qu·∫£ c·ªßa t√°c v·ª• m√† kh√¥ng l√†m m·∫•t gi√° tr·ªã.
     ********************************************************************************************************************/

    thread t1(processResult, 1, shared_ft);
    thread t2(processResult, 2, shared_ft);
    /*********************************************************************************************************************
     * t1 v√† t2 ƒë∆∞·ª£c kh·ªüi t·∫°o ƒë·ªÉ ch·∫°y h√†m processResult v·ªõi c√°c tham s·ªë t∆∞∆°ng ·ª©ng l√† 1 v√† 2 cho id, c√πng v·ªõi shared_ft 	 
     * (k·∫øt qu·∫£ chia s·∫ª).
     * C·∫£ hai thread s·∫Ω ch·∫°y song song v√† g·ªçi f.get() t·ª´ shared_ft ƒë·ªÉ l·∫•y k·∫øt qu·∫£ t·ª´ t√°c v·ª• asyncTask. V√¨ shared_future 
     * cho ph√©p chia s·∫ª k·∫øt qu·∫£, n√™n vi·ªác g·ªçi f.get() tr√™n c√°c thread kh√°c nhau v·∫´n an to√†n v√† c√≥ th·ªÉ th·ª±c hi·ªán ƒë·ªìng 
     * th·ªùi.t1 v√† t2 ƒë∆∞·ª£c kh·ªüi t·∫°o ƒë·ªÉ ch·∫°y h√†m processResult v·ªõi c√°c tham s·ªë t∆∞∆°ng ·ª©ng l√† 1 v√† 2 cho id, c√πng v·ªõi 
     * shared_ft (k·∫øt qu·∫£ chia s·∫ª).
     * C·∫£ hai thread s·∫Ω ch·∫°y song song v√† g·ªçi f.get() t·ª´ shared_ft ƒë·ªÉ l·∫•y k·∫øt qu·∫£ t·ª´ t√°c v·ª• asyncTask. V√¨ shared_future 
     * cho ph√©p chia s·∫ª k·∫øt qu·∫£, n√™n vi·ªác g·ªçi f.get() tr√™n c√°c thread kh√°c nhau v·∫´n an to√†n v√† c√≥ th·ªÉ th·ª±c hi·ªán ƒë·ªìng th·ªùi.
     *********************************************************************************************************************/


    t1.join();
    t2.join();

    return 0;
}
```

<br>

üíª **V√≠ d·ª• 2:**
```cpp
#include <iostream>
#include <thread>
#include <future>
#include <vector>
#include <chrono>
#include <conio.h>

using namespace std;

// H√†m gi·∫£ l·∫≠p t·∫£i t√†i nguy√™n
string loadResource(const std::string& resourceName) 
{
    this_thread::sleep_for(chrono::seconds(2)); // Gi·∫£ l·∫≠p th·ªùi gian t·∫£i
    return "Resource " + resourceName + " loaded.";
}

// C·∫≠p nh·∫≠t tr·∫°ng th√°i nh√¢n v·∫≠t d·ª±a tr√™n ƒë·∫ßu v√†o
void updateGameState(char input, int& playerX, int& playerY) 
{
    switch (input) 
    {
        case 'w': --playerY; break; // Di chuy·ªÉn l√™n
        case 's': ++playerY; break; // Di chuy·ªÉn xu·ªëng
        case 'a': --playerX; break; // Di chuy·ªÉn tr√°i
        case 'd': ++playerX; break; // Di chuy·ªÉn ph·∫£i
        default: break;
    }
}

// Render tr·∫°ng th√°i game
void render(int playerX, int playerY) 
{
    // system("cls"); // X√≥a m√†n h√¨nh (ch·ªâ d√πng tr√™n Windows)
    cout << "Rendering game...\n";
    cout << "Player position: (" << playerX << ", " << playerY << ")\n";
}

int main() 
{
    std::cout << "Game starting...\n";

    // T·∫£i t√†i nguy√™n b·∫•t ƒë·ªìng b·ªô
    auto textureFuture = async(launch::async, loadResource, "Texture");
    auto soundFuture   = async(launch::async, loadResource, "Sound");

    // Bi·∫øn tr·∫°ng th√°i game
    int playerX = 0, playerY = 0;
    char input = 0;

    // C·ªù ƒë·ªÉ ki·ªÉm tra t√†i nguy√™n ƒë√£ t·∫£i xong
    bool textureLoaded = false;
    bool soundLoaded = false;

    bool isRunning = true;
    while (isRunning) 
    {
        // 1. X·ª≠ l√Ω ƒë·∫ßu v√†o
        if (_kbhit()) // Ki·ªÉm tra c√≥ ph√≠m ƒë∆∞·ª£c nh·∫•n
        { 
            input = _getch(); // L·∫•y k√Ω t·ª± ph√≠m

            if (input == 'q') 
            {
                isRunning = false; // Tho√°t game
            } 
            else 
            {
                updateGameState(input, playerX, playerY);
            }
        }

        // 2. Render game
        render(playerX, playerY);

        // 3. Ki·ªÉm tra t√†i nguy√™n ƒë√£ t·∫£i xong ch∆∞a
        if (!textureLoaded && textureFuture.wait_for(chrono::seconds(0)) == future_status::ready) 
        {
            cout << textureFuture.get() << "\n";
            textureLoaded = true; // ƒê√°nh d·∫•u ƒë√£ t·∫£i xong
        }

        if (!soundLoaded && soundFuture.wait_for(chrono::seconds(0)) == future_status::ready) 
        {
            cout << soundFuture.get() << "\n";
            soundLoaded = true; // ƒê√°nh d·∫•u ƒë√£ t·∫£i xong
        }

        if (textureLoaded && soundLoaded) 
        {
            cout << "All resources loaded. Game is fully ready!\n";
        }

        // 4. T·∫°m d·ª´ng m·ªôt ch√∫t ƒë·ªÉ gi·∫£m t·∫£i CPU
        this_thread::sleep_for(chrono::milliseconds(1000));
    }

    cout << "Game exited.\n";
    return 0;
}

/**
 * Lu·ªìng ch√≠nh:
 *      X·ª≠ l√Ω ƒë·∫ßu v√†o t·ª´ ng∆∞·ªùi ch∆°i.
 *      C·∫≠p nh·∫≠t tr·∫°ng th√°i game (di chuy·ªÉn nh√¢n v·∫≠t d·ª±a tr√™n ƒë·∫ßu v√†o).
 *      Hi·ªÉn th·ªã khung h√¨nh (render).'
 *
 * Lu·ªìng b·∫•t ƒë·ªìng b·ªô:
 *      T·∫£i t√†i nguy√™n ƒë·ªì h·ªça v√† √¢m thanh trong n·ªÅn (nh∆∞ texture ho·∫∑c nh·∫°c n·ªÅn).
 * 
 * Trong khi t·∫£i t√†i nguy√™n:
 * 	Lu·ªìng ch√≠nh hi·ªÉn th·ªã m√†n h√¨nh "Loading..." ƒë·ªÉ ng∆∞·ªùi ch∆°i bi·∫øt game ƒëang chu·∫©n b·ªã.
 * 	Ng∆∞·ªùi ch∆°i c√≥ th·ªÉ nh·∫•n ph√≠m ƒë·ªÉ th·ª≠ t∆∞∆°ng t√°c (nh∆∞ng nh√¢n v·∫≠t ch∆∞a di chuy·ªÉn ƒë∆∞·ª£c v√¨ d·ªØ li·ªáu ch∆∞a s·∫µn s√†ng).
 *
 * Sau khi t·∫£i t√†i nguy√™n:
 * 	Lu·ªìng b·∫•t ƒë·ªìng b·ªô b√°o r·∫±ng t√†i nguy√™n ƒë√£ s·∫µn s√†ng b·∫±ng c√°ch ƒë·∫∑t isGameReady = true.
 * 	Lu·ªìng ch√≠nh chuy·ªÉn sang tr·∫°ng th√°i ho√†n thi·ªán, cho ph√©p ng∆∞·ªùi ch∆°i ƒëi·ªÅu khi·ªÉn nh√¢n v·∫≠t v√† hi·ªÉn th·ªã ƒë·∫ßy ƒë·ªß th√¥ng tin.
 */
```

<br>

</p>
</details>

</p>
</details>

</p>
</details>
 
</p>
</details>
